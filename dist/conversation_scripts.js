/******/ (() => { // webpackBootstrap
/******/ 	var __webpack_modules__ = ({

/***/ "./node_modules/@disciple.tools/web-components/index.js":
/*!**************************************************************!*\
  !*** ./node_modules/@disciple.tools/web-components/index.js ***!
  \**************************************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   DtAlert: () => (/* reexport safe */ _src_components_layout_dt_alert_dt_alert_js__WEBPACK_IMPORTED_MODULE_18__.DtAlert),
/* harmony export */   DtBase: () => (/* reexport safe */ _src_components_dt_base_js__WEBPACK_IMPORTED_MODULE_23__["default"]),
/* harmony export */   DtButton: () => (/* reexport safe */ _src_components_form_dt_button_dt_button_js__WEBPACK_IMPORTED_MODULE_0__.DtButton),
/* harmony export */   DtChurchHealthCircle: () => (/* reexport safe */ _src_components_form_dt_church_health_circle_dt_church_health_circle_js__WEBPACK_IMPORTED_MODULE_1__.DtChurchHealthCircle),
/* harmony export */   DtCommChannel: () => (/* reexport safe */ _src_components_form_dt_communication_channel_dt_comm_channel_js__WEBPACK_IMPORTED_MODULE_16__.DtCommChannel),
/* harmony export */   DtConnection: () => (/* reexport safe */ _src_components_form_dt_connection_dt_connection_js__WEBPACK_IMPORTED_MODULE_2__.DtConnection),
/* harmony export */   DtCopyText: () => (/* reexport safe */ _src_components_form_dt_copy_text_dt_copy_text_js__WEBPACK_IMPORTED_MODULE_3__.DtCopyText),
/* harmony export */   DtDate: () => (/* reexport safe */ _src_components_form_dt_date_dt_date_js__WEBPACK_IMPORTED_MODULE_4__.DtDate),
/* harmony export */   DtFormBase: () => (/* reexport safe */ _src_components_form_dt_form_base_js__WEBPACK_IMPORTED_MODULE_17__["default"]),
/* harmony export */   DtIcon: () => (/* reexport safe */ _src_components_icons_dt_icon_js__WEBPACK_IMPORTED_MODULE_22__.DtIcon),
/* harmony export */   DtLabel: () => (/* reexport safe */ _src_components_form_dt_label_dt_label_js__WEBPACK_IMPORTED_MODULE_5__.DtLabel),
/* harmony export */   DtList: () => (/* reexport safe */ _src_components_layout_dt_list_dt_list_js__WEBPACK_IMPORTED_MODULE_19__.DtList),
/* harmony export */   DtLocation: () => (/* reexport safe */ _src_components_form_dt_location_dt_location_js__WEBPACK_IMPORTED_MODULE_6__.DtLocation),
/* harmony export */   DtLocationMap: () => (/* reexport safe */ _src_components_form_dt_location_map_dt_location_map_js__WEBPACK_IMPORTED_MODULE_7__.DtLocationMap),
/* harmony export */   DtMapModal: () => (/* reexport safe */ _src_components_form_dt_location_map_dt_map_modal_js__WEBPACK_IMPORTED_MODULE_8__.DtMapModal),
/* harmony export */   DtModal: () => (/* reexport safe */ _src_components_layout_dt_modal_dt_modal_js__WEBPACK_IMPORTED_MODULE_20__.DtModal),
/* harmony export */   DtMultiSelect: () => (/* reexport safe */ _src_components_form_dt_multi_select_dt_multi_select_js__WEBPACK_IMPORTED_MODULE_9__.DtMultiSelect),
/* harmony export */   DtNumberField: () => (/* reexport safe */ _src_components_form_dt_number_dt_number_js__WEBPACK_IMPORTED_MODULE_10__.DtNumberField),
/* harmony export */   DtSingleSelect: () => (/* reexport safe */ _src_components_form_dt_single_select_dt_single_select_js__WEBPACK_IMPORTED_MODULE_11__.DtSingleSelect),
/* harmony export */   DtTags: () => (/* reexport safe */ _src_components_form_dt_tags_dt_tags_js__WEBPACK_IMPORTED_MODULE_12__.DtTags),
/* harmony export */   DtText: () => (/* reexport safe */ _src_components_form_dt_text_dt_text_js__WEBPACK_IMPORTED_MODULE_13__.DtText),
/* harmony export */   DtTextArea: () => (/* reexport safe */ _src_components_form_dt_textarea_dt_textarea_js__WEBPACK_IMPORTED_MODULE_14__.DtTextArea),
/* harmony export */   DtTile: () => (/* reexport safe */ _src_components_layout_dt_tile_dt_tile_js__WEBPACK_IMPORTED_MODULE_21__.DtTile),
/* harmony export */   DtToggle: () => (/* reexport safe */ _src_components_form_dt_toggle_dt_toggle_js__WEBPACK_IMPORTED_MODULE_15__.DtToggle)
/* harmony export */ });
/* harmony import */ var _src_components_form_dt_button_dt_button_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./src/components/form/dt-button/dt-button.js */ "./node_modules/@disciple.tools/web-components/src/components/form/dt-button/dt-button.js");
/* harmony import */ var _src_components_form_dt_church_health_circle_dt_church_health_circle_js__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ./src/components/form/dt-church-health-circle/dt-church-health-circle.js */ "./node_modules/@disciple.tools/web-components/src/components/form/dt-church-health-circle/dt-church-health-circle.js");
/* harmony import */ var _src_components_form_dt_connection_dt_connection_js__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! ./src/components/form/dt-connection/dt-connection.js */ "./node_modules/@disciple.tools/web-components/src/components/form/dt-connection/dt-connection.js");
/* harmony import */ var _src_components_form_dt_copy_text_dt_copy_text_js__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(/*! ./src/components/form/dt-copy-text/dt-copy-text.js */ "./node_modules/@disciple.tools/web-components/src/components/form/dt-copy-text/dt-copy-text.js");
/* harmony import */ var _src_components_form_dt_date_dt_date_js__WEBPACK_IMPORTED_MODULE_4__ = __webpack_require__(/*! ./src/components/form/dt-date/dt-date.js */ "./node_modules/@disciple.tools/web-components/src/components/form/dt-date/dt-date.js");
/* harmony import */ var _src_components_form_dt_label_dt_label_js__WEBPACK_IMPORTED_MODULE_5__ = __webpack_require__(/*! ./src/components/form/dt-label/dt-label.js */ "./node_modules/@disciple.tools/web-components/src/components/form/dt-label/dt-label.js");
/* harmony import */ var _src_components_form_dt_location_dt_location_js__WEBPACK_IMPORTED_MODULE_6__ = __webpack_require__(/*! ./src/components/form/dt-location/dt-location.js */ "./node_modules/@disciple.tools/web-components/src/components/form/dt-location/dt-location.js");
/* harmony import */ var _src_components_form_dt_location_map_dt_location_map_js__WEBPACK_IMPORTED_MODULE_7__ = __webpack_require__(/*! ./src/components/form/dt-location-map/dt-location-map.js */ "./node_modules/@disciple.tools/web-components/src/components/form/dt-location-map/dt-location-map.js");
/* harmony import */ var _src_components_form_dt_location_map_dt_map_modal_js__WEBPACK_IMPORTED_MODULE_8__ = __webpack_require__(/*! ./src/components/form/dt-location-map/dt-map-modal.js */ "./node_modules/@disciple.tools/web-components/src/components/form/dt-location-map/dt-map-modal.js");
/* harmony import */ var _src_components_form_dt_multi_select_dt_multi_select_js__WEBPACK_IMPORTED_MODULE_9__ = __webpack_require__(/*! ./src/components/form/dt-multi-select/dt-multi-select.js */ "./node_modules/@disciple.tools/web-components/src/components/form/dt-multi-select/dt-multi-select.js");
/* harmony import */ var _src_components_form_dt_number_dt_number_js__WEBPACK_IMPORTED_MODULE_10__ = __webpack_require__(/*! ./src/components/form/dt-number/dt-number.js */ "./node_modules/@disciple.tools/web-components/src/components/form/dt-number/dt-number.js");
/* harmony import */ var _src_components_form_dt_single_select_dt_single_select_js__WEBPACK_IMPORTED_MODULE_11__ = __webpack_require__(/*! ./src/components/form/dt-single-select/dt-single-select.js */ "./node_modules/@disciple.tools/web-components/src/components/form/dt-single-select/dt-single-select.js");
/* harmony import */ var _src_components_form_dt_tags_dt_tags_js__WEBPACK_IMPORTED_MODULE_12__ = __webpack_require__(/*! ./src/components/form/dt-tags/dt-tags.js */ "./node_modules/@disciple.tools/web-components/src/components/form/dt-tags/dt-tags.js");
/* harmony import */ var _src_components_form_dt_text_dt_text_js__WEBPACK_IMPORTED_MODULE_13__ = __webpack_require__(/*! ./src/components/form/dt-text/dt-text.js */ "./node_modules/@disciple.tools/web-components/src/components/form/dt-text/dt-text.js");
/* harmony import */ var _src_components_form_dt_textarea_dt_textarea_js__WEBPACK_IMPORTED_MODULE_14__ = __webpack_require__(/*! ./src/components/form/dt-textarea/dt-textarea.js */ "./node_modules/@disciple.tools/web-components/src/components/form/dt-textarea/dt-textarea.js");
/* harmony import */ var _src_components_form_dt_toggle_dt_toggle_js__WEBPACK_IMPORTED_MODULE_15__ = __webpack_require__(/*! ./src/components/form/dt-toggle/dt-toggle.js */ "./node_modules/@disciple.tools/web-components/src/components/form/dt-toggle/dt-toggle.js");
/* harmony import */ var _src_components_form_dt_communication_channel_dt_comm_channel_js__WEBPACK_IMPORTED_MODULE_16__ = __webpack_require__(/*! ./src/components/form/dt-communication-channel/dt-comm-channel.js */ "./node_modules/@disciple.tools/web-components/src/components/form/dt-communication-channel/dt-comm-channel.js");
/* harmony import */ var _src_components_form_dt_form_base_js__WEBPACK_IMPORTED_MODULE_17__ = __webpack_require__(/*! ./src/components/form/dt-form-base.js */ "./node_modules/@disciple.tools/web-components/src/components/form/dt-form-base.js");
/* harmony import */ var _src_components_layout_dt_alert_dt_alert_js__WEBPACK_IMPORTED_MODULE_18__ = __webpack_require__(/*! ./src/components/layout/dt-alert/dt-alert.js */ "./node_modules/@disciple.tools/web-components/src/components/layout/dt-alert/dt-alert.js");
/* harmony import */ var _src_components_layout_dt_list_dt_list_js__WEBPACK_IMPORTED_MODULE_19__ = __webpack_require__(/*! ./src/components/layout/dt-list/dt-list.js */ "./node_modules/@disciple.tools/web-components/src/components/layout/dt-list/dt-list.js");
/* harmony import */ var _src_components_layout_dt_modal_dt_modal_js__WEBPACK_IMPORTED_MODULE_20__ = __webpack_require__(/*! ./src/components/layout/dt-modal/dt-modal.js */ "./node_modules/@disciple.tools/web-components/src/components/layout/dt-modal/dt-modal.js");
/* harmony import */ var _src_components_layout_dt_tile_dt_tile_js__WEBPACK_IMPORTED_MODULE_21__ = __webpack_require__(/*! ./src/components/layout/dt-tile/dt-tile.js */ "./node_modules/@disciple.tools/web-components/src/components/layout/dt-tile/dt-tile.js");
/* harmony import */ var _src_components_icons_dt_icon_js__WEBPACK_IMPORTED_MODULE_22__ = __webpack_require__(/*! ./src/components/icons/dt-icon.js */ "./node_modules/@disciple.tools/web-components/src/components/icons/dt-icon.js");
/* harmony import */ var _src_components_dt_base_js__WEBPACK_IMPORTED_MODULE_23__ = __webpack_require__(/*! ./src/components/dt-base.js */ "./node_modules/@disciple.tools/web-components/src/components/dt-base.js");
/*
  Form Components
*/




















/*
  Layout Components
*/









/***/ }),

/***/ "./node_modules/@disciple.tools/web-components/src/components/dt-base.js":
/*!*******************************************************************************!*\
  !*** ./node_modules/@disciple.tools/web-components/src/components/dt-base.js ***!
  \*******************************************************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "default": () => (/* binding */ DtBase)
/* harmony export */ });
/* harmony import */ var lit__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! lit */ "./node_modules/lit/index.js");
/* harmony import */ var _lit_localize__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! @lit/localize */ "./node_modules/@lit/localize/lit-localize.js");
/* harmony import */ var _i18n_localization_js__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! ../i18n/localization.js */ "./node_modules/@disciple.tools/web-components/src/i18n/localization.js");
/* harmony import */ var _services_apiService_js__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(/*! ../services/apiService.js */ "./node_modules/@disciple.tools/web-components/src/services/apiService.js");
/* harmony import */ var element_internals_polyfill__WEBPACK_IMPORTED_MODULE_4__ = __webpack_require__(/*! element-internals-polyfill */ "./node_modules/element-internals-polyfill/dist/index.js");





 // eslint-disable-line import/no-extraneous-dependencies

class DtBase extends lit__WEBPACK_IMPORTED_MODULE_0__.LitElement {
  static get properties() {
    return {
      RTL: { type: String },
      locale: { type: String },
      apiRoot: { type: String, reflect: false },
      postType: { type: String, reflect: false },
      postID: { type: String, reflect: false },
    };
  }

  /**
   * return the element to proxy focus to
   */
  get _focusTarget() {
    return this.shadowRoot.children[0] instanceof Element
      ? this.shadowRoot.children[0]
      : null;
  }

  constructor() {
    super();
    (0,_lit_localize__WEBPACK_IMPORTED_MODULE_1__.updateWhenLocaleChanges)(this);
    this.addEventListener('focus', this._proxyFocus.bind(this));
  }

  connectedCallback() {
    super.connectedCallback();

    this.apiRoot = this.apiRoot ? `${this.apiRoot}/`.replace('//', '/') : '/'; // ensure it ends with /
    this.api = new _services_apiService_js__WEBPACK_IMPORTED_MODULE_3__["default"](this.nonce, this.apiRoot);
  }

  willUpdate(props) {
    // get RTL from closest parent with [dir] attribute
    if (this.RTL === undefined) {
      const dirEl = this.closest('[dir]');
      if (dirEl) {
        const dir = dirEl.getAttribute('dir');
        if (dir) {
          this.RTL = dir.toLowerCase() === 'rtl';
        }
      }
    }

    // get locale from closest parent with [lang] attribute
    if (!this.locale) {
      const langEl = this.closest('[lang]');
      if (langEl) {
        const lang = langEl.getAttribute('lang');
        if (lang) {
          this.locale = lang;
        }
      }
    }

    // if locale is changing, update lit-localize
    if (props && props.has('locale') && this.locale) {
      try {
        (0,_i18n_localization_js__WEBPACK_IMPORTED_MODULE_2__.setLocale)(this.locale);
      } catch (e) {
        console.error(e);
      }
    }
  }

  /**
   * Proxy focus to the focus target
   * @returns
   */
  _proxyFocus() {
    if (!this._focusTarget) {
      return;
    }

    this._focusTarget.focus();
  }
}


/***/ }),

/***/ "./node_modules/@disciple.tools/web-components/src/components/form/dt-button/dt-button.js":
/*!************************************************************************************************!*\
  !*** ./node_modules/@disciple.tools/web-components/src/components/form/dt-button/dt-button.js ***!
  \************************************************************************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   DtButton: () => (/* binding */ DtButton)
/* harmony export */ });
/* harmony import */ var lit__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! lit */ "./node_modules/lit/index.js");
/* harmony import */ var lit_directives_class_map_js__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! lit/directives/class-map.js */ "./node_modules/lit/directives/class-map.js");
/* harmony import */ var _dt_base_js__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! ../../dt-base.js */ "./node_modules/@disciple.tools/web-components/src/components/dt-base.js");




class DtButton extends _dt_base_js__WEBPACK_IMPORTED_MODULE_2__["default"] {
  static get styles() {
    return (0,lit__WEBPACK_IMPORTED_MODULE_0__.css)`
      :host {
        display: inline-flex;
        width: fit-content;
        height: fit-content;
      }

      .dt-button {
        cursor: pointer;
        display: flex;
        padding: var(--dt-button-padding-y, 10px)
          var(--dt-button-padding-x, 10px);
        font-family: var(--dt-button-font-family);
        font-size: var(--dt-button-font-size, 14px);
        line-height: var(--dt-button-line-height, inherit);
        font-weight: var(--dt-button-font-weight, 700);
        background-color: var(
          --dt-button-context-background-color,
          var(--dt-button-background-color)
        );
        border: var(--dt-button-border-width, 1px) solid
          var(--dt-button-context-border-color, var(--dt-button-border-color));
        border-radius: var(--dt-button-border-radius, 10px);
        box-shadow: var(
          --dt-button-box-shadow,
          --dt-button-context-box-shadow(0 2px 4px rgb(0 0 0 / 25%))
        );
        color: var(--dt-button-context-text-color, var(--dt-button-text-color));
        text-rendering: optimizeLegibility;
        gap: var(--dt-button-gap, 10px);
        justify-content: var(--dt-button-justify-content, center);
        align-content: var(--dt-button-align-content, center);
        align-items: var(--dt-button-align-items, center);
        text-decoration: var(
          --dt-button-text-decoration,
          var(--dt-button-context-text-decoration, none)
        );
        text-transform: var(--dt-button-text-transform, none);
        letter-spacing: var(--dt-button-letter-spacing, normal);
        width: var(--dt-button-width, 100%);
        height: var(--dt-button-height, auto);
        aspect-ratio: var(--dt-button-aspect-ratio, auto);
        position: relative;
      }

      .dt-button.dt-button--outline {
        background-color: transparent;
        color: var(--dt-button-context-text-color, var(--text-color-inverse));
      }

      .dt-button--primary:not(.dt-button--outline) {
        --dt-button-context-border-color: var(--primary-color);
        --dt-button-context-background-color: var(--primary-color);
        --dt-button-context-text-color: var(--dt-button-text-color-light);
      }

      .dt-button--link:not(.dt-button--outline) {
        --dt-button-context-text-decoration: underline;
        --dt-button-context-box-shadow: none;
        --dt-button-context-border-color: transparent;
        --dt-button-context-background-color: transparent;
        --dt-button-context-text-color: var(--dt-button-text-color-dark);
      }

      .dt-button--alert:not(.dt-button--outline) {
        --dt-button-context-border-color: var(--alert-color);
        --dt-button-context-background-color: var(--alert-color);
        --dt-button-context-text-color: var(--dt-button-text-color-light);
      }

      .dt-button--caution:not(.dt-button--outline) {
        --dt-button-context-border-color: var(--caution-color);
        --dt-button-context-background-color: var(--caution-color);
        --dt-button-context-text-color: var(--dt-button-text-color-dark);
      }

      .dt-button--success:not(.dt-button--outline) {
        --dt-button-context-border-color: var(--success-color);
        --dt-button-context-background-color: var(--success-color);
        --dt-button-context-text-color: var(--dt-button-text-color-light);
      }

      .dt-button--inactive:not(.dt-button--outline) {
        --dt-button-context-border-color: var(--inactive-color);
        --dt-button-context-background-color: var(--inactive-color);
        --dt-button-context-text-color: var(--dt-button-text-color-light);
      }

      .dt-button--disabled:not(.dt-button--outline) {
        --dt-button-context-border-color: var(--disabled-color);
        --dt-button-context-background-color: var(--disabled-color);
        --dt-button-context-text-color: var(--dt-button-text-color-dark);
      }

      .dt-button--primary.dt-button--outline {
        --dt-button-context-border-color: var(--primary-color);
        --dt-button-context-text-color: var(--primary-color);
      }

      .dt-button--alert.dt-button--outline {
        --dt-button-context-border-color: var(--alert-color);
        --dt-button-context-text-color: var(--alert-color);
      }

      .dt-button--caution.dt-button--outline {
        --dt-button-context-border-color: var(--caution-color);
        --dt-button-context-text-color: var(--caution-color);
      }

      .dt-button--success.dt-button--outline {
        --dt-button-context-border-color: var(--success-color);
        --dt-button-context-text-color: var(--success-color);
      }

      .dt-button--inactive.dt-button--outline {
        --dt-button-context-border-color: var(--inactive-color);
      }

      .dt-button--disabled.dt-button--outline {
        --dt-button-context-border-color: var(--disabled-color);
      }

      .dt-button.dt-button--rounded {
        --dt-button-border-radius: 50%;
        --dt-button-padding-x: 0px;
        --dt-button-padding-y: 0px;
        --dt-button-aspect-ratio: var(--dt-button-rounded-aspect-ratio, 1/1);
      }

      button.toggle {
        margin-inline-end: 0;
        margin-inline-start: auto;
        background: none;
        border: none;
        color: inherit;
        cursor: pointer;
        display: flex;
        align-items: center;
      }
    `;
  }

  static get properties() {
    return {
      context: { type: String },
      type: { type: String },
      outline: { type: Boolean },
      href: { type: String },
      title: { type: String },
      onClick: { type: Function },
      rounded: { type: Boolean },
      confirm: { type: String },
    };
  }

  get classes() {
    const classes = {
      'dt-button': true,
      'dt-button--outline': this.outline,
      'dt-button--rounded': this.rounded,
    };
    const contextClass = `dt-button--${this.context}`;
    classes[contextClass] = true;
    return classes;
  }

  constructor() {
    super();

    this.context = 'default';
  }

  handleClick(e) {
    if (this.confirm) {
      if (!confirm(this.confirm)) {
        e.preventDefault();
        return;
      }
    }
    if (this.onClick) {
      e.preventDefault();
      this.onClick(e);
    } else {
      const form = this.closest('form');
      if (form) {
        form.submit();
      }
    }
  }

  _dismiss() {
    this.hide = true;
  }

  render() {
    if (this.hide) {
      return (0,lit__WEBPACK_IMPORTED_MODULE_0__.html)``;
    }

    if (this.href) {
      return (0,lit__WEBPACK_IMPORTED_MODULE_0__.html)`
        <a
          class=${(0,lit_directives_class_map_js__WEBPACK_IMPORTED_MODULE_1__.classMap)(this.classes)}
          href=${this.href}
          title=${this.title}
          type=${this.type}
          @click=${() => this.handleClick()}
        >
          <div>
            <slot></slot>
          </div>
        </a>
      `;
    }
    return (0,lit__WEBPACK_IMPORTED_MODULE_0__.html)`
      <button
        class=${(0,lit_directives_class_map_js__WEBPACK_IMPORTED_MODULE_1__.classMap)(this.classes)}
        title=${this.title}
        type=${this.type}
        @click=${() => this.handleClick()}
      >
        <div>
          <slot></slot>
        </div>
      </button>
    `;
  }
}

window.customElements.define('dt-button', DtButton);


/***/ }),

/***/ "./node_modules/@disciple.tools/web-components/src/components/form/dt-church-health-circle/dt-church-health-circle-icon.js":
/*!*********************************************************************************************************************************!*\
  !*** ./node_modules/@disciple.tools/web-components/src/components/form/dt-church-health-circle/dt-church-health-circle-icon.js ***!
  \*********************************************************************************************************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony import */ var lit__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! lit */ "./node_modules/lit/index.js");
/* harmony import */ var lit_directives_class_map_js__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! lit/directives/class-map.js */ "./node_modules/lit/directives/class-map.js");
/* harmony import */ var _dt_base_js__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! ../../dt-base.js */ "./node_modules/@disciple.tools/web-components/src/components/dt-base.js");




class DtChurchHealthIcon extends _dt_base_js__WEBPACK_IMPORTED_MODULE_2__["default"] {
  static get styles() {
    return (0,lit__WEBPACK_IMPORTED_MODULE_0__.css)`
      root {
        display: block;
      }
      .health-item img {
        width: var(--d);
        height: var(--d);
        filter: grayscale(1) opacity(0.75);
      }
      .health-item--active img {
        filter: none !important;
      }
    `;
  }

  static get properties() {
    return {
      key: { type: String },
      metric: { type: Object },
      group: { type: Object },
      active: { type: Boolean, reflect: true },
      missingIcon: { type: String },
      handleSave: { type: Function },
    };
  }

  render() {
    const {
      metric,
      active,
      missingIcon = `${window.wpApiShare.template_dir}/dt-assets/images/groups/missing.svg`,
    } = this;

    return (0,lit__WEBPACK_IMPORTED_MODULE_0__.html)`<div
      class=${(0,lit_directives_class_map_js__WEBPACK_IMPORTED_MODULE_1__.classMap)({
        'health-item': true,
        'health-item--active': active,
      })}
      title="${metric.description}"
      @click="${this._handleClick}"
    >
      <img src="${metric.icon ? metric.icon : missingIcon}" />
    </div>`;
  }

  async _handleClick() {
    if (!this.handleSave) {
      return;
    }

    const active = !this.active;
    this.active = active;
    const payload = {
      health_metrics: {
        values: [
          {
            value: this.key,
            delete: !active,
          },
        ],
      },
    };

    try {
      await this.handleSave(this.group.ID, payload);
    } catch (err) {
      console.error(err);
      return;
    }

    if (active) {
      this.group.health_metrics.push(this.key);
    } else {
      this.group.health_metrics.pop(this.key);
    }
  }
}

window.customElements.define('dt-church-health-icon', DtChurchHealthIcon);


/***/ }),

/***/ "./node_modules/@disciple.tools/web-components/src/components/form/dt-church-health-circle/dt-church-health-circle.js":
/*!****************************************************************************************************************************!*\
  !*** ./node_modules/@disciple.tools/web-components/src/components/form/dt-church-health-circle/dt-church-health-circle.js ***!
  \****************************************************************************************************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   DtChurchHealthCircle: () => (/* binding */ DtChurchHealthCircle)
/* harmony export */ });
/* harmony import */ var lit__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! lit */ "./node_modules/lit/index.js");
/* harmony import */ var lit_directives_class_map_js__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! lit/directives/class-map.js */ "./node_modules/lit/directives/class-map.js");
/* harmony import */ var _dt_base_js__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! ../../dt-base.js */ "./node_modules/@disciple.tools/web-components/src/components/dt-base.js");
/* harmony import */ var _dt_church_health_circle_icon_js__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(/*! ./dt-church-health-circle-icon.js */ "./node_modules/@disciple.tools/web-components/src/components/form/dt-church-health-circle/dt-church-health-circle-icon.js");





class DtChurchHealthCircle extends _dt_base_js__WEBPACK_IMPORTED_MODULE_2__["default"] {
  static get styles() {
    return (0,lit__WEBPACK_IMPORTED_MODULE_0__.css)`
      .health-circle__container {
        --d: 55px; /* image size */
        --rel: 1; /* how much extra space we want between images, 1 = one image size */
        --r: calc(1 * var(--d) / var(--tan)); /* circle radius */
        --s: calc(3 * var(--r));
        margin: 1rem auto;
        display: flex;
        justify-content: center;
        align-items: baseline;
        padding-top: 100%;
        height: 0;
        position: relative;
        overflow: visible;
      }

      .health-circle {
        display: block;
        border-radius: 100%;
        border: 3px darkgray dashed;
        max-width: 100%;
        position: absolute;
        transform: translate(-50%, -50%);
        left: 50%;
        top: 50%;
        width: 100%;
        height: 100%;
      }

      @media (max-width: 519px) {
        .health-circle__container {
          --d: 40px; /* image size */
        }

        .health-circle {
          max-width: 300px;
          max-height: 300px;
        }
      }

      @media (max-width: 400px) {
        .health-circle__container {
          --d: 30px; /* image size */
        }

        .health-circle {
          max-width: 250px;
          max-height: 250px;
        }
      }

      @media (max-width: 321px) {
        .health-circle__container {
          --d: 25px; /* image size */
        }

        .health-circle {
          max-width: 225px;
          max-height: 225px;
        }
      }

      .health-circle__grid {
        display: inline-block;
        position: relative;
        height: 100%;
        width: 100%;
        margin-left: auto;
        margin-right: auto;
        position: relative;
        width: var(--s);
        max-width: 100%;
      }

      .health-circle--committed {
        border: 3px #4caf50 solid !important;
      }

      dt-church-health-icon {
        position: absolute;
        border-radius: 100%;
        font-size: 16px;
        color: black;
        text-align: center;
        font-style: italic;
        cursor: pointer;
        top: 50%;
        left: 50%;
        margin: calc(-0.5 * var(--d));
        width: var(--d);
        height: var(--d);
        --az: calc(var(--i) * 1turn / var(--m));
        transform: rotate(var(--az)) translate(var(--r)) rotate(calc(-1 * var(--az)));
      }
    `;
  }

  static get properties() {
    return {
      groupId: { type: Number },
      group: { type: Object, reflect: false },
      settings: { type: Object, reflect: false },
      errorMessage: { type: String, attribute: false },
      missingIcon: { type: String },
      handleSave: { type: Function },
    };
  }

  /**
   * Map fields settings as an array and filter out church commitment
   */
  get metrics() {
    const settings = this.settings || [];

    if (!Object.values(settings).length) {
      return [];
    }

    const entries = Object.entries(settings);

    //We don't want to show church commitment in the circle
    return entries.filter(([key, value]) => key !== 'church_commitment');
  }

  get isCommited() {
    if (!this.group) {
      return false;
    }

    if (!this.group.health_metrics) {
      return false;
    }

    return this.group.health_metrics.includes('church_commitment');
  }

  /**
   * Fetch group data on component load if it's not provided as a property
   */
  connectedCallback() {
    super.connectedCallback();
    this.fetch();
  }

  adoptedCallback() {
    this.distributeItems();
  }

  /**
   * Position the items after the component is rendered
   */
  updated() {
    this.distributeItems();
  }

  /**
   * Fetch the group and settings data if not provided by the server
   */
  async fetch() {
    try {
      const promises = [this.fetchSettings(), this.fetchGroup()];
      let [settings, group] = await Promise.all(promises);
      this.settings = settings;
      this.post = group;
      if (!settings) {
        this.errorMessage = 'Error loading settings';
      }
      if (!group) {
        this.errorMessage = 'Error loading group';
      }
    } catch (e) {
      console.error(e);
    }
  }

  /**
   * Fetch the group data if it's not already set
   * @returns
   */
  fetchGroup() {
    if (this.group) {
      return Promise.resolve(this.group);
    }
    fetch(`/wp-json/dt-posts/v2/groups/${this.groupId}`).then(response =>
      response.json()
    );
  }

  /**
   * Fetch the settings data if not already set
   * @returns
   */
  fetchSettings() {
    if (this.settings) {
      return Promise.resolve(this.settings);
    }
    return fetch('/wp-json/dt-posts/v2/groups/settings').then(response =>
      response.json()
    );
  }

  /**
   * Find a metric by key
   * @param {*} key
   * @returns
   */
  findMetric(key) {
    const metric = this.metrics.find(item => item.key === key);
    return metric ? metric.value : null;
  }

  /**
   * Render the component
   * @returns
   */
  render() {
    // Show the spinner if we don't have data
    if (!this.group || !this.metrics.length) {
      return (0,lit__WEBPACK_IMPORTED_MODULE_0__.html)`<dt-spinner></dt-spinner>`;
    }

    // Setup data
    const practicedItems = this.group.health_metrics || [];

    // Show the error message if we have one
    if (this.errorMessage) {
      (0,lit__WEBPACK_IMPORTED_MODULE_0__.html)`<dt-alert type="error">${this.errorMessage}</dt-alert>`;
    }

    // Render the group circle
    return (0,lit__WEBPACK_IMPORTED_MODULE_0__.html)`
      <div class="health-circle__wrapper">
        <div class="health-circle__container">
          <div
            class=${(0,lit_directives_class_map_js__WEBPACK_IMPORTED_MODULE_1__.classMap)({
              'health-circle': true,
              'health-circle--committed': this.isCommited,
            })}
          >
            <div class="health-circle__grid">
              ${this.metrics.map(
                ([key, metric], index) =>
                  (0,lit__WEBPACK_IMPORTED_MODULE_0__.html)`<dt-church-health-icon
                    key="${key}"
                    .group="${this.group}"
                    .metric=${metric}
                    .active=${practicedItems.indexOf(key) !== -1}
                    .style="--i: ${index + 1}"
                    .missingIcon="${this.missingIcon}"
                    .handleSave="${this.handleSave}"
                  >
                  </dt-church-health-icon>`
              )}
            </div>
          </div>
        </div>

        <dt-toggle
          name="church-commitment"
          label="${this.settings.church_commitment.label}"
          requiredmessage=""
          icon="https://cdn-icons-png.flaticon.com/512/1077/1077114.png"
          iconalttext="Icon Alt Text"
          privatelabel=""
          @click="${this.toggleClick}"
          ?checked=${this.isCommited}
        >
        </dt-toggle>
      </div>
    `;
  }

  /**
   * Dynamically distribute items in Church Health Circle
   * according to amount of health metric elements
   */
  distributeItems() {
    const container = this.renderRoot.querySelector(
      '.health-circle__container'
    );
    const items = container.querySelectorAll('dt-church-health-icon');

    let n_items = items.length;
    let m = n_items; /* how many are ON the circle */
    let tan = Math.tan(Math.PI / m); /* tangent of half the base angle */

    container.style.setProperty('--m', m);
    container.style.setProperty('--tan', + tan.toFixed(2));
  }

  async toggleClick(e) {
    const { handleSave } = this;

    if (!handleSave) {
      return;
    }

    let toggle = this.renderRoot.querySelector('dt-toggle');
    let church_commitment = toggle.toggleAttribute('checked');
    if (!this.group.health_metrics) {
      this.group.health_metrics = [];
    }

    const payload = {
      health_metrics: {
        values: [
          {
            value: 'church_commitment',
            delete: !church_commitment,
          },
        ],
      },
    };

    try {
      await handleSave(this.group.ID, payload);
    } catch (err) {
      toggle.toggleAttribute('checked', !church_commitment);
      console.error(err);
      return;
    }

    if (church_commitment) {
      this.group.health_metrics.push('church_commitment');
    } else {
      this.group.health_metrics.pop('church_commitment');
    }

    this.requestUpdate();
  }

  _isChecked() {
    if (Object.hasOwn(this.group, 'health_metrics')) {
      if (this.group.health_metrics.includes('church_commitment')) {
        return (this.isChurch = true);
      }
      return (this.isChurch = false);
    }
    return (this.isChurch = false);
  }
}

window.customElements.define('dt-church-health-circle', DtChurchHealthCircle);


/***/ }),

/***/ "./node_modules/@disciple.tools/web-components/src/components/form/dt-communication-channel/dt-comm-channel.js":
/*!*********************************************************************************************************************!*\
  !*** ./node_modules/@disciple.tools/web-components/src/components/form/dt-communication-channel/dt-comm-channel.js ***!
  \*********************************************************************************************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   DtCommChannel: () => (/* binding */ DtCommChannel)
/* harmony export */ });
/* harmony import */ var lit__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! lit */ "./node_modules/lit/index.js");
/* harmony import */ var lit_directives_class_map_js__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! lit/directives/class-map.js */ "./node_modules/lit/directives/class-map.js");
/* harmony import */ var _dt_text_dt_text_js__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! ../dt-text/dt-text.js */ "./node_modules/@disciple.tools/web-components/src/components/form/dt-text/dt-text.js");





class DtCommChannel extends _dt_text_dt_text_js__WEBPACK_IMPORTED_MODULE_2__.DtText {
  static get styles() {
    return [
      ...super.styles,
      (0,lit__WEBPACK_IMPORTED_MODULE_0__.css)`
        :host {
          display: block;
        }
       .label-wrapper {
          display: flex;
          flex-direction: row;
          flex-wrap: wrap;
          width: 100%;
          align-items: center;
       }
       .add-btn {
          background-color: transparent;
          border: none;
       }
        .add-icon {
          color: var(--dt-comm-channel-add-btn-color, var(--success-color));
          height: 1.75rem;
          margin: 0 1rem
        }
        .input-group {
          display: flex;
          list-style-type: none;
          margin: 0;
          padding: 0;
        }
        .input-group li {
          display: flex;
          width: 100%;
          flex-direction: row;
          align-content: center;
          justify-content: center;
          align-items: center;
        }
        #path0_fill {
          fill: red;
        }

        .delete-button {
          background-color: transparent;
          border: none;
        }

        .delete-button svg {
          width: 100%;
          height: 20px;
        }
      `,
    ];
  }

  static get properties() {
    return {
      ...super.properties,
      value: { type: Array, reflect: true }
    };
  }

  _addClick() {
    const newValue = {
      verified: false,
      value: '',
      key: `new-${this.name}-${Math.floor(Math.random() * 100)}`
    };
    this.value = [...this.value, newValue];
    this.requestUpdate();
  }

  _deleteField(item) {
    const index = this.value.findIndex(currentItem => currentItem.key === item.key);
    if (index !== -1) {
      this.value.splice(index, 1);
    }
    this.value = [...this.value];
    this.requestUpdate();
  }

  labelTemplate() {
    if (!this.label) {
      return '';
    }

    return (0,lit__WEBPACK_IMPORTED_MODULE_0__.html)`
      <dt-label
        ?private=${this.private}
        privateLabel="${this.privateLabel}"
        iconAltText="${this.iconAltText}"
        icon="${this.icon}"
      >
        ${!this.icon
        ? (0,lit__WEBPACK_IMPORTED_MODULE_0__.html)`<slot name="icon-start" slot="icon-start"></slot>`
        : null}
        ${this.label}
      </dt-label>
      <button class="add-btn" @click=${this._addClick}>
        <svg class="add-icon" xmlns="http://www.w3.org/2000/svg" viewBox="0 0 24 24"><path fill="currentColor" d="M18 10h-4V6a2 2 0 0 0-4 0l.071 4H6a2 2 0 0 0 0 4l4.071-.071L10 18a2 2 0 0 0 4 0v-4.071L18 14a2 2 0 0 0 0-4z"></svg>
      </button>
    `;
  }

  _inputFieldTemplate(item) {
    const isFirstItem = item.key === `new-${this.name}-0`;
    const deleteButton = !isFirstItem ? (0,lit__WEBPACK_IMPORTED_MODULE_0__.html)`
      <button class="delete-button"  @click=${() => this._deleteField(item)}>
        <svg xmlns="http://www.w3.org/2000/svg" width="100" height="100">
          <path
            id="path0_fill"
            fill-rule="evenodd"
            d="M 14 7C 14 10.866 10.866 14 7 14C 3.13403 14 0 10.866 0 7C 0 3.13401 3.13403 0 7 0C 10.866 0 14 3.13401 14 7ZM 9.51294 3.51299L 7 6.01299L 4.48706 3.51299L 3.5 4.49999L 6.01294 6.99999L 3.5 9.49999L 4.48706 10.487L 7 7.98699L 9.5 10.5L 10.4871 9.51299L 7.98706 6.99999L 10.5 4.49999L 9.51294 3.51299Z"
          />
        </svg>
      </button>
  ` : '';
    return (0,lit__WEBPACK_IMPORTED_MODULE_0__.html)`
      <div class="input-group">
        <input
          id="${item.key}"
          name="${this.name}"
          aria-label="${this.label}"
          type="${this.type || 'text'}"
          placeholder="${this.placeholder}"
          ?disabled=${this.disabled}
          ?required=${this.required}
          class="${(0,lit_directives_class_map_js__WEBPACK_IMPORTED_MODULE_1__.classMap)(this.classes)}"
          .value="${item.value || ''}"
          @change=${this._change}
          novalidate
          @keyup="${this.implicitFormSubmit}"
        />
        ${deleteButton}

        ${this.touched && this.invalid
        ? (0,lit__WEBPACK_IMPORTED_MODULE_0__.html)`<dt-exclamation-circle
              class="icon-overlay alert"
            ></dt-exclamation-circle>`
        : null}
        ${this.error
        ? (0,lit__WEBPACK_IMPORTED_MODULE_0__.html)`<dt-icon
              icon="mdi:alert-circle"
              class="icon-overlay alert"
              tooltip="${this.error}"
              size="2rem"
              ></dt-icon>`
        : null}
        ${this.loading
        ? (0,lit__WEBPACK_IMPORTED_MODULE_0__.html)`<dt-spinner class="icon-overlay"></dt-spinner>`
        : null}
        ${this.saved
        ? (0,lit__WEBPACK_IMPORTED_MODULE_0__.html)`<dt-checkmark class="icon-overlay success"></dt-checkmark>`
        : null}
      </div>
    `;
  }

  _setFormValue(value) {
    super._setFormValue(value);
    this.internals.setFormValue(JSON.stringify(value));
  }

  _change(e) {
    const key = e.target.id;
    const { value } = e.target;
    const newValue = this.value;
    this.value.find((o, i) => {
      if (o.key === key) {
        newValue[i] = { verified: false, value, key };
        return true; // stop searching
      }
      return false;
    });

    const event = new CustomEvent('change', {
      detail: {
        field: this.name,
        oldValue: this.value,
        newValue,
      },
    });

    this.value = newValue;

    this._setFormValue(this.value);

    this.dispatchEvent(event);
  }

  _renderInputFields() {
    if (!this.value) {
      this.value = [{
        verified: false,
        value: '',
        key: `new-${this.name}-0`
      }];

      // initializing with 0 so that delete button does comes in
      return this._inputFieldTemplate(this.value[0]);
    }
    return (0,lit__WEBPACK_IMPORTED_MODULE_0__.html)`
      ${this.value.map((item) =>
      this._inputFieldTemplate(item)
    )}
    `;
  }

  render() {
    return (0,lit__WEBPACK_IMPORTED_MODULE_0__.html)`
     <div class="label-wrapper">
        ${this.labelTemplate()}
      </div>
      ${this._renderInputFields()}
    `;
  }
}

window.customElements.define('dt-comm-channel', DtCommChannel);


/***/ }),

/***/ "./node_modules/@disciple.tools/web-components/src/components/form/dt-connection/dt-connection.js":
/*!********************************************************************************************************!*\
  !*** ./node_modules/@disciple.tools/web-components/src/components/form/dt-connection/dt-connection.js ***!
  \********************************************************************************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   DtConnection: () => (/* binding */ DtConnection)
/* harmony export */ });
/* harmony import */ var lit__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! lit */ "./node_modules/lit/index.js");
/* harmony import */ var _dt_tags_dt_tags_js__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ../dt-tags/dt-tags.js */ "./node_modules/@disciple.tools/web-components/src/components/form/dt-tags/dt-tags.js");



class DtConnection extends _dt_tags_dt_tags_js__WEBPACK_IMPORTED_MODULE_1__.DtTags {
  static get styles() {
    return [
      ...super.styles,
      (0,lit__WEBPACK_IMPORTED_MODULE_0__.css)`
        .selected-option a {
          border-inline-start: solid 3px transparent;
        }

        li button * {
          pointer-events: none;
        }

        li {
          border-inline-start: solid 5px transparent;
        }

        li button .status {
          font-style: italic;
          opacity: 0.6;
        }
        li button .status:before {
          content: '[';
          font-style: normal;
        }
        li button .status:after {
          content: ']';
          font-style: normal;
        }

        li button svg {
          width: 20px;
          height: auto;
          margin-bottom: -4px;
        }
        li button svg use {
          fill: var(--dt-connection-icon-fill, var(--primary-color));
        }
      `,
    ];
  }

  _clickOption(e) {
    if (e.target && e.target.value) {
      const id = parseInt(e.target.value, 10);
      const option = this.filteredOptions.reduce((result, opt) => {
        if (!result && opt.id == id) {
          return opt;
        }
        return result;
      }, null);
      if (option) {
        this._select(option);
      }
      this._clearSearch();
    }
  }

  _clickAddNew(e) {
    if (e.target) {
      this._select({
        id: e.target.dataset?.label,
        label: e.target.dataset?.label,
        isNew: true,
      });
      // clear search field if clicked with mouse, since field will lose focus
      const input = this.shadowRoot.querySelector('input');
      if (input) {
        input.value = '';
      }
    }
  }

  _keyboardSelectOption() {
    if (this.activeIndex > -1) {
      if (this.activeIndex + 1 > this.filteredOptions.length) {
        this._select({
          id: this.query,
          label: this.query,
          isNew: true,
        });
      } else {
        this._select(this.filteredOptions[this.activeIndex]);
      }
      this._clearSearch();
    }
  }

  _remove(e) {
    if (e.target && e.target.dataset && e.target.dataset.value) {
      const event = new CustomEvent('change', {
        detail: {
          field: this.name,
          oldValue: this.value,
        },
      });
      this.value = (this.value || []).map(i => {
        const val = {
          ...i,
        };
        if (i.id === e.target.dataset.value) {
          val.delete = true;
        }
        return val;
      });
      event.detail.newValue = this.value;

      // dispatch event for use with addEventListener from javascript
      this.dispatchEvent(event);

      // If option was de-selected while list was open, re-focus input
      if (this.open) {
        this.shadowRoot.querySelector('input').focus();
      }
    }
  }

  /**
   * Filter to options that:
   *   1: are not selected
   *   2: match the search query
   * @private
   */
  _filterOptions() {
    const selectedValues = (this.value || [])
      .filter(i => !i.delete)
      .map(v => v?.id);

    if (this.options?.length) {
      this.filteredOptions = (this.options || []).filter(
        opt =>
          !selectedValues.includes(opt.id) &&
          (!this.query ||
            opt.label
              .toLocaleLowerCase()
              .includes(this.query.toLocaleLowerCase()))
      );
    } else if (this.open) {
      // Only run this filtering if the list is open.
      // This prevents it from running on initial load before a `load` event is attached.
      this.loading = true;
      this.filteredOptions = [];

      // need to fetch data via API request
      const self = this;
      const event = new CustomEvent('load', {
        bubbles: true,
        detail: {
          field: this.name,
          postType: this.postType,
          query: this.query,
          onSuccess: result => {
            self.loading = false;

            // filter out selected values from list
            self.filteredOptions = result.filter(
              opt => !selectedValues.includes(opt.id)
            );
          },
          onError: error => {
            console.warn(error);
            self.loading = false;
          },
        },
      });
      this.dispatchEvent(event);
    }
    return this.filteredOptions;
  }

  _renderSelectedOptions() {
    return (this.value || [])
      .filter(i => !i.delete)
      .map(
        opt => (0,lit__WEBPACK_IMPORTED_MODULE_0__.html)`
          <div class="selected-option">
            <a
              href="${opt.link}"
              style="border-inline-start-color: ${opt.status
                ? opt.status.color
                : ''}"
              ?disabled="${this.disabled}"
              title="${opt.status ? opt.status.label : opt.label}"
              >${opt.label}</a
            >
            <button
              @click="${this._remove}"
              ?disabled="${this.disabled}"
              data-value="${opt.id}"
            >
              x
            </button>
          </div>
        `
      );
  }

  _renderOption(opt, idx) {
    // prettier-ignore
    const svg = (0,lit__WEBPACK_IMPORTED_MODULE_0__.html)`<svg width="24" height="24" viewBox="0 0 24 24" version="1.1" xmlns="http://www.w3.org/2000/svg" xmlns:xlink="http://www.w3.org/1999/xlink"><title>circle-08 2</title><desc>Created using Figma</desc><g id="Canvas" transform="translate(1457 4940)"><g id="circle-08 2"><g id="Group"><g id="Vector"><use xlink:href="#path0_fill" transform="translate(-1457 -4940)" fill="#000000"/></g></g></g></g><defs><path id="path0_fill" d="M 12 0C 5.383 0 0 5.383 0 12C 0 18.617 5.383 24 12 24C 18.617 24 24 18.617 24 12C 24 5.383 18.617 0 12 0ZM 8 10C 8 7.791 9.844 6 12 6C 14.156 6 16 7.791 16 10L 16 11C 16 13.209 14.156 15 12 15C 9.844 15 8 13.209 8 11L 8 10ZM 12 22C 9.567 22 7.335 21.124 5.599 19.674C 6.438 18.091 8.083 17 10 17L 14 17C 15.917 17 17.562 18.091 18.401 19.674C 16.665 21.124 14.433 22 12 22Z"/></defs></svg>`

    const status = opt.status || {
      key: '',
      label: '',
      color: '',
    };
    return (0,lit__WEBPACK_IMPORTED_MODULE_0__.html)`
      <li tabindex="-1" style="border-inline-start-color:${status.color}">
        <button
          value="${opt.id}"
          type="button"
          data-label="${opt.label}"
          @click="${this._clickOption}"
          @touchstart="${this._touchStart}"
          @touchmove="${this._touchMove}"
          @touchend="${this._touchEnd}"
          tabindex="-1"
          class="${this.activeIndex > -1 && this.activeIndex === idx
            ? 'active'
            : ''}"
        >
          <span class="label">${opt.label}</span>
          <span class="connection-id">(#${opt.id})</span>
          ${status.label
            ? (0,lit__WEBPACK_IMPORTED_MODULE_0__.html)`<span class="status">${status.label}</span>`
            : null}
          ${opt.user ? svg : null}
        </button>
      </li>
    `;
  }
}

window.customElements.define('dt-connection', DtConnection);


/***/ }),

/***/ "./node_modules/@disciple.tools/web-components/src/components/form/dt-copy-text/dt-copy-text.js":
/*!******************************************************************************************************!*\
  !*** ./node_modules/@disciple.tools/web-components/src/components/form/dt-copy-text/dt-copy-text.js ***!
  \******************************************************************************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   DtCopyText: () => (/* binding */ DtCopyText)
/* harmony export */ });
/* harmony import */ var lit__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! lit */ "./node_modules/lit/index.js");
/* harmony import */ var lit_directives_style_map_js__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! lit/directives/style-map.js */ "./node_modules/lit/directives/style-map.js");
/* harmony import */ var _dt_base_js__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! ../../dt-base.js */ "./node_modules/@disciple.tools/web-components/src/components/dt-base.js");
/* harmony import */ var _dt_form_base_js__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(/*! ../dt-form-base.js */ "./node_modules/@disciple.tools/web-components/src/components/form/dt-form-base.js");





class DtCopyText extends _dt_base_js__WEBPACK_IMPORTED_MODULE_2__["default"] {
  static get styles() {
    return (0,lit__WEBPACK_IMPORTED_MODULE_0__.css)`
      :root {
        font-size: inherit;
      }

      .copy-text {
        --dt-form-text-color: #575757;
        display: flex;
        align-items: center;
        position: relative;
        width: calc(100% + 20px);
      }

      .copy-text__input {
        flex: 1;
      }

      .copy_icon {
        cursor: copy;
        font-size: 16px;
        display: block;
        transform: translate(-24px, -5px);
        width: 20px;
      }

      :host([dir='rtl']) .copy_icon {
        transform: translate(24px, -5px);
      }
    `;
  }

  static get properties() {
    return {
      value: { type: String },
      success: { type: Boolean },
      error: { type: Boolean },
    };
  }

  get inputStyles() {
    if (this.success) {
      return {
        '--dt-text-border-color':
          'var(--copy-text-success-color, var(--success-color))',
        '--dt-form-text-color':
          'var( --copy-text-success-color, var(--success-color))',
        color: 'var( --copy-text-success-color, var(--success-color))',
      };
    }
    if (this.error) {
      return {
        '---dt-text-border-color':
          'var(--copy-text-alert-color, var(--alert-color))',
        '--dt-form-text-color':
          'var(--copy-text-alert-color, var(--alert-color))',
      };
    }

    return {};
  }

  get icon() {
    return this.success ? 'ic:round-check' : 'ic:round-content-copy';
  }

  async copy() {
    try {
      this.success = false;
      this.error = false;
      await navigator.clipboard.writeText(this.value);
      this.success = true;
      this.error = false;
    } catch (err) {
      console.log(err);
      this.success = false;
      this.error = true;
    }
  }

  render() {
    return (0,lit__WEBPACK_IMPORTED_MODULE_0__.html)`
      <div class="copy-text" style=${(0,lit_directives_style_map_js__WEBPACK_IMPORTED_MODULE_1__.styleMap)(this.inputStyles)}>
        <dt-text
          class="copy-text__input"
          value="${this.value}"
          disabled
        ></dt-text>
        <dt-icon
          class="copy_icon"
          icon="${this.icon}"
          @click="${this.copy}"
        ></dt-icon>
      </div>
    `;
  }
}

window.customElements.define('dt-copy-text', DtCopyText);


/***/ }),

/***/ "./node_modules/@disciple.tools/web-components/src/components/form/dt-date/dt-date.js":
/*!********************************************************************************************!*\
  !*** ./node_modules/@disciple.tools/web-components/src/components/form/dt-date/dt-date.js ***!
  \********************************************************************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   DtDate: () => (/* binding */ DtDate)
/* harmony export */ });
/* harmony import */ var lit__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! lit */ "./node_modules/lit/index.js");
/* harmony import */ var _dt_form_base_js__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ../dt-form-base.js */ "./node_modules/@disciple.tools/web-components/src/components/form/dt-form-base.js");



class DtDate extends _dt_form_base_js__WEBPACK_IMPORTED_MODULE_1__["default"] {
  static get styles() {
    return [
      ...super.styles,
      (0,lit__WEBPACK_IMPORTED_MODULE_0__.css)`
        input {
          color: var(--dt-form-text-color, #000);
          appearance: none;
          background-color: var(--dt-form-background-color, #cecece);
          border: 1px solid var(--dt-form-border-color, #cacaca);
          border-radius: 0;
          box-shadow: var(
            --dt-form-input-box-shadow,
            inset 0 1px 2px hsl(0deg 0% 4% / 10%)
          );
          box-sizing: border-box;
          display: inline-flex;
          font-family: inherit;
          font-size: 1rem;
          font-weight: 300;
          height: 2.5rem;
          line-height: 1.5;
          padding: var(--dt-form-padding, 0.5333333333rem);
          transition: var(
            --dt-form-transition,
            box-shadow 0.5s,
            border-color 0.25s ease-in-out
          );
          width: 100%;
        }
        input:disabled,
        input[readonly],
        textarea:disabled,
        textarea[readonly],
        .input-group button:disabled {
          background-color: var(--dt-form-disabled-background-color, #e6e6e6);
          cursor: not-allowed;
        }

        /* input::-webkit-datetime-edit-text { color: red; padding: 0 0.3em; } */
        input::-webkit-calendar-picker-indicator {
          color: red;
        }

        .input-group {
          position: relative;
          display: inline-flex;
          margin: 0 0 1.0666666667rem;
          width: 100%;
        }

        .input-group .input-group-button {
          font-size: 0.75rem;
          line-height: 1em;
          display: inline-flex;
        }
        .input-group .button {
          display: inline-block;
          background: var(--dt-form-background-color, #cecece);
          border: 1px solid var(--dt-form-border-color, #cecece);
          color: var(--alert-color, #cc4b37);
          align-self: stretch;
          font-size: 1rem;
          height: auto;
          padding: 0 1em;
          margin: 0;
        }
        .input-group .button:hover:not([disabled]) {
          background-color: var(--alert-color, #cc4b37);
          color: var(--text-color-inverse, #fefefe);
        }

        .icon-overlay {
          inset-inline-end: 5rem;
        }
      `,
    ];
  }

  static get properties() {
    return {
      ...super.properties,
      id: { type: String },
      value: {
        type: String,
        reflect: true,
      },
      timestamp: {
        converter: date => {
          let JStimestamp = Number(date);
          if (JStimestamp < 1000000000000) {
            JStimestamp *= 1000;
          }
          if (JStimestamp) return JStimestamp;
          return undefined;
        },
        reflect: true,
      },
      onchange: { type: String },
    };
  }

  // _convertArabicToEnglishNumbers() {
  //   this.value
  //   .replace(/[\u0660-\u0669]/g, (c) => { return c.charCodeAt(0) - 0x0660; })
  //     .replace(/[\u06f0-\u06f9]/g, (c) => {
  //       return c.charCodeAt(0) - 0x06f0;
  //     });
  // }

  updateTimestamp(value) {
    const timestampMilliseconds = new Date(value).getTime();
    const timestampSecond = timestampMilliseconds / 1000;
    const event = new CustomEvent('change', {
      detail: {
        field: this.name,
        oldValue: this.timestamp,
        newValue: timestampSecond,
      },
    });

    this.timestamp = timestampMilliseconds;
    this.value = value;
    this._setFormValue(value);
    this.dispatchEvent(event);
  }

  _change(e) {
    this.updateTimestamp(e.target.value);
  }

  clearInput() {
    this.updateTimestamp('');
  }

  showDatePicker() {
    const input = this.shadowRoot.querySelector('input');
    input.showPicker();
  }

  render() {
    if (this.timestamp) {
      this.value = new Date(this.timestamp).toISOString().substring(0, 10);
    } else if (this.value) {
      this.timestamp = new Date(this.value).getTime();
    }

    return (0,lit__WEBPACK_IMPORTED_MODULE_0__.html)`
      ${this.labelTemplate()}

      <div class="input-group">
        <input
          id="${this.id}"
          class="input-group-field dt_date_picker"
          type="date"
          autocomplete="off"
          .placeholder="${new Date().toISOString().substring(0, 10)}"
          .value="${this.value}"
          .timestamp="${this.date}"
          ?disabled=${this.disabled}
          @change="${this._change}"
          @click="${this.showDatePicker}"
        />
        <button
          id="${this.id}-clear-button"
          class="button alert clear-date-button"
          data-inputid="${this.id}"
          title="Delete Date"
          type="button"
          ?disabled=${this.disabled}
          @click="${this.clearInput}"
        >
          x
        </button>

        ${(this.touched && this.invalid) || this.error
          ? (0,lit__WEBPACK_IMPORTED_MODULE_0__.html)`<dt-exclamation-circle
              class="icon-overlay alert"
            ></dt-exclamation-circle>`
          : null}
        ${this.loading
          ? (0,lit__WEBPACK_IMPORTED_MODULE_0__.html)`<dt-spinner class="icon-overlay"></dt-spinner>`
          : null}
        ${this.saved
          ? (0,lit__WEBPACK_IMPORTED_MODULE_0__.html)`<dt-checkmark class="icon-overlay success"></dt-checkmark>`
          : null}
      </div>
    `;
  }
}

window.customElements.define('dt-date', DtDate);


/***/ }),

/***/ "./node_modules/@disciple.tools/web-components/src/components/form/dt-form-base.js":
/*!*****************************************************************************************!*\
  !*** ./node_modules/@disciple.tools/web-components/src/components/form/dt-form-base.js ***!
  \*****************************************************************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "default": () => (/* binding */ DtFormBase)
/* harmony export */ });
/* harmony import */ var lit__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! lit */ "./node_modules/lit/index.js");
/* harmony import */ var _dt_base_js__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ../dt-base.js */ "./node_modules/@disciple.tools/web-components/src/components/dt-base.js");
/* harmony import */ var element_internals_polyfill__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! element-internals-polyfill */ "./node_modules/element-internals-polyfill/dist/index.js");
/* harmony import */ var _dt_label_dt_label_js__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(/*! ./dt-label/dt-label.js */ "./node_modules/@disciple.tools/web-components/src/components/form/dt-label/dt-label.js");


 // eslint-disable-line import/no-extraneous-dependencies


class DtFormBase extends _dt_base_js__WEBPACK_IMPORTED_MODULE_1__["default"] {
  static get formAssociated() {
    return true;
  }

  static get styles() {
    return [
      (0,lit__WEBPACK_IMPORTED_MODULE_0__.css)`
        .input-group {
          position: relative;
        }
        .input-group.disabled {
          background-color: var(--disabled-color);
        }

        /* === Inline Icons === */
        .icon-overlay {
          position: absolute;
          inset-inline-end: 1rem;
          top: 0;
          height: 100%;
          display: flex;
          justify-content: center;
          align-items: center;
        }

        .icon-overlay.alert {
          color: var(--alert-color);
          cursor: pointer;
        }
        .icon-overlay.success {
          color: var(--success-color);
        }
      `,
    ];
  }

  static get properties() {
    return {
      ...super.properties,
      name: { type: String },
      label: { type: String },
      icon: { type: String },
      iconAltText: { type: String },
      private: { type: Boolean },
      privateLabel: { type: String },
      disabled: { type: Boolean },
      required: { type: Boolean },
      requiredMessage: { type: String },
      touched: {
        type: Boolean,
        state: true,
      },
      invalid: {
        type: Boolean,
        state: true,
      },
      error: { type: String },
      loading: { type: Boolean },
      saved: { type: Boolean },
    };
  }

  /**
   * return the field elemnt
   */
  get _field() {
    return this.shadowRoot.querySelector('input, textarea, select');
  }

  /**
   * return the element to proxy focus to
   */
  get _focusTarget() {
    return this._field;
  }

  constructor() {
    super();
    this.touched = false;
    this.invalid = false;
    this.internals = this.attachInternals();

    // catch oninvalid event (when validation is triggered from form submit)
    // and set touched=true so that styles are shown
    this.addEventListener('invalid', () => {
      this.touched = true;
      this._validateRequired();
    });
  }

  firstUpdated(...args) {
    super.firstUpdated(...args);

    // set initial form value
    const formdata = DtFormBase._jsonToFormData(this.value, this.name);
    this.internals.setFormValue(formdata);
    this._validateRequired();
  }

  /**
   * Recursively create FormData from JSON data
   * @param formData
   * @param data
   * @param parentKey
   * @private
   */
  static _buildFormData(formData, data, parentKey) {
    if (data && typeof data === 'object' && !(data instanceof Date) && !(data instanceof File)) {
      Object.keys(data).forEach(key => {
        this._buildFormData(formData, data[key], parentKey ? `${parentKey}[${key}]` : key);
      });
    } else {
      const value = data == null ? '' : data;
      formData.append(parentKey, value);
    }
  }

  /**
   * Convert JSON to FormData object
   * @param data
   * @param parentKey - prefix for all values. Should be the field name
   * @returns {FormData}
   * @private
   */
  static _jsonToFormData(data, parentKey) {
    const formData = new FormData();
    DtFormBase._buildFormData(formData, data, parentKey);
    return formData;
  }

  _setFormValue(value) {
    // handle complex types like arrays and objects by converting to FormData
    const formdata = DtFormBase._jsonToFormData(value, this.name);
    this.internals.setFormValue(formdata, value);
    this._validateRequired();
    this.touched = true;
  }

  /* eslint-disable class-methods-use-this */
  /**
   * Can/should be overriden by each component to implement logic for checking if a value is entered/selected
   * @private
   */
  _validateRequired() {
    // const { value } = this;
    // const input = this.shadowRoot.querySelector('input');
    // if (value === '' && this.required) {
    //   this.invalid = true;
    //   this.internals.setValidity({
    //     valueMissing: true
    //   }, this.requiredMessage || 'This field is required', input);
    // } else {
    //   this.invalid = false;
    //   this.internals.setValidity({});
    // }
  }
  /* eslint-enable class-methods-use-this */

  labelTemplate() {
    if (!this.label) {
      return '';
    }

    return (0,lit__WEBPACK_IMPORTED_MODULE_0__.html)`
      <dt-label
        ?private=${this.private}
        privateLabel="${this.privateLabel}"
        iconAltText="${this.iconAltText}"
        icon="${this.icon}"
      >
        ${!this.icon
          ? (0,lit__WEBPACK_IMPORTED_MODULE_0__.html)`<slot name="icon-start" slot="icon-start"></slot>`
          : null}
        ${this.label}
      </dt-label>
    `;
  }

  render() {
    return (0,lit__WEBPACK_IMPORTED_MODULE_0__.html)`
      ${this.labelTemplate()}
      <slot></slot>
    `;
  }
}


/***/ }),

/***/ "./node_modules/@disciple.tools/web-components/src/components/form/dt-label/dt-label.js":
/*!**********************************************************************************************!*\
  !*** ./node_modules/@disciple.tools/web-components/src/components/form/dt-label/dt-label.js ***!
  \**********************************************************************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   DtLabel: () => (/* binding */ DtLabel)
/* harmony export */ });
/* harmony import */ var lit__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! lit */ "./node_modules/lit/index.js");
/* harmony import */ var _lit_localize__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! @lit/localize */ "./node_modules/@lit/localize/lit-localize.js");
/* harmony import */ var _dt_base_js__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! ../../dt-base.js */ "./node_modules/@disciple.tools/web-components/src/components/dt-base.js");




class DtLabel extends _dt_base_js__WEBPACK_IMPORTED_MODULE_2__["default"] {
  static get styles() {
    return (0,lit__WEBPACK_IMPORTED_MODULE_0__.css)`
      :host {
        font-family: var(--font-family);
        font-size: var(--dt-label-font-size, 14px);
        font-weight: var(--dt-label-font-weight, 700);
        color: var(--dt-label-color, #000);
        overflow: hidden;
        text-overflow: ellipsis;
        white-space: nowrap;
      }

      .icon {
        height: var(--dt-label-font-size, 14px);
        width: auto;
        display: inline-block;
      }

      .icon.private {
        position: relative;
      }
      .icon.private:hover .tooltip {
        display: block;
      }
      .tooltip {
        display: none;
        position: absolute;
        color: var(--dt-label-tooltip-color, #666);
        background: var(--dt-label-tooltip-background, #eee);
        top: calc(100% + 0.5rem);
        inset-inline-start: -1rem;
        font-weight: normal;
        padding: 0.4rem;
      }
      .tooltip:before {
        content: '';
        position: absolute;
        inset-inline-start: 1rem;
        top: -0.5rem;
        height: 0;
        width: 0;
        border-bottom: 0.5rem solid var(--dt-label-tooltip-background, #eee);
        border-inline-start: 0.5rem solid transparent;
        border-inline-end: 0.5rem solid transparent;
      }
    `;
  }

  static get properties() {
    return {
      icon: { type: String },
      iconAltText: { type: String },
      private: { type: Boolean },
      privateLabel: { type: String },
    };
  }

  firstUpdated() {
    // handle img or svg content that may be bigger than the space allotted
    const slot = this.shadowRoot.querySelector('slot[name=icon-start]');
    const elements = slot.assignedElements({ flatten: true });
    for (const element of elements) {
      element.style.height = '100%';
      element.style.width = 'auto';
    }
  }

  get _slottedChildren() {
    const slot = this.shadowRoot.querySelector('slot');
    return slot.assignedElements({ flatten: true });
  }

  render() {
    // prettier-ignore
    const svg = (0,lit__WEBPACK_IMPORTED_MODULE_0__.html)`<svg class="icon" height='100px' width='100px' fill="#000000" xmlns:x="http://ns.adobe.com/Extensibility/1.0/" xmlns:i="http://ns.adobe.com/AdobeIllustrator/10.0/" xmlns:graph="http://ns.adobe.com/Graphs/1.0/" xmlns="http://www.w3.org/2000/svg" xmlns:xlink="http://www.w3.org/1999/xlink" version="1.1" x="0px" y="0px" viewBox="0 0 100 100" style="enable-background:new 0 0 100 100;" xml:space="preserve"><g><g i:extraneous="self"><g><path d="M5273.1,2400.1v-2c0-2.8-5-4-9.7-4s-9.7,1.3-9.7,4v2c0,1.8,0.7,3.6,2,4.9l5,4.9c0.3,0.3,0.4,0.6,0.4,1v6.4     c0,0.4,0.2,0.7,0.6,0.8l2.9,0.9c0.5,0.1,1-0.2,1-0.8v-7.2c0-0.4,0.2-0.7,0.4-1l5.1-5C5272.4,2403.7,5273.1,2401.9,5273.1,2400.1z      M5263.4,2400c-4.8,0-7.4-1.3-7.5-1.8v0c0.1-0.5,2.7-1.8,7.5-1.8c4.8,0,7.3,1.3,7.5,1.8C5270.7,2398.7,5268.2,2400,5263.4,2400z"></path><path d="M5268.4,2410.3c-0.6,0-1,0.4-1,1c0,0.6,0.4,1,1,1h4.3c0.6,0,1-0.4,1-1c0-0.6-0.4-1-1-1H5268.4z"></path><path d="M5272.7,2413.7h-4.3c-0.6,0-1,0.4-1,1c0,0.6,0.4,1,1,1h4.3c0.6,0,1-0.4,1-1C5273.7,2414.1,5273.3,2413.7,5272.7,2413.7z"></path><path d="M5272.7,2417h-4.3c-0.6,0-1,0.4-1,1c0,0.6,0.4,1,1,1h4.3c0.6,0,1-0.4,1-1C5273.7,2417.5,5273.3,2417,5272.7,2417z"></path></g><path d="M75.8,37.6v-9.3C75.8,14.1,64.2,2.5,50,2.5S24.2,14.1,24.2,28.3v9.3c-7,0.6-12.4,6.4-12.4,13.6v32.6    c0,7.6,6.1,13.7,13.7,13.7h49.1c7.6,0,13.7-6.1,13.7-13.7V51.2C88.3,44,82.8,38.2,75.8,37.6z M56,79.4c0.2,1-0.5,1.9-1.5,1.9h-9.1    c-1,0-1.7-0.9-1.5-1.9l3-11.8c-2.5-1.1-4.3-3.6-4.3-6.6c0-4,3.3-7.3,7.3-7.3c4,0,7.3,3.3,7.3,7.3c0,2.9-1.8,5.4-4.3,6.6L56,79.4z     M62.7,37.5H37.3v-9.1c0-7,5.7-12.7,12.7-12.7s12.7,5.7,12.7,12.7V37.5z"></path></g></g></svg>`;
    return (0,lit__WEBPACK_IMPORTED_MODULE_0__.html)`
      <div class="label">
        <span class="icon">
          <slot name="icon-start">
            ${this.icon
              ? (0,lit__WEBPACK_IMPORTED_MODULE_0__.html)`<img src="${this.icon}" alt="${this.iconAltText}" />`
              : null}
          </slot>
        </span>
        <slot></slot>

        ${this.private
          ? (0,lit__WEBPACK_IMPORTED_MODULE_0__.html)`<span class="icon private">
              ${svg}
              <span class="tooltip"
                >${this.privateLabel ||
                (0,_lit_localize__WEBPACK_IMPORTED_MODULE_1__.msg)('Private Field: Only I can see its content')}</span
              >
            </span> `
          : null}
      </div>
    `;
  }
}

window.customElements.define('dt-label', DtLabel);


/***/ }),

/***/ "./node_modules/@disciple.tools/web-components/src/components/form/dt-location-map/dt-location-map-item.js":
/*!*****************************************************************************************************************!*\
  !*** ./node_modules/@disciple.tools/web-components/src/components/form/dt-location-map/dt-location-map-item.js ***!
  \*****************************************************************************************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "default": () => (/* binding */ DtLocationMapItem)
/* harmony export */ });
/* harmony import */ var lit__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! lit */ "./node_modules/lit/index.js");
/* harmony import */ var lit_directives_style_map_js__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! lit/directives/style-map.js */ "./node_modules/lit/directives/style-map.js");
/* harmony import */ var _lit_localize__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! @lit/localize */ "./node_modules/@lit/localize/lit-localize.js");
/* harmony import */ var _services_mapboxService__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(/*! ../../../services/mapboxService */ "./node_modules/@disciple.tools/web-components/src/services/mapboxService.js");
/* harmony import */ var _services_googleGeocodeService__WEBPACK_IMPORTED_MODULE_4__ = __webpack_require__(/*! ../../../services/googleGeocodeService */ "./node_modules/@disciple.tools/web-components/src/services/googleGeocodeService.js");
/* harmony import */ var _icons_dt_icon_js__WEBPACK_IMPORTED_MODULE_5__ = __webpack_require__(/*! ../../icons/dt-icon.js */ "./node_modules/@disciple.tools/web-components/src/components/icons/dt-icon.js");
/* harmony import */ var _dt_map_modal_js__WEBPACK_IMPORTED_MODULE_6__ = __webpack_require__(/*! ./dt-map-modal.js */ "./node_modules/@disciple.tools/web-components/src/components/form/dt-location-map/dt-map-modal.js");








class DtLocationMapItem extends lit__WEBPACK_IMPORTED_MODULE_0__.LitElement {
  static get properties() {
    return {
      id: { type: String, reflect: true },
      placeholder: { type: String },
      mapboxToken: { type: String, attribute: 'mapbox-token' },
      googleToken: { type: String, attribute: 'google-token' },
      metadata: { type: Object },
      disabled: { type: Boolean },
      open: {
        type: Boolean,
        state: true,
      },
      query: {
        type: String,
        state: true,
      },
      activeIndex: {
        type: Number,
        state: true,
      },
      containerHeight: {
        type: Number,
        state: true,
      },
      loading: { type: Boolean },
      saved: { type: Boolean },
      filteredOptions: { type: Array, state: true },
    };
  }

  static get styles() {
    return [
      (0,lit__WEBPACK_IMPORTED_MODULE_0__.css)`
        :host {
          position: relative;
          font-family: Helvetica, Arial, sans-serif;
          display: block;
        }
        
        .input-group {
          color: var(--dt-multi-select-text-color, #0a0a0a);
          margin-bottom: 1rem;
        }
        .input-group.disabled input,
        .input-group.disabled .field-container {
          background-color: var(--disabled-color);
        }
        .input-group.disabled a,
        .input-group.disabled button {
          cursor: not-allowed;
          pointer-events: none;
        }
        .input-group.disabled *:hover {
          cursor: not-allowed;
        }
        
        /* === Options List === */
        .option-list {
          list-style: none;
          margin: 0;
          padding: 0;
          border: 1px solid var(--dt-form-border-color, #cacaca);
          background: var(--dt-form-background-color, #fefefe);
          z-index: 10;
          position: absolute;
          width: var(--container-width, 100%);
          width: 100%;
          top: 0;
          left: 0;
          box-shadow: var(--shadow-1);
          max-height: 150px;
          overflow-y: scroll;
        }
        .option-list li {
          border-block-start: 1px solid var(--dt-form-border-color, #cacaca);
          outline: 0;
        }
        .option-list li div,
        .option-list li button {
          padding: 0.5rem 0.75rem;
          color: var(--dt-multi-select-text-color, #0a0a0a);
          font-weight: 100;
          font-size: 1rem;
          text-decoration: none;
          text-align: inherit;
        }
        .option-list li button {
          display: block;
          width: 100%;
          border: 0;
          background: transparent;
        }
        .option-list li button:hover,
        .option-list li button.active {
          cursor: pointer;
          background: var(--dt-multi-select-option-hover-background, #f5f5f5);
        }
      `,
      (0,lit__WEBPACK_IMPORTED_MODULE_0__.css)`
        input {
          color: var(--dt-form-text-color, #000);
          appearance: none;
          background-color: var(--dt-location-map-background-color, #fefefe);
          border: 1px solid var(--dt-location-map-border-color, #fefefe);
          border-radius: var(--dt-location-map-border-radius, 0);
          box-shadow: var(
            --dt-location-map-box-shadow,
            var(
              --dt-form-input-box-shadow,
              inset 0 1px 2px hsl(0deg 0% 4% / 10%)
            )
          );
          box-sizing: border-box;
          display: block;
          font-family: inherit;
          font-size: 1rem;
          font-weight: 300;
          line-height: 1.5;
          margin: 0;
          padding: var(--dt-form-padding, 0.5333333333rem);
          transition: var(
            --dt-form-transition,
            box-shadow 0.5s,
            border-color 0.25s ease-in-out
          );
        }
        input:disabled,
        input[readonly],
        textarea:disabled,
        textarea[readonly] {
          background-color: var(
            --dt-text-disabled-background-color,
            var(--dt-form-disabled-background-color, #e6e6e6)
          );
          cursor: not-allowed;
        }
        input.disabled {
          color: var(--dt-text-placeholder-color, #999);        
        }
        input:focus-within,
        input:focus-visible {
          outline: none;
        }
        input::placeholder {
          color: var(--dt-text-placeholder-color, #999);
          text-transform: var(--dt-text-placeholder-transform, none);
          font-size: var(--dt-text-placeholder-font-size, 1rem);
          font-weight: var(--dt-text-placeholder-font-weight, 400);
          letter-spacing: var(--dt-text-placeholder-letter-spacing, normal);
        }
        input.invalid {
          border-color: var(--dt-text-border-color-alert, var(--alert-color));
        }
        
        .field-container {
          display: flex;
          margin-bottom: 0.5rem;
        }
        .field-container input {
          flex-grow: 1;
        }
        .field-container .input-addon {
          flex-shrink: 1;
          display: flex;
          justify-content: center;
          align-items: center;
          aspect-ratio: 1/1;
          padding: 10px;
          border: solid 1px gray;
          border-collapse: collapse;
          color: var(--dt-location-map-button-color, #cc4b37);
          background-color: var(--dt-location-map-background-color, buttonface);
          border: 1px solid var(--dt-location-map-border-color, #fefefe);
          border-radius: var(--dt-location-map-border-radius, 0);
          box-shadow: var(
            --dt-location-map-box-shadow,
            var(
              --dt-form-input-box-shadow,
              inset 0 1px 2px hsl(0deg 0% 4% / 10%)
            )
          );
        }
        .field-container .input-addon:hover {
          background-color: var(--dt-location-map-button-hover-background-color, #cc4b37);
          color: var(--dt-location-map-button-hover-color, #ffffff);
        }
        
        .input-addon:disabled {
          background-color: var(--dt-form-disabled-background-color);
          color: var(--dt-text-placeholder-color, #999);
        }
        .input-addon:disabled:hover {
          background-color: var(--dt-form-disabled-background-color);
          color: var(--dt-text-placeholder-color, #999);
          cursor: not-allowed;          
        }
      `,
      (0,lit__WEBPACK_IMPORTED_MODULE_0__.css)`
        /* === Inline Icons === */
        .icon-overlay {
          position: absolute;
          inset-inline-end: 1rem;
          top: 0;
          inset-inline-end: 3rem;
          height: 100%;
          display: flex;
          justify-content: center;
          align-items: center;
        }

        .icon-overlay.alert {
          color: var(--alert-color);
        }
        .icon-overlay.success {
          color: var(--success-color);
        }
      `,
    ];
  }

  constructor() {
    super();
    this.activeIndex = -1;
    this.filteredOptions = [];
    this.detectTap = false;
    this.debounceTimer = null;
  }

  connectedCallback() {
    super.connectedCallback();
    this.addEventListener('autofocus', async (evt) => {
      // wait for render to complete
      await this.updateComplete;

      const input = this.shadowRoot.querySelector('input');
      if (input) {
        input.focus();
      }
    });

    if (this.mapboxToken) {
      this.mapboxService = new _services_mapboxService__WEBPACK_IMPORTED_MODULE_3__["default"](this.mapboxToken);
    }

    if (this.googleToken) {
      this.googleGeocodeService = new _services_googleGeocodeService__WEBPACK_IMPORTED_MODULE_4__["default"](this.googleToken, window, document);
    }
  }

  updated(changedProperties) {
    this._scrollOptionListToActive();

    // set variable with width of container for truncating selected options via CSS
    const container = this.shadowRoot.querySelector('.input-group');
    const currentValue = container.style.getPropertyValue('--container-width');
    if (!currentValue) {
      container.style.setProperty(
        '--container-width',
        `${container.clientWidth}px`
      );
    }
  }

  /**
   * When navigating via keyboard, keep active element within visible area of option list
   * @private
   */
  _scrollOptionListToActive() {
    const optionList = this.shadowRoot.querySelector('.option-list');
    const activeEl = this.shadowRoot.querySelector('button.active');
    if (optionList && activeEl) {
      const elTop = activeEl.offsetTop;
      const elBottom = activeEl.offsetTop + activeEl.clientHeight;
      const listTop = optionList.scrollTop;
      const listBottom = optionList.scrollTop + optionList.clientHeight;
      if (elBottom > listBottom) {
        // active element below visible area. scroll down
        optionList.scrollTo({
          top: elBottom - optionList.clientHeight,
          behavior: 'smooth',
        });
      } else if (elTop < listTop) {
        // active element above visible area. scroll up
        optionList.scrollTo({ top: elTop, behavior: 'smooth' });
      }
    }
  }

  _clickOption(e) {
    const target = e.currentTarget ?? e.target;
    if (target && target.value) {
      this._select(JSON.parse(target.value));
    }
  }

  _touchStart(e) {
    if (e.target) {
      this.detectTap = false;
    }
  }

  _touchMove(e) {
    if (e.target) {
      this.detectTap = true;
    }
  }

  _touchEnd(e) {
    if (!this.detectTap) {
      if (e.target && e.target.value) {
        this._clickOption(e);
      }
      this.detectTap = false;
    }
  }

  _keyboardSelectOption() {
    if (this.activeIndex > -1) {
      if (this.activeIndex < this.filteredOptions.length) {
        // select one of the options
        this._select(this.filteredOptions[this.activeIndex]);
      } else {
        // select the Add New option
        this._select({
          value: this.query,
          label: this.query,
        })
      }
    }
  }

  async _select(metadata) {
    if (metadata.place_id && this.googleGeocodeService) {
      // Google Places autocomplete will give a place_id instead of geometry details,
      // so we need to get those details by geocoding the full address from Place lookup
      this.loading = true;
      const place = await this.googleGeocodeService.getPlaceDetails(metadata.label, this.locale);
      this.loading = false;
      if (place) {
        metadata.lat = place.geometry.location.lat;
        metadata.lng = place.geometry.location.lng;
        metadata.level = place.types && place.types.length ? place.types[0] : null;
      }
    }

    // Create custom event with new/old values to pass to onchange function
    const options = {
      detail: {
        metadata,
      },
      bubbles: false,
    };
    this.dispatchEvent(new CustomEvent('select', options));

    // update value in this component
    this.metadata = metadata;
    const input = this.shadowRoot.querySelector('input');
    if (input) {
      input.value = metadata?.label;
    }

    this.open = false; // close options list
    this.activeIndex = -1; // reset keyboard-selected option
  }

  get _focusTarget() {
    let target = this._field;
    if (this.metadata) {
      target = this.shadowRoot.querySelector('button') || target;
    }
    return target;
  }

  _inputFocusIn() {
    this.activeIndex = -1;
  }

  _inputFocusOut(e) {
    // allow clicks on option list button to not close the option list
    // Safari actually passes the parent <li> as the relatedTarget
    if (
      !e.relatedTarget ||
      !['BUTTON', 'LI'].includes(e.relatedTarget.nodeName)
    ) {
      this.open = false;
    }
  }

  _inputKeyDown(e) {
    const keycode = e.keyCode || e.which;

    switch (keycode) {
      case 38: // arrow up
        this.open = true;
        this._listHighlightPrevious();
        break;
      case 40: // arrow down
        this.open = true;
        this._listHighlightNext();
        break;
      case 9: // tab
        if (this.activeIndex < 0) {
          // if pressing tab while no option is selected,
          // close the list so you can go to next field
          this.open = false;
        } else {
          e.preventDefault();
        }
        this._keyboardSelectOption();
        break;
      case 13: // enter
        this._keyboardSelectOption();
        break;
      case 27: // escape
        this.open = false;
        this.activeIndex = -1;
        break;
      default:
        this.open = true;
        break;
    }
  }

  _inputKeyUp(e) {
    const keycode = e.keyCode || e.which;
    const ignoredKeys = [9, 13]; // ignore tab & enter;
    if (e.target.value && !ignoredKeys.includes(keycode)) {
      this.open = true;
    }
    this.query = e.target.value;
  }

  _listHighlightNext() {
    this.activeIndex = Math.min(
      this.filteredOptions.length,
      this.activeIndex + 1
    );
  }

  _listHighlightPrevious() {
    this.activeIndex = Math.max(0, this.activeIndex - 1);
  }

  /**
   * Filter to options that:
   *   1: are not selected
   *   2: match the search query
   * @private
   */
  async _filterOptions() {
    if (this.query) {
      if (this.googleToken && this.googleGeocodeService) {
        this.loading = true;

        try {
          const predictions = await this.googleGeocodeService.getPlacePredictions(this.query, this.locale);

          this.filteredOptions = (predictions || []).map((i) => ({
            label: i.description,
            place_id: i.place_id,
            source: 'user',
            raw: i,
          }));

          this.loading = false;
        } catch (ex) {
          console.error(ex);
          this.error = true;
          this.loading = false;
          return;
        }
      } else if (this.mapboxToken && this.mapboxService) {
        this.loading = true;

        const results = await this.mapboxService.searchPlaces(this.query, this.locale);

        this.filteredOptions = results.map((i) => ({
          lng: i.center[0],
          lat: i.center[1],
          level: i.place_type[0],
          label: i.place_name,
          source: 'user'
        }));

        this.loading = false;
      }
    }
    return this.filteredOptions;
  }

  willUpdate(props) {
    super.willUpdate(props);

    if (props) {
      // // if query changes, trigger filter
      const queryChanged = props.has('query');
      if (queryChanged) {
        this.error = false;
        clearTimeout(this.debounceTimer);
        this.debounceTimer = setTimeout(() => this._filterOptions(), 300);
      }

      // Set the containerHeight for dropdown positioning if it hasn't been set yet
      if (
        !this.containerHeight &&
        this.shadowRoot.children &&
        this.shadowRoot.children.length
      ) {
        const inputGroup = this.shadowRoot.querySelector('.input-group');
        if (inputGroup) {
          this.containerHeight = inputGroup.offsetHeight;
        }
      }
    }
  }

  _change() {

  }
  _delete() {
    const options = {
      detail: {
        metadata: this.metadata,
      },
      bubbles: false,
    };
    this.dispatchEvent(new CustomEvent('delete', options));
  }
  _openMapModal() {
    this.shadowRoot.querySelector('dt-map-modal').dispatchEvent(new Event('open'));
  }
  async _onMapModalSubmit(e) {
    if (e?.detail?.location?.lat) {
      const { location } = e?.detail;
      const { lat, lng } = location;

      // reverse geocode location and save
      if (this.googleGeocodeService) {
        const results = await this.googleGeocodeService.reverseGeocode(lng, lat, this.locale);
        if (results && results.length) {
          const place = results[0];
          this._select({
            lng: place.geometry.location.lng,
            lat: place.geometry.location.lat,
            level: place.types && place.types.length ? place.types[0] : null,
            label: place.formatted_address,
            source: 'user',
          });
        }
      } else if (this.mapboxService) {
        const results = await this.mapboxService.reverseGeocode(lng, lat, this.locale);
        if (results && results.length) {
          const place = results[0];
          this._select({
            lng: place.center[0],
            lat: place.center[1],
            level: place.place_type[0],
            label: place.place_name,
            source: 'user',
          });
        }
      }
    }
  }

  _renderOption(opt, idx, label) {
    return (0,lit__WEBPACK_IMPORTED_MODULE_0__.html)`
      <li tabindex="-1">
        <button
          value="${JSON.stringify(opt)}"
          type="button"
          @click="${this._clickOption}"
          @touchstart="${this._touchStart}"
          @touchmove="${this._touchMove}"
          @touchend="${this._touchEnd}"
          tabindex="-1"
          class="${this.activeIndex > -1 && this.activeIndex === idx
      ? 'active'
      : ''}"
        >
          ${label ?? opt.label}
        </button>
      </li>
    `;
  }

  _renderOptions() {
    let options = [];
    if (!this.filteredOptions.length) {
      if (this.loading) {
        options.push((0,lit__WEBPACK_IMPORTED_MODULE_0__.html)`<li><div>${(0,_lit_localize__WEBPACK_IMPORTED_MODULE_2__.msg)('Loading...')}</div></li>`);
      } else {
        options.push((0,lit__WEBPACK_IMPORTED_MODULE_0__.html)`<li><div>${(0,_lit_localize__WEBPACK_IMPORTED_MODULE_2__.msg)('No Data Available')}</div></li>`);
      }
    } else {
      options.push(...this.filteredOptions.map((opt, idx) => this._renderOption(opt, idx)));
    }

    options.push(this._renderOption({
      value: this.query,
      label: this.query,
    }, (this.filteredOptions || []).length, (0,lit__WEBPACK_IMPORTED_MODULE_0__.html)`<strong>${(0,_lit_localize__WEBPACK_IMPORTED_MODULE_2__.msg)('Use')}: "${this.query}"</strong>`));
    return options;
  }

  render() {
    const optionListStyles = {
      display: this.open ? 'block' : 'none',
      top: this.containerHeight ? `${this.containerHeight}px` : '2.5rem',
    };
    const existingValue = !!this.metadata?.label;
    const hasGeometry = this.metadata?.lat && this.metadata?.lng;
    return (0,lit__WEBPACK_IMPORTED_MODULE_0__.html)`
      <div class="input-group">
        <div class="field-container">      
          <input 
            type="text"
            class="${this.disabled ? 'disabled' : null}"
            placeholder="${this.placeholder}"
            value="${this.metadata?.label}"
            .disabled=${(existingValue && hasGeometry) || this.disabled}
            @focusin="${this._inputFocusIn}"
            @blur="${this._inputFocusOut}"
            @keydown="${this._inputKeyDown}"
            @keyup="${this._inputKeyUp}"
          />
          
          ${existingValue && hasGeometry ? (0,lit__WEBPACK_IMPORTED_MODULE_0__.html)`
          <button 
            class="input-addon btn-map" 
            @click=${this._openMapModal}
            ?disabled=${this.disabled}
          >
            <dt-icon icon="mdi:map" />
          </button>
          ` : null }
          ${existingValue ? (0,lit__WEBPACK_IMPORTED_MODULE_0__.html)`
          <button 
            class="input-addon btn-delete" 
            @click=${this._delete}
            ?disabled=${this.disabled}
          >
            <dt-icon icon="mdi:trash-can-outline" />
          </button>
          ` : (0,lit__WEBPACK_IMPORTED_MODULE_0__.html)`
          <button 
            class="input-addon btn-pin" 
            @click=${this._openMapModal}
            ?disabled=${this.disabled}
          >
            <dt-icon icon="mdi:map-marker-radius" />
          </button>
          ` }
        </div>
        <ul class="option-list" style=${(0,lit_directives_style_map_js__WEBPACK_IMPORTED_MODULE_1__.styleMap)(optionListStyles)}>
          ${this._renderOptions()}
        </ul>
        ${(this.touched && this.invalid) || this.error
          ? (0,lit__WEBPACK_IMPORTED_MODULE_0__.html)`<dt-exclamation-circle class="icon-overlay alert"></dt-exclamation-circle>`
            : null}
        ${this.loading
          ? (0,lit__WEBPACK_IMPORTED_MODULE_0__.html)`<dt-spinner class="icon-overlay"></dt-spinner>` : null}
        ${this.saved 
          ? (0,lit__WEBPACK_IMPORTED_MODULE_0__.html)`<dt-checkmark class="icon-overlay success"></dt-checkmark>` : null}
      </div>
      
      <dt-map-modal 
        .metadata=${this.metadata} 
        mapbox-token="${this.mapboxToken}"
        @submit=${this._onMapModalSubmit} 
      />
      
`;
  }
}
window.customElements.define('dt-location-map-item', DtLocationMapItem);


/***/ }),

/***/ "./node_modules/@disciple.tools/web-components/src/components/form/dt-location-map/dt-location-map.js":
/*!************************************************************************************************************!*\
  !*** ./node_modules/@disciple.tools/web-components/src/components/form/dt-location-map/dt-location-map.js ***!
  \************************************************************************************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   DtLocationMap: () => (/* binding */ DtLocationMap)
/* harmony export */ });
/* harmony import */ var lit__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! lit */ "./node_modules/lit/index.js");
/* harmony import */ var lit_directives_repeat_js__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! lit/directives/repeat.js */ "./node_modules/lit/directives/repeat.js");
/* harmony import */ var _dt_form_base_js__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! ../dt-form-base.js */ "./node_modules/@disciple.tools/web-components/src/components/form/dt-form-base.js");
/* harmony import */ var _dt_location_map_item_js__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(/*! ./dt-location-map-item.js */ "./node_modules/@disciple.tools/web-components/src/components/form/dt-location-map/dt-location-map-item.js");





class DtLocationMap extends _dt_form_base_js__WEBPACK_IMPORTED_MODULE_2__["default"] {
  static get properties() {
    return {
      ...super.properties,
      placeholder: { type: String },
      value: {
        type: Array,
        reflect: true,
      },
      locations: {
        type: Array,
        state: true,
      },
      open: {
        type: Boolean,
        state: true,
      },
      onchange: { type: String },
      mapboxToken: {
        type: String,
        attribute: 'mapbox-token',
      },
      googleToken: {
        type: String,
        attribute: 'google-token',
      },
    };
  }

  static get styles() {
    return [
      ...super.styles,
      (0,lit__WEBPACK_IMPORTED_MODULE_0__.css)`
        :host {
          font-family: Helvetica, Arial, sans-serif;
        }
        .input-group {
          display: flex;
        }

        .field-container {
          position: relative;
        }
      `,
    ];
  }

  constructor() {
    super();
    this.value = [];
    this.locations = [{
      id: Date.now(),
    }];
  }

  _setFormValue(value) {
    super._setFormValue(value);
    this.internals.setFormValue(JSON.stringify(value));
  }

  willUpdate(...args) {
    super.willUpdate(...args);

    if (this.value) {
      if (this.value.filter((opt) => !opt.id)) {
        this.value = [
          ...this.value.map((opt) => ({
            ...opt,
            id: opt.grid_meta_id,
          }))
        ];
      }
    }
    this.updateLocationList();
  }

  firstUpdated(...args) {
    super.firstUpdated(...args);
    this.internals.setFormValue(JSON.stringify(this.value));
  }

  updated(changedProperties) {
    // if length of value was changed, focus the last element
    if (changedProperties.has('value')) {
      const old = changedProperties.get('value');
      if (old && old?.length !== this.value?.length) {
        this.focusNewLocation();
      }
    }
    // if length of locations was changed, focus the last element
    if (changedProperties.has('locations')) {
      const old = changedProperties.get('locations');
      if (old && old?.length !== this.locations?.length) {
        this.focusNewLocation();
      }
    }
  }

  focusNewLocation() {
    const items = this.shadowRoot.querySelectorAll('dt-location-map-item');
    if (items && items.length) {
      // console.log('trigger focus');
      items[items.length - 1].dispatchEvent(new Event('autofocus'));
    }
  }

  updateLocationList() {
    if (!this.disabled && (this.open || !this.value || !this.value.length)) {
      this.open = true;
      this.locations = [
        ...(this.value || []).filter(i => i.label),
        {
          id: Date.now(),
        }
      ];
    } else {
      this.locations = [
        ...(this.value || []).filter(i => i.label),
      ];
    }
  }

  selectLocation(evt) {
    const event = new CustomEvent('change', {
      detail: {
        field: this.name,
        oldValue: this.value,
      },
    });
    const newLocation = {
      ...evt.detail.metadata,
      id: Date.now(),
    }
    this.value = [
      ...(this.value || []).filter(i => i.label),
      newLocation,
    ];
    this.updateLocationList();
    event.detail.newValue = this.value;

    // dispatch event for use with addEventListener from javascript
    this.dispatchEvent(event);
    this._setFormValue(this.value);
  }

  deleteItem(evt) {
    const event = new CustomEvent('change', {
      detail: {
        field: this.name,
        oldValue: this.value,
      },
    });

    const item = evt.detail?.metadata;
    const gridMetaId = item?.grid_meta_id;
    if (gridMetaId) {
      // remove this item from the value
      this.value = (this.value || []).filter(m => m.grid_meta_id !== gridMetaId);
    } else {
      // remove by lat/lng
      this.value = (this.value || []).filter(m => m.lat !== item.lat && m.lng !== item.lng);
    }

    this.updateLocationList();
    event.detail.newValue = this.value;

    // dispatch event for use with addEventListener from javascript
    this.dispatchEvent(event);
    this._setFormValue(this.value);
  }

  addNew() {
    this.open = true;
    this.updateLocationList();
  }

  renderItem(opt) {
    return (0,lit__WEBPACK_IMPORTED_MODULE_0__.html)`
      <dt-location-map-item
        placeholder="${this.placeholder}"
        .metadata=${opt}
        mapbox-token="${this.mapboxToken}"
        google-token="${this.googleToken}"
        @delete=${this.deleteItem}
        @select=${this.selectLocation}
        ?disabled=${this.disabled}
      ></dt-location-map-item>
    `;
  }

  render() {
    const values = [...(this.value || [])];
    values.push({
      id: Date.now(),
    });
    return (0,lit__WEBPACK_IMPORTED_MODULE_0__.html)`
      ${this.labelTemplate()}

      ${(0,lit_directives_repeat_js__WEBPACK_IMPORTED_MODULE_1__.repeat)(this.locations || [], (opt) => opt.id, (opt, idx) => this.renderItem(opt, idx))}
      ${!this.open
        ? (0,lit__WEBPACK_IMPORTED_MODULE_0__.html)`<button @click="${this.addNew}">Add New</button>`
        : null}
    `;
  }
}

window.customElements.define('dt-location-map', DtLocationMap);


/***/ }),

/***/ "./node_modules/@disciple.tools/web-components/src/components/form/dt-location-map/dt-map-modal.js":
/*!*********************************************************************************************************!*\
  !*** ./node_modules/@disciple.tools/web-components/src/components/form/dt-location-map/dt-map-modal.js ***!
  \*********************************************************************************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   DtMapModal: () => (/* binding */ DtMapModal)
/* harmony export */ });
/* harmony import */ var lit__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! lit */ "./node_modules/lit/index.js");
/* harmony import */ var _lit_localize__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! @lit/localize */ "./node_modules/@lit/localize/lit-localize.js");
/* harmony import */ var _dt_base_js__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! ../../dt-base.js */ "./node_modules/@disciple.tools/web-components/src/components/dt-base.js");
/* harmony import */ var _layout_dt_modal_dt_modal_js__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(/*! ../../layout/dt-modal/dt-modal.js */ "./node_modules/@disciple.tools/web-components/src/components/layout/dt-modal/dt-modal.js");





class DtMapModal extends _dt_base_js__WEBPACK_IMPORTED_MODULE_2__["default"] {
  static get properties() {
    return {
      ...super.properties,
      title: { type: String },
      isOpen: { type: Boolean },
      canEdit: { type: Boolean, state: true },
      metadata: { type: Object },
      center: { type: Array },
      mapboxToken: {
        type: String,
        attribute: 'mapbox-token',
      },
    };
  }

  static get styles() {
    return [
      (0,lit__WEBPACK_IMPORTED_MODULE_0__.css)`
        .map {
          width: 100%;
          min-width: 50vw;
          min-height: 50dvb;
        }
      `,
    ];
  }

  constructor() {
    super();

    this.addEventListener('open', (e) => {
      this.shadowRoot.querySelector('dt-modal').dispatchEvent(new Event('open'));
      this.isOpen = true;
    });
    this.addEventListener('close', (e) => {
      this.shadowRoot.querySelector('dt-modal').dispatchEvent(new Event('close'));
      this.isOpen = false;
    });
  }

  connectedCallback() {
    super.connectedCallback();

    this.canEdit = !this.metadata;

    if (!window.mapboxgl) {
      let script = document.createElement('script');
      script.src = 'https://api.mapbox.com/mapbox-gl-js/v2.11.0/mapbox-gl.js';
      script.onload = this.initMap.bind(this);
      document.body.appendChild(script);
      console.log('injected script')
    } else {
      this.initMap();
    }
  }

  initMap() {
    if (!this.isOpen || !window.mapboxgl || !this.mapboxToken) {
      return;
    }

    const mapContainer = this.shadowRoot.querySelector('#map')
    if (mapContainer && !this.map) {
      this.map = new window.mapboxgl.Map({
        accessToken: this.mapboxToken,
        container: mapContainer,
        style: 'mapbox://styles/mapbox/streets-v12', // style URL
        minZoom: 1,
      });
      this.map.on('load', () => this.map.resize());
      if (this.center && this.center.length) {
        this.map.setCenter(this.center);
        this.map.setZoom(15);
      }

      // Add zoom controls
      const nav = new mapboxgl.NavigationControl();
      this.map.addControl(nav, 'bottom-right');

      // Add pin if there is one
      this.addPinFromMetadata();

      // If map is editable add/move marker on click
      this.map.on('click', (e) => {
        if (!this.canEdit) {
          return;
        }
        if (this.marker) {
          this.marker.setLngLat(e.lngLat)
        } else {
          this.marker = new mapboxgl.Marker()
            .setLngLat(e.lngLat)
            .addTo(this.map);
        }
      });
    }
  }

  addPinFromMetadata() {
    if (this.metadata) {
      const { lng, lat, level } = this.metadata;
      let zoom = 15
      if ('admin0' === level) {
        zoom = 3
      } else if ('admin1' === level) {
        zoom = 6
      } else if ('admin2' === level) {
        zoom = 10
      }

      if (this.map) {
        this.map.setCenter([lng, lat]);
        this.map.setZoom(zoom);
        this.marker = new mapboxgl.Marker()
          .setLngLat([lng, lat])
          .addTo(this.map);
      }
    }
  }

  updated(changedProperties) {
    if (!window.mapboxgl) {
      return;
    }

    if (changedProperties.has('metadata') && this.metadata && this.metadata.lat) {
      this.addPinFromMetadata()
    }
    if (changedProperties.has('isOpen') && this.isOpen) {
      this.initMap();
    }
  }

  onClose(e) {
    if (e?.detail?.action === 'button' && this.marker) {
      this.dispatchEvent(new CustomEvent('submit', {
        detail: {
          location: this.marker.getLngLat(),
        }
      }));
    }
  }
  render() {
    return (0,lit__WEBPACK_IMPORTED_MODULE_0__.html)`      
      <dt-modal
        .title=${this.metadata?.label}
        ?isopen=${this.isOpen}
        hideButton
        @close=${this.onClose}
      >
        <div slot="content">
          <div class="map" id="map"></div>
        </div>
       
        ${this.canEdit ? (0,lit__WEBPACK_IMPORTED_MODULE_0__.html)`<div slot="close-button">${(0,_lit_localize__WEBPACK_IMPORTED_MODULE_1__.msg)('Save')}</div>` : null}
      </dt-modal>
      
      <link href='https://api.mapbox.com/mapbox-gl-js/v2.11.0/mapbox-gl.css' rel='stylesheet' />
    `;
  }
}

window.customElements.define('dt-map-modal', DtMapModal);


/***/ }),

/***/ "./node_modules/@disciple.tools/web-components/src/components/form/dt-location/dt-location.js":
/*!****************************************************************************************************!*\
  !*** ./node_modules/@disciple.tools/web-components/src/components/form/dt-location/dt-location.js ***!
  \****************************************************************************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   DtLocation: () => (/* binding */ DtLocation)
/* harmony export */ });
/* harmony import */ var lit__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! lit */ "./node_modules/lit/index.js");
/* harmony import */ var lit_directives_style_map_js__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! lit/directives/style-map.js */ "./node_modules/lit/directives/style-map.js");
/* harmony import */ var lit_directives_map_js__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! lit/directives/map.js */ "./node_modules/lit/directives/map.js");
/* harmony import */ var _dt_tags_dt_tags_js__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(/*! ../dt-tags/dt-tags.js */ "./node_modules/@disciple.tools/web-components/src/components/form/dt-tags/dt-tags.js");





class DtLocation extends _dt_tags_dt_tags_js__WEBPACK_IMPORTED_MODULE_3__.DtTags {
  static get properties() {
    return {
      ...super.properties,
      filters: { type: Array },
      mapboxKey: { type: String },
      dtMapbox: { type: Object },
    };
  }

  static get styles() {
    return [
      ...super.styles,
      (0,lit__WEBPACK_IMPORTED_MODULE_0__.css)`
        .input-group {
          display: flex;
        }

        .field-container {
          position: relative;
        }

        select {
          border: 1px solid var(--dt-form-border-color, #cacaca);
          outline: 0;
        }
        .selected-option > *:first-child {
          max-width: calc(
            var(--container-width) - var(--select-width) -
              var(--container-padding) - var(--option-padding) -
              var(--option-button) - 8px
          );
        }
      `,
    ];
  }

  _clickOption(e) {
    if (e.target && e.target.value) {
      const id = e.target.value;
      const option = this.filteredOptions.reduce((result, opt) => {
        if (!result && opt.id === id) {
          return opt;
        }
        return result;
      }, null);
      this._select(option);
    }
  }

  _clickAddNew(e) {
    if (e.target) {
      this._select({
        id: e.target.dataset?.label,
        label: e.target.dataset?.label,
        isNew: true,
      });
      // clear search field if clicked with mouse, since field will lose focus
      const input = this.shadowRoot.querySelector('input');
      if (input) {
        input.value = '';
      }
    }
  }

  _keyboardSelectOption() {
    if (this.activeIndex > -1) {
      if (this.activeIndex + 1 > this.filteredOptions.length) {
        this._select({
          id: this.query,
          label: this.query,
          isNew: true,
        });
      } else {
        this._select(this.filteredOptions[this.activeIndex]);
      }
    }
  }

  _remove(e) {
    if (e.target && e.target.dataset && e.target.dataset.value) {
      const event = new CustomEvent('change', {
        detail: {
          field: this.name,
          oldValue: this.value,
        },
      });
      this.value = (this.value || []).map(i => {
        const val = {
          ...i,
        };
        if (i.id === e.target.dataset.value) {
          val.delete = true;
        }
        return val;
      });
      event.detail.newValue = this.value;

      // dispatch event for use with addEventListener from javascript
      this.dispatchEvent(event);

      // If option was de-selected while list was open, re-focus input
      if (this.open) {
        this.shadowRoot.querySelector('input').focus();
      }
    }
  }

  updated() {
    super.updated();

    // set variable with width of container for truncating selected options via CSS
    const container = this.shadowRoot.querySelector('.input-group');
    const currentValue = container.style.getPropertyValue('--select-width');
    const select = this.shadowRoot.querySelector('select');
    if (!currentValue && select?.clientWidth > 0) {
      container.style.setProperty('--select-width', `${select.clientWidth}px`);
    }
  }

  /**
   * Filter to options that:
   *   1: are not selected
   *   2: match the search query
   * @private
   */
  _filterOptions() {
    const selectedValues = (this.value || [])
      .filter(i => !i.delete)
      .map(v => v?.id);

    if (this.options?.length) {
      this.filteredOptions = (this.options || []).filter(
        opt =>
          !selectedValues.includes(opt.id) &&
          (!this.query ||
            opt.label
              .toLocaleLowerCase()
              .includes(this.query.toLocaleLowerCase()))
      );
    } else {
      this.loading = true;
      this.filteredOptions = [];

      // need to fetch data via API request
      const self = this;
      const selectEl = this.shadowRoot.querySelector('select');
      const event = new CustomEvent('load', {
        bubbles: true,
        detail: {
          field: this.name,
          query: this.query,
          filter: selectEl?.value,
          onSuccess: result => {
            self.loading = false;

            // filter out selected values from list
            self.filteredOptions = result.filter(
              opt => !selectedValues.includes(opt.id)
            );
          },
          onError: error => {
            console.warn(error);
            self.loading = false;
          },
        },
      });
      this.dispatchEvent(event);
    }
    return this.filteredOptions;
  }

  _renderOption(opt, idx) {
    return (0,lit__WEBPACK_IMPORTED_MODULE_0__.html)`
      <li tabindex="-1">
        <button
          value="${opt.id}"
          type="button"
          data-label="${opt.label}"
          @click="${this._clickOption}"
          @touchstart="${this._touchStart}"
          @touchmove="${this._touchMove}"
          @touchend="${this._touchEnd}"
          tabindex="-1"
          class="${this.activeIndex > -1 && this.activeIndex === idx
      ? 'active'
      : ''}"
        >
          ${opt.label}
        </button>
      </li>
    `;
  }

  _renderSelectedOptions() {
    return (this.value || [])
      .filter(i => !i.delete)
      .map(
        opt => {
          return (0,lit__WEBPACK_IMPORTED_MODULE_0__.html)`
          <div class="selected-option">
            <a
              href="${opt.link}"
              ?disabled="${this.disabled}"
              alt="${opt.status ? opt.status.label : opt.label}"
              >${opt.label}</a
            >
            <button
              @click="${this._remove}"
              ?disabled="${this.disabled}"
              data-value="${opt.id}"
            >
              x
            </button>
          </div>
        `}
      );
  }

  render() {
    const optionListStyles = {
      display: this.open ? 'block' : 'none',
      top: `${this.containerHeight}px`,
    };
    return this.mapboxKey
      ? (0,lit__WEBPACK_IMPORTED_MODULE_0__.html)` ${this.labelTemplate()}
          <div id="mapbox-wrapper">
            <div
              id="mapbox-autocomplete"
              class="mapbox-autocomplete input-group"
              data-autosubmit="true"
              data-add-address="true"
            >
              <input
                id="mapbox-search"
                type="text"
                name="mapbox_search"
                class="input-group-field"
                autocomplete="off"
                dir="auto"
                placeholder="Search Location"
              />
              <div class="input-group-button">
                <button
                  id="mapbox-spinner-button"
                  class="button hollow"
                  style="display:none;border-color:lightgrey;"
                >
                  <span
                    class=""
                    style="border-radius: 50%;width: 24px;height: 24px;border: 0.25rem solid lightgrey;border-top-color: black;animation: spin 1s infinite linear;display: inline-block;"
                  ></span>
                </button>
                <button
                  id="mapbox-clear-autocomplete"
                  class="button alert input-height delete-button-style mapbox-delete-button"
                  type="button"
                  title="Clear"
                  style="display:none;"
                >
                  
                </button>
              </div>
              <div
                id="mapbox-autocomplete-list"
                class="mapbox-autocomplete-items"
              ></div>
            </div>
            <div id="location-grid-meta-results"></div>
          </div>`
      : (0,lit__WEBPACK_IMPORTED_MODULE_0__.html)`
          ${this.labelTemplate()}

          <div class="input-group ${this.disabled ? 'disabled' : ''}">
            <div
              class="field-container"
              @click="${this._focusInput}"
              @keydown="${this._focusInput}"
            >
              ${this._renderSelectedOptions()}
              <input
                type="text"
                placeholder="${this.placeholder}"
                @focusin="${this._inputFocusIn}"
                @blur="${this._inputFocusOut}"
                @keydown="${this._inputKeyDown}"
                @keyup="${this._inputKeyUp}"
                ?disabled="${this.disabled}"
              />

              ${this.loading
                ? (0,lit__WEBPACK_IMPORTED_MODULE_0__.html)`<dt-spinner class="icon-overlay"></dt-spinner>`
                : null}
              ${this.saved
                ? (0,lit__WEBPACK_IMPORTED_MODULE_0__.html)`<dt-checkmark
                    class="icon-overlay success"
                  ></dt-checkmark>`
                : null}
            </div>
            <select class="filter-list" ?disabled="${this.disabled}">
              ${(0,lit_directives_map_js__WEBPACK_IMPORTED_MODULE_2__.map)(
                this.filters,
                f => (0,lit__WEBPACK_IMPORTED_MODULE_0__.html)`<option value="${f.id}">${f.label}</option>`
              )}
            </select>
            <ul class="option-list" style=${(0,lit_directives_style_map_js__WEBPACK_IMPORTED_MODULE_1__.styleMap)(optionListStyles)}>
              ${this._renderOptions()}
            </ul>
          </div>
        `;
  }
}

window.customElements.define('dt-location', DtLocation);


/***/ }),

/***/ "./node_modules/@disciple.tools/web-components/src/components/form/dt-multi-select/dt-multi-select.js":
/*!************************************************************************************************************!*\
  !*** ./node_modules/@disciple.tools/web-components/src/components/form/dt-multi-select/dt-multi-select.js ***!
  \************************************************************************************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   DtMultiSelect: () => (/* binding */ DtMultiSelect)
/* harmony export */ });
/* harmony import */ var lit__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! lit */ "./node_modules/lit/index.js");
/* harmony import */ var lit_directives_style_map_js__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! lit/directives/style-map.js */ "./node_modules/lit/directives/style-map.js");
/* harmony import */ var _lit_localize__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! @lit/localize */ "./node_modules/@lit/localize/lit-localize.js");
/* harmony import */ var _dt_form_base_js__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(/*! ../dt-form-base.js */ "./node_modules/@disciple.tools/web-components/src/components/form/dt-form-base.js");
/* harmony import */ var _mixins_hasOptionsList_js__WEBPACK_IMPORTED_MODULE_4__ = __webpack_require__(/*! ../mixins/hasOptionsList.js */ "./node_modules/@disciple.tools/web-components/src/components/form/mixins/hasOptionsList.js");
/* harmony import */ var _icons_dt_spinner_js__WEBPACK_IMPORTED_MODULE_5__ = __webpack_require__(/*! ../../icons/dt-spinner.js */ "./node_modules/@disciple.tools/web-components/src/components/icons/dt-spinner.js");
/* harmony import */ var _icons_dt_checkmark_js__WEBPACK_IMPORTED_MODULE_6__ = __webpack_require__(/*! ../../icons/dt-checkmark.js */ "./node_modules/@disciple.tools/web-components/src/components/icons/dt-checkmark.js");








class DtMultiSelect extends (0,_mixins_hasOptionsList_js__WEBPACK_IMPORTED_MODULE_4__.HasOptionsList)(_dt_form_base_js__WEBPACK_IMPORTED_MODULE_3__["default"]) {
  static get styles() {
    return [
      ...super.styles,
      (0,lit__WEBPACK_IMPORTED_MODULE_0__.css)`
        :host {
          position: relative;
          font-family: Helvetica, Arial, sans-serif;
        }

        .input-group {
          color: var(--dt-multi-select-text-color, #0a0a0a);
          margin-bottom: 1rem;
        }
        .input-group.disabled input,
        .input-group.disabled .field-container {
          background-color: var(--disabled-color);
        }
        .input-group.disabled a,
        .input-group.disabled button {
          cursor: not-allowed;
          pointer-events: none;
        }
        .input-group.disabled *:hover {
          cursor: not-allowed;
        }

        .field-container {
          background-color: var(--dt-multi-select-background-color, #fefefe);
          border: 1px solid var(--dt-form-border-color, #cacaca);
          border-radius: 0;
          color: var(--dt-multi-select-text-color, #0a0a0a);
          font-size: 1rem;
          font-weight: 300;
          min-height: 2.5rem;
          line-height: 1.5;
          margin: 0;
          padding-top: calc(0.5rem - 0.375rem);
          padding-bottom: 0.5rem;
          padding-inline: 0.5rem 1.6rem;
          box-sizing: border-box;
          width: 100%;
          text-transform: none;
          display: flex;
          flex-wrap: wrap;
        }

        .field-container input,
        .field-container .selected-option {
          height: 1.25rem;
        }

        .selected-option {
          border: 1px solid var(--dt-multi-select-tag-border-color, #c2e0ff);
          background-color: var(
            --dt-multi-select-tag-background-color,
            #c2e0ff
          );

          display: flex;
          font-size: 0.875rem;
          position: relative;
          border-radius: 2px;
          margin-inline-end: 4px;
          margin-block-start: 0.375rem;
          box-sizing: border-box;
        }
        .selected-option > *:first-child {
          padding-inline-start: 4px;
          text-overflow: ellipsis;
          overflow: hidden;
          white-space: nowrap;
          --container-padding: calc(0.5rem + 1.6rem + 2px);
          --option-padding: 8px;
          --option-button: 20px;
          max-width: calc(
            var(--container-width) - var(--container-padding) -
              var(--option-padding) - var(--option-button)
          );
        }
        .selected-option * {
          align-self: center;
        }
        .selected-option button {
          background: transparent;
          outline: 0;
          border: 0;
          border-inline-start: 1px solid
            var(--dt-multi-select-tag-border-color, #c2e0ff);
          color: var(--dt-multi-select-text-color, #0a0a0a);
          margin-inline-start: 4px;
        }
        .selected-option button:hover {
          cursor: pointer;
        }

        .field-container input {
          background-color: var(--dt-form-background-color, #fff);
          color: var(--dt-form-text-color, #000);
          flex-grow: 1;
          min-width: 50px;
          border: 0;
          margin-block-start: 0.375rem;
        }
        .field-container input:focus,
        .field-container input:focus-visible,
        .field-container input:active {
          border: 0;
          outline: 0;
        }
        .field-container input::placeholder {
          color: var(--dt-text-placeholder-color, #999);
          opacity: 1;
        }

        /* === Options List === */
        .option-list {
          list-style: none;
          margin: 0;
          padding: 0;
          border: 1px solid var(--dt-form-border-color, #cacaca);
          background: var(--dt-form-background-color, #fefefe);
          z-index: 10;
          position: absolute;
          width: 100%;
          top: 0;
          left: 0;
          box-shadow: var(--shadow-1);
          max-height: 150px;
          overflow-y: scroll;
        }
        .option-list li {
          border-block-start: 1px solid var(--dt-form-border-color, #cacaca);
          outline: 0;
        }
        .option-list li div,
        .option-list li button {
          padding: 0.5rem 0.75rem;
          color: var(--dt-multi-select-text-color, #0a0a0a);
          font-weight: 100;
          font-size: 1rem;
          text-decoration: none;
          text-align: inherit;
        }
        .option-list li button {
          display: block;
          width: 100%;
          border: 0;
          background: transparent;
        }
        .option-list li button:hover,
        .option-list li button.active {
          cursor: pointer;
          background: var(--dt-multi-select-option-hover-background, #f5f5f5);
        }
      `,
    ];
  }

  static get properties() {
    return {
      ...super.properties,
      placeholder: { type: String },
      containerHeight: {
        type: Number,
        state: true,
      },
      onchange: { type: String },
    };
  }

  _select(value) {
    // Create custom event with new/old values to pass to onchange function
    const event = new CustomEvent('change', {
      bubbles: true,
      detail: {
        field: this.name,
        oldValue: this.value,
      },
    });

    // update value in this component
    if (this.value && this.value.length) {
      if (typeof this.value[0] === 'string') {
        // If value is array of strings, check for same value prefixed with hyphen
        this.value = [...this.value.filter(i => i !== `-${value}`), value];
      } else {
        // If value is array of objects, check for same value with `delete` property
        let foundPrevious = false;
        const newVal = this.value.map(i => {
          const val = {
            ...i,
          };
          if (i.id === value.id && i.delete) {
            delete val.delete;
            foundPrevious = true;
          }
          return val;
        });
        if (!foundPrevious) {
          newVal.push(value);
        }
        this.value = newVal;
      }
    } else {
      this.value = [value];
    }
    event.detail.newValue = this.value;
    this.open = false; // close options list
    this.activeIndex = -1; // reset keyboard-selected option

    // dispatch event for use with addEventListener from javascript
    this.dispatchEvent(event);
    this._setFormValue(this.value);
  }

  _remove(e) {
    if (e.target && e.target.dataset && e.target.dataset.value) {
      const event = new CustomEvent('change', {
        bubbles: true,
        detail: {
          field: this.name,
          oldValue: this.value,
        },
      });
      this.value = (this.value || []).map(i =>
        i === e.target.dataset.value ? `-${i}` : i
      );
      event.detail.newValue = this.value;

      // dispatch event for use with addEventListener from javascript
      this.dispatchEvent(event);
      this._setFormValue(this.value);

      // If option was de-selected while list was open, re-focus input
      if (this.open) {
        this.shadowRoot.querySelector('input').focus();
      }
    }
  }

  /**
   * Filter to options that:
   *   1: are not selected
   *   2: match the search query
   * @private
   */
  _filterOptions() {
    this.filteredOptions = (this.options || []).filter(
      opt =>
        !(this.value || []).includes(opt.id) &&
        (!this.query ||
          opt.label
            .toLocaleLowerCase()
            .includes(this.query.toLocaleLowerCase()))
    );
    return this.filteredOptions;
  }

  willUpdate(props) {
    super.willUpdate(props);

    if (props) {
      const valueChanged = props.has('value');
      const queryChanged = props.has('query');
      const optionsChanged = props.has('options');

      // if value, query, or options change, trigger filter
      if (valueChanged || queryChanged || optionsChanged) {
        this._filterOptions();
      }
    }
  }

  _renderSelectedOptions() {
    return (
      this.options &&
      this.options
        .filter(opt => this.value && this.value.indexOf(opt.id) > -1)
        .map(
          opt => (0,lit__WEBPACK_IMPORTED_MODULE_0__.html)`
            <div class="selected-option">
              <span>${opt.label}</span>
              <button
                @click="${this._remove}"
                ?disabled="${this.disabled}"
                data-value="${opt.id}"
              >
                x
              </button>
            </div>
          `
        )
    );
  }

  render() {
    const optionListStyles = {
      display: this.open ? 'block' : 'none',
      top: this.containerHeight ? `${this.containerHeight}px` : '2.5rem',
    };
    return (0,lit__WEBPACK_IMPORTED_MODULE_0__.html)`
      ${this.labelTemplate()}

      <div class="input-group ${this.disabled ? 'disabled' : ''}">
        <div
          class="field-container"
          @click="${this._focusInput}"
          @keydown="${this._focusInput}"
        >
          ${this._renderSelectedOptions()}
          <input
            type="text"
            placeholder="${this.placeholder}"
            @focusin="${this._inputFocusIn}"
            @blur="${this._inputFocusOut}"
            @keydown="${this._inputKeyDown}"
            @keyup="${this._inputKeyUp}"
            ?disabled="${this.disabled}"
          />
        </div>
        <ul class="option-list" style=${(0,lit_directives_style_map_js__WEBPACK_IMPORTED_MODULE_1__.styleMap)(optionListStyles)}>
          ${this._renderOptions()}
        </ul>
        ${this.loading
          ? (0,lit__WEBPACK_IMPORTED_MODULE_0__.html)`<dt-spinner class="icon-overlay"></dt-spinner>`
          : null}
        ${this.saved
          ? (0,lit__WEBPACK_IMPORTED_MODULE_0__.html)`<dt-checkmark class="icon-overlay success"></dt-checkmark>`
          : null}
        ${this.error
          ? (0,lit__WEBPACK_IMPORTED_MODULE_0__.html)`<dt-icon
                icon="mdi:alert-circle"
                class="icon-overlay alert"
                tooltip="${this.error}"
                size="2rem"
                ></dt-icon>`
              : null}
        </div>
`;
  }
}

window.customElements.define('dt-multi-select', DtMultiSelect);


/***/ }),

/***/ "./node_modules/@disciple.tools/web-components/src/components/form/dt-number/dt-number.js":
/*!************************************************************************************************!*\
  !*** ./node_modules/@disciple.tools/web-components/src/components/form/dt-number/dt-number.js ***!
  \************************************************************************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   DtNumberField: () => (/* binding */ DtNumberField)
/* harmony export */ });
/* harmony import */ var lit__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! lit */ "./node_modules/lit/index.js");
/* harmony import */ var lit_directives_if_defined_js__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! lit/directives/if-defined.js */ "./node_modules/lit/directives/if-defined.js");
/* harmony import */ var _dt_form_base_js__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! ../dt-form-base.js */ "./node_modules/@disciple.tools/web-components/src/components/form/dt-form-base.js");
/* harmony import */ var _services_apiService_js__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(/*! ../../../services/apiService.js */ "./node_modules/@disciple.tools/web-components/src/services/apiService.js");





class DtNumberField extends _dt_form_base_js__WEBPACK_IMPORTED_MODULE_2__["default"] {
  static get styles() {
    return [
      ...super.styles,
      (0,lit__WEBPACK_IMPORTED_MODULE_0__.css)`
        input {
          color: var(--dt-form-text-color, #000);
          appearance: none;
          background-color: var(--dt-form-background-color, #fff);
          border: 1px solid var(--dt-form-border-color, #ccc);
          border-radius: 0;
          box-shadow: var(
            --dt-form-input-box-shadow,
            inset 0 1px 2px hsl(0deg 0% 4% / 10%)
          );
          box-sizing: border-box;
          display: block;
          font-family: inherit;
          font-size: 1rem;
          font-weight: 300;
          height: 2.5rem;
          line-height: 1.5;
          margin: 0 0 1.0666666667rem;
          padding: var(--dt-form-padding, 0.5333333333rem);
          transition: var(
            --dt-form-transition,
            box-shadow 0.5s,
            border-color 0.25s ease-in-out
          );
        }
        input:disabled,
        input[readonly],
        textarea:disabled,
        textarea[readonly] {
          background-color: var(--dt-form-disabled-background-color, #e6e6e6);
          cursor: not-allowed;
        }
        input:invalid {
          border-color: var(--dt-form-invalid-border-color, #dc3545);
        }
      `,
    ];
  }

  static get properties() {
    return {
      ...super.properties,
      id: { type: String },
      value: {
        type: String,
        reflect: true,
      },
      oldValue: {
        type: String,
      },
      min: { type: Number },
      max: { type: Number },
      loading: { type: Boolean },
      saved: { type: Boolean },
      onchange: { type: String },
    };
  }

  connectedCallback() {
    super.connectedCallback();
    this.oldValue = this.value;
  }

  _checkValue(value) {
    if (value < this.min || value > this.max) {
      return false;
    }

    return true;
  }

  async onChange(e) {
    if (this._checkValue(e.target.value)) {
      const event = new CustomEvent('change', {
        detail: {
          field: this.name,
          oldValue: this.value,
          newValue: e.target.value,
        },
        bubbles: true,
        composed: true,
      });

      this.value = e.target.value;
      this._field.setCustomValidity('');
      this.dispatchEvent(event);
      this.api = new _services_apiService_js__WEBPACK_IMPORTED_MODULE_3__["default"](this.nonce, `${this.apiRoot}`);

      /*try {
        const response = await this.api.updatePost(this.postType, this.postID, {
          [this.name]: e.target.value,
        });
        if (response.data && response.data.status !== 200) {
          this.handleError(response.message);
        } else {
          this.saved = true;
          this.oldValue = this.value;
        }
      } catch (error) {
        this.handleError(error);
      }*/
    } else {
      e.currentTarget.value = '';
    }
  }

  handleError(er = 'An error occurred.') {
    let error = er;
    if (error instanceof Error) {
      console.error(error);
      error = error.message;
    } else {
      console.error(error);
    }
    this.error = error;
    this._field.setCustomValidity(error);
    this.invalid = true;
    this.value = this.oldValue;
  }

  render() {
    return (0,lit__WEBPACK_IMPORTED_MODULE_0__.html)`
      ${this.labelTemplate()}

      <input
        id="${this.id}"
        name="${this.name}"
        aria-label="${this.label}"
        type="number"
        ?disabled=${this.disabled}
        class="text-input"
        .value="${this.value}"
        min="${(0,lit_directives_if_defined_js__WEBPACK_IMPORTED_MODULE_1__.ifDefined)(this.min)}"
        max="${(0,lit_directives_if_defined_js__WEBPACK_IMPORTED_MODULE_1__.ifDefined)(this.max)}"
        @change=${this.onChange}
      />
    `;
  }
}

window.customElements.define('dt-number', DtNumberField);


/***/ }),

/***/ "./node_modules/@disciple.tools/web-components/src/components/form/dt-single-select/dt-single-select.js":
/*!**************************************************************************************************************!*\
  !*** ./node_modules/@disciple.tools/web-components/src/components/form/dt-single-select/dt-single-select.js ***!
  \**************************************************************************************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   DtSingleSelect: () => (/* binding */ DtSingleSelect)
/* harmony export */ });
/* harmony import */ var lit__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! lit */ "./node_modules/lit/index.js");
/* harmony import */ var _dt_form_base_js__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ../dt-form-base.js */ "./node_modules/@disciple.tools/web-components/src/components/form/dt-form-base.js");
/* harmony import */ var _icons_dt_spinner_js__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! ../../icons/dt-spinner.js */ "./node_modules/@disciple.tools/web-components/src/components/icons/dt-spinner.js");
/* harmony import */ var _icons_dt_checkmark_js__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(/*! ../../icons/dt-checkmark.js */ "./node_modules/@disciple.tools/web-components/src/components/icons/dt-checkmark.js");





class DtSingleSelect extends _dt_form_base_js__WEBPACK_IMPORTED_MODULE_1__["default"] {
  static get styles() {
    return [
      ...super.styles,
      (0,lit__WEBPACK_IMPORTED_MODULE_0__.css)`
        :host {
          position: relative;
        }

        select {
          appearance: none;
          background-color: var(--dt-form-background-color, #fefefe);
          background-image: linear-gradient(
              45deg,
              transparent 50%,
              var(--dt-single-select-text-color) 50%
            ),
            linear-gradient(
              135deg,
              var(--dt-single-select-text-color) 50%,
              transparent 50%
            );
          background-position: calc(100% - 20px) calc(1em + 2px),
            calc(100% - 15px) calc(1em + 2px), calc(100% - 2.5em) 0.5em;
          background-size: 5px 5px, 5px 5px, 1px 1.5em;
          background-repeat: no-repeat;
          border: 1px solid var(--dt-form-border-color, #cacaca);
          border-radius: 0;
          color: var(--dt-single-select-text-color, #0a0a0a);
          font-family: var(--font-family, sans-serif);
          font-size: 1rem;
          font-weight: 300;
          height: 2.5rem;
          line-height: 1.5;
          margin: 0 0 1rem;
          padding: 0.53rem;
          padding-inline-end: 1.6rem;
          transition: border-color 0.25s ease-in-out;
          transition: box-shadow 0.5s, border-color 0.25s ease-in-out;
          box-sizing: border-box;
          width: 100%;
          text-transform: none;
        }
        [dir='rtl'] select {
          background-position: 15px calc(1em + 2px), 20px calc(1em + 2px),
            2.5em 0.5em;
        }
        select.color-select {
          background-image: url("data:image/svg+xml;utf8,<svg xmlns='http://www.w3.org/2000/svg' version='1.1' width='32' height='24' viewBox='0 0 32 24'><polygon points='0,0 32,0 16,24' style='fill: white'></polygon></svg>");
          background-color: var(--dt-form-border-color, #cacaca);
          border: none;
          border-radius: 10px;
          color: var(--dt-single-select-text-color-inverse, #fff);
          font-weight: 700;
          text-shadow: rgb(0 0 0 / 45%) 0 0 6px;
        }

        .icon-overlay {
          inset-inline-end: 2.5rem;
        }
      `,
    ];
  }

  static get properties() {
    return {
      ...super.properties,
      placeholder: { type: String },
      options: { type: Array },
      value: {
        type: String,
        reflect: true,
      },
      color: {
        type: String,
        state: true,
      },
      onchange: { type: String },
    };
  }

  /**
   * Find the color for the currently selected value
   */
  updateColor() {
    if (this.value && this.options) {
      const options = this.options.filter(opt => opt.id === this.value);
      if (options && options.length) {
        this.color = options[0].color;
      }
    }
  }

  isColorSelect() {
    return (this.options || []).reduce(
      (isColor, option) => isColor || option.color,
      false
    );
  }

  willUpdate(changedProperties) {
    super.willUpdate(changedProperties);
    if (changedProperties.has('value')) {
      this.updateColor();
    }
  }

  _change(e) {
    // Create custom event with new/old values to pass to onchange function
    const event = new CustomEvent('change', {
      detail: {
        field: this.name,
        oldValue: this.value,
        newValue: e.target.value,
      },
    });

    // update value in this component
    this.value = e.target.value;
    this._setFormValue(this.value);

    // dispatch event for use with addEventListener from javascript
    this.dispatchEvent(event);
  }

  render() {
    return (0,lit__WEBPACK_IMPORTED_MODULE_0__.html)`
      ${this.labelTemplate()}

      <div class="container" dir="${this.RTL ? 'rtl' : 'ltr'}">
        <select
          name="${this.name}"
          aria-label="${this.name}"
          @change="${this._change}"
          class="${this.isColorSelect() ? 'color-select' : ''}"
          style="background-color: ${this.color};"
          ?disabled="${this.disabled}"
        >
          <option disabled selected hidden value="">${this.placeholder}</option>

          ${this.options &&
          this.options.map(
            i => (0,lit__WEBPACK_IMPORTED_MODULE_0__.html)`
              <option value="${i.id}" ?selected="${i.id === this.value}">
                ${i.label}
              </option>
            `
          )}
        </select>
        ${this.loading
          ? (0,lit__WEBPACK_IMPORTED_MODULE_0__.html)`<dt-spinner class="icon-overlay"></dt-spinner>`
          : null}
        ${this.saved
          ? (0,lit__WEBPACK_IMPORTED_MODULE_0__.html)`<dt-checkmark class="icon-overlay success"></dt-checkmark>`
          : null}
      </div>
    `;
  }
}

window.customElements.define('dt-single-select', DtSingleSelect);


/***/ }),

/***/ "./node_modules/@disciple.tools/web-components/src/components/form/dt-tags/dt-tags.js":
/*!********************************************************************************************!*\
  !*** ./node_modules/@disciple.tools/web-components/src/components/form/dt-tags/dt-tags.js ***!
  \********************************************************************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   DtTags: () => (/* binding */ DtTags)
/* harmony export */ });
/* harmony import */ var lit__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! lit */ "./node_modules/lit/index.js");
/* harmony import */ var _dt_multi_select_dt_multi_select_js__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ../dt-multi-select/dt-multi-select.js */ "./node_modules/@disciple.tools/web-components/src/components/form/dt-multi-select/dt-multi-select.js");



class DtTags extends _dt_multi_select_dt_multi_select_js__WEBPACK_IMPORTED_MODULE_1__.DtMultiSelect {
  static get properties() {
    return {
      ...super.properties,
      allowAdd: { type: Boolean },
      onload: { type: String },
    };
  }

  static get styles() {
    return [
      ...super.styles,
      (0,lit__WEBPACK_IMPORTED_MODULE_0__.css)`
        .selected-option a,
        .selected-option a:active,
        .selected-option a:visited {
          text-decoration: none;
          color: var(--primary-color, #3f729b);
        }
      `,
    ];
  }

  willUpdate(props) {
    super.willUpdate(props);

    if (props) {
      const openChanged = props.has('open');
      // When list is first opened and we don't have any options yet,
      // trigger _filterOptions to load options
      if (openChanged && this.open && (!this.filteredOptions || !this.filteredOptions.length)) {
        this._filterOptions();
      }
    }
  }

  /**
   * Filter to options that:
   *   1: are not selected
   *   2: match the search query
   * @private
   */
  _filterOptions() {
    const selectedValues = (this.value || [])
      .filter(i => !i.startsWith('-'));

    if (this.options?.length) {
      this.filteredOptions = (this.options || []).filter(
        opt =>
          !selectedValues.includes(opt.id) &&
          (!this.query ||
            opt.id
              .toLocaleLowerCase()
              .includes(this.query.toLocaleLowerCase()))
      );
    } else if (this.open) {
      // Only run this filtering if the list is open.
      // This prevents it from running on initial load before a `load` event is attached.
      this.loading = true;
      this.filteredOptions = [];

      // need to fetch data via API request
      const self = this;
      const event = new CustomEvent('load', {
        bubbles: true,
        detail: {
          field: this.name,
          postType: this.postType,
          query: this.query,
          onSuccess: result => {
            self.loading = false;

            // if given an array of strings, transform to object array
            let options = result;
            if (options.length && typeof options[0] === 'string') {
              options = options.map(o => ({
                id: o,
              }));
            }

            self.allOptions = options;
            // filter out selected values from list
            self.filteredOptions = options.filter(
              opt => !selectedValues.includes(opt.id)
            );
          },
          onError: error => {
            console.warn(error);
            self.loading = false;
          },
        },
      });
      this.dispatchEvent(event);
    }
    return this.filteredOptions;
  }

  _renderOption(opt, idx) {
    return (0,lit__WEBPACK_IMPORTED_MODULE_0__.html)`
      <li tabindex="-1">
        <button
          value="${opt.id}"
          type="button"
          data-label="${opt.label}"
          @click="${this._clickOption}"
          @touchstart="${this._touchStart}"
          @touchmove="${this._touchMove}"
          @touchend="${this._touchEnd}"
          tabindex="-1"
          class="${this.activeIndex > -1 && this.activeIndex === idx
      ? 'active'
      : ''}"
        >
          ${opt.label || opt.id}
        </button>
      </li>
    `;
  }

  _renderSelectedOptions() {
    const options = this.options || this.allOptions;
    return (this.value || [])
      .filter(i => !i.startsWith('-'))
      .map(
        tag => {
          let label = tag;
          if (options) {
            const option = options.filter(o => o === tag || o.id === tag);
            if (option.length) {
              label = option[0].label || option[0].id || tag;
            }
          }
          let link;
          if (!link && window?.SHAREDFUNCTIONS?.createCustomFilter) {
            const query =  window.SHAREDFUNCTIONS.createCustomFilter(this.name, [tag])
            const fieldLabel = this.label || this.name
            const labels = [{ id: `${this.name}_${tag}`, name: `${fieldLabel}: ${tag}`}]
            link = window.SHAREDFUNCTIONS.create_url_for_list_query(this.postType, query, labels);
          }
          return (0,lit__WEBPACK_IMPORTED_MODULE_0__.html)`
          <div class="selected-option">
            <a
              href="${link || '#'}"
              ?disabled="${this.disabled}"
              alt="${tag}"
              >${label}</a
            >
            <button
              @click="${this._remove}"
              ?disabled="${this.disabled}"
              data-value="${tag}"
            >
              x
            </button>
          </div>
        `}
      );
  }
}

window.customElements.define('dt-tags', DtTags);


/***/ }),

/***/ "./node_modules/@disciple.tools/web-components/src/components/form/dt-text/dt-text.js":
/*!********************************************************************************************!*\
  !*** ./node_modules/@disciple.tools/web-components/src/components/form/dt-text/dt-text.js ***!
  \********************************************************************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   DtText: () => (/* binding */ DtText)
/* harmony export */ });
/* harmony import */ var lit__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! lit */ "./node_modules/lit/index.js");
/* harmony import */ var lit_directives_class_map_js__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! lit/directives/class-map.js */ "./node_modules/lit/directives/class-map.js");
/* harmony import */ var _dt_form_base_js__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! ../dt-form-base.js */ "./node_modules/@disciple.tools/web-components/src/components/form/dt-form-base.js");
/* harmony import */ var _icons_dt_spinner_js__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(/*! ../../icons/dt-spinner.js */ "./node_modules/@disciple.tools/web-components/src/components/icons/dt-spinner.js");
/* harmony import */ var _icons_dt_checkmark_js__WEBPACK_IMPORTED_MODULE_4__ = __webpack_require__(/*! ../../icons/dt-checkmark.js */ "./node_modules/@disciple.tools/web-components/src/components/icons/dt-checkmark.js");
/* harmony import */ var _icons_dt_exclamation_circle_js__WEBPACK_IMPORTED_MODULE_5__ = __webpack_require__(/*! ../../icons/dt-exclamation-circle.js */ "./node_modules/@disciple.tools/web-components/src/components/icons/dt-exclamation-circle.js");







class DtText extends _dt_form_base_js__WEBPACK_IMPORTED_MODULE_2__["default"] {
  static get styles() {
    return [
      ...super.styles,
      (0,lit__WEBPACK_IMPORTED_MODULE_0__.css)`
        input {
          color: var(--dt-form-text-color, #000);
          appearance: none;
          background-color: var(--dt-text-background-color, #fefefe);
          border: 1px solid var(--dt-text-border-color, #fefefe);
          border-radius: var(--dt-text-border-radius, 0);
          box-shadow: var(
            --dt-text-box-shadow,
            var(
              --dt-form-input-box-shadow,
              inset 0 1px 2px hsl(0deg 0% 4% / 10%)
            )
          );
          box-sizing: border-box;
          display: block;
          font-family: inherit;
          font-size: 1rem;
          font-weight: 300;
          height: 2.5rem;
          line-height: 1.5;
          margin: 0 0 1.0666666667rem;
          padding: var(--dt-form-padding, 0.5333333333rem);
          transition: var(
            --dt-form-transition,
            box-shadow 0.5s,
            border-color 0.25s ease-in-out
          );
          width: 100%;
        }
        input:disabled,
        input[readonly],
        textarea:disabled,
        textarea[readonly] {
          background-color: var(
            --dt-text-disabled-background-color,
            var(--dt-form-disabled-background-color, #e6e6e6)
          );
          cursor: copy;
        }
        input:focus-within,
        input:focus-visible {
          outline: none;
        }
        input::placeholder {
          color: var(--dt-text-placeholder-color, #999);
          text-transform: var(--dt-text-placeholder-transform, none);
          font-size: var(--dt-text-placeholder-font-size, 1rem);
          font-weight: var(--dt-text-placeholder-font-weight, 400);
          letter-spacing: var(--dt-text-placeholder-letter-spacing, normal);
        }
        input.invalid {
          border-color: var(--dt-text-border-color-alert, var(--alert-color));
        }
      `,
    ];
  }

  static get properties() {
    return {
      ...super.properties,
      id: { type: String },
      type: { type: String },
      placeholder: { type: String },
      value: {
        type: String,
        reflect: true,
      },
      onchange: { type: String },
    };
  }

  _change(e) {
    const event = new CustomEvent('change', {
      bubbles: true,
      detail: {
        field: this.name,
        oldValue: this.value,
        newValue: e.target.value,
      },
    });

    this.value = e.target.value;

    this._setFormValue(this.value);

    this.dispatchEvent(event);
  }

  implicitFormSubmit(e) {
    const keycode = e.keyCode || e.which;
    // If the Enter key is pressed, find the first button in the form and click it.
    // This replicates normal browser handling of input elements when pressing Enter
    if (keycode === 13 && this.internals.form) {
      const button = this.internals.form.querySelector('button');
      if (button) {
        button.click();
      }
    }
  }

  _validateRequired() {
    const { value } = this;
    const input = this.shadowRoot.querySelector('input');
    if (value === '' && this.required) {
      this.invalid = true;
      this.internals.setValidity(
        {
          valueMissing: true,
        },
        this.requiredMessage || 'This field is required',
        input
      );
    } else {
      this.invalid = false;
      this.internals.setValidity({});
    }
  }

  get classes() {
    const classes = {
      'text-input': true,
      invalid: this.touched && this.invalid,
    };
    return classes;
  }

  render() {
    return (0,lit__WEBPACK_IMPORTED_MODULE_0__.html)`
      ${this.labelTemplate()}

      <div class="input-group">
        <input
          id="${this.id}"
          name="${this.name}"
          aria-label="${this.label}"
          type="${this.type || 'text'}"
          placeholder="${this.placeholder}"
          ?disabled=${this.disabled}
          ?required=${this.required}
          class="${(0,lit_directives_class_map_js__WEBPACK_IMPORTED_MODULE_1__.classMap)(this.classes)}"
          .value="${this.value || ''}"
          @change=${this._change}
          novalidate
          @keyup="${this.implicitFormSubmit}"
        />

        ${this.touched && this.invalid
          ? (0,lit__WEBPACK_IMPORTED_MODULE_0__.html)`<dt-exclamation-circle
              class="icon-overlay alert"
            ></dt-exclamation-circle>`
          : null}
        ${this.error
          ? (0,lit__WEBPACK_IMPORTED_MODULE_0__.html)`<dt-icon
              icon="mdi:alert-circle"
              class="icon-overlay alert"
              tooltip="${this.error}"
              size="2rem"
              ></dt-icon>`
            : null}
        ${this.loading
          ? (0,lit__WEBPACK_IMPORTED_MODULE_0__.html)`<dt-spinner class="icon-overlay"></dt-spinner>`
          : null}
        ${this.saved
          ? (0,lit__WEBPACK_IMPORTED_MODULE_0__.html)`<dt-checkmark class="icon-overlay success"></dt-checkmark>`
          : null}
      </div>
    `;
  }
}

window.customElements.define('dt-text', DtText);


/***/ }),

/***/ "./node_modules/@disciple.tools/web-components/src/components/form/dt-textarea/dt-textarea.js":
/*!****************************************************************************************************!*\
  !*** ./node_modules/@disciple.tools/web-components/src/components/form/dt-textarea/dt-textarea.js ***!
  \****************************************************************************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   DtTextArea: () => (/* binding */ DtTextArea)
/* harmony export */ });
/* harmony import */ var lit__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! lit */ "./node_modules/lit/index.js");
/* harmony import */ var _dt_form_base_js__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ../dt-form-base.js */ "./node_modules/@disciple.tools/web-components/src/components/form/dt-form-base.js");



class DtTextArea extends _dt_form_base_js__WEBPACK_IMPORTED_MODULE_1__["default"] {
  static get styles() {
    return [
      ...super.styles,
      (0,lit__WEBPACK_IMPORTED_MODULE_0__.css)`
        textarea {
          color: var(--dt-textarea-text-color, #0a0a0a);
          appearance: none;
          background-color: var(--dt-textarea-background-color, #fefefe);
          border: 1px solid var(--dt-textarea-border-color, #cecece);
          border-radius: 3px;
          box-shadow: var(
            --dt-textarea-input-box-shadow,
            inset 0 1px 2px hsl(0deg 0% 4% / 10%)
          );
          box-sizing: border-box;
          display: block;
          font-family: inherit;
          font-size: 1rem;
          font-weight: 300;
          height: 10rem;
          line-height: 1.5;
          margin: 0 0 1.0666666667rem;
          padding: var(--dt-form-padding, 0.5333333333rem);
          transition: var(
            --dt-form-transition,
            box-shadow 0.5s,
            border-color 0.25s ease-in-out
          );
          overflow: hidden;
          position: relative;
          outline: 0;
          resize: none;
        }
        input:disabled,
        input[readonly],
        textarea:disabled,
        textarea[readonly] {
          background-color: var(
            --dt-textarea-disabled-background-color,
            #e6e6e6
          );
          cursor: not-allowed;
        }
      `,
    ];
  }

  static get properties() {
    return {
      ...super.properties,
      id: { type: String },
      value: {
        type: String,
        reflect: true,
      },
      loading: { type: Boolean },
      saved: { type: Boolean },
      onchange: { type: String },
    };
  }

  onChange(e) {
    const event = new CustomEvent('change', {
      detail: {
        field: this.name,
        oldValue: this.value,
        newValue: e.target.value,
      },
    });

    this.value = e.target.value;

    this.dispatchEvent(event);
  }

  render() {
    return (0,lit__WEBPACK_IMPORTED_MODULE_0__.html)`
      ${this.labelTemplate()}

      <textarea
        id="${this.id}"
        name="${this.name}"
        aria-label="${this.label}"
        type="text"
        ?disabled=${this.disabled}
        class="text-input"
        @change=${this.onChange}
        .value="${this.value || ''}"
      ></textarea>
    `;
  }
}

window.customElements.define('dt-textarea', DtTextArea);


/***/ }),

/***/ "./node_modules/@disciple.tools/web-components/src/components/form/dt-toggle/dt-toggle.js":
/*!************************************************************************************************!*\
  !*** ./node_modules/@disciple.tools/web-components/src/components/form/dt-toggle/dt-toggle.js ***!
  \************************************************************************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   DtToggle: () => (/* binding */ DtToggle)
/* harmony export */ });
/* harmony import */ var lit__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! lit */ "./node_modules/lit/index.js");
/* harmony import */ var _dt_form_base_js__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ../dt-form-base.js */ "./node_modules/@disciple.tools/web-components/src/components/form/dt-form-base.js");



class DtToggle extends _dt_form_base_js__WEBPACK_IMPORTED_MODULE_1__["default"] {
  static get styles() {
    return [
      ...super.styles,
      (0,lit__WEBPACK_IMPORTED_MODULE_0__.css)`
        :host {
          display: inline-block;
        }

        .Toggle {
          display: flex;
          flex-wrap: wrap;
          align-items: center;
          position: relative;
          margin-bottom: 1em;
          cursor: pointer;
          gap: 1ch;
        }

        button.Toggle {
          border: 0;
          padding: 0;
          background-color: transparent;
          font: inherit;
        }

        .Toggle__input {
          position: absolute;
          opacity: 0;
          width: 100%;
          height: 100%;
        }

        .Toggle__display {
          --offset: 0.25em;
          --diameter: 1.2em;

          display: inline-flex;
          align-items: center;
          justify-content: space-around;
          box-sizing: content-box;
          width: calc(var(--diameter) * 2 + var(--offset) * 2);
          height: calc(var(--diameter) + var(--offset) * 2);
          border: 0.1em solid rgb(0 0 0 / 0.2);
          position: relative;
          border-radius: 100vw;
          background-color: var(--dt-toggle-background-color-off, #ecf5fc);
          transition: 250ms;
        }

        .Toggle__display::before {
          content: '';
          z-index: 2;
          position: absolute;
          top: 50%;
          left: var(--offset);
          box-sizing: border-box;
          width: var(--diameter);
          height: var(--diameter);
          border: 0.1em solid rgb(0 0 0 / 0.2);
          border-radius: 50%;
          background-color: white;
          transform: translate(0, -50%);
          will-change: transform;
          transition: inherit;
        }

        .Toggle:focus .Toggle__display,
        .Toggle__input:focus + .Toggle__display {
          outline: 1px dotted #212121;
          outline: 1px auto -webkit-focus-ring-color;
          outline-offset: 2px;
        }

        .Toggle:focus,
        .Toggle:focus:not(:focus-visible) .Toggle__display,
        .Toggle__input:focus:not(:focus-visible) + .Toggle__display {
          outline: 0;
        }

        .Toggle[aria-pressed='true'] .Toggle__display,
        .Toggle__input:checked + .Toggle__display {
          background-color: var(--primary-color);
        }

        .Toggle[aria-pressed='true'] .Toggle__display::before,
        .Toggle__input:checked + .Toggle__display::before {
          transform: translate(100%, -50%);
        }

        .Toggle[disabled] .Toggle__display,
        .Toggle__input:disabled + .Toggle__display {
          opacity: 0.6;
          filter: grayscale(40%);
          cursor: not-allowed;
        }
        [dir='rtl'] .Toggle__display::before {
          left: auto;
          right: var(--offset);
        }

        [dir='rtl'] .Toggle[aria-pressed='true'] + .Toggle__display::before,
        [dir='rtl'] .Toggle__input:checked + .Toggle__display::before {
          transform: translate(-100%, -50%);
        }

        .Toggle__icon {
          display: inline-block;
          width: 1em;
          height: 1em;
          color: inherit;
          fill: currentcolor;
          vertical-align: middle;
          overflow: hidden;
        }

        .Toggle__icon--cross {
          color: var(--alert-color);
          font-size: 65%;
        }

        .Toggle__icon--checkmark {
          color: var(--success-color);
        }
      `,
    ];
  }

  static get properties() {
    return {
      ...super.properties,
      id: { type: String },
      checked: {
        type: Boolean,
        reflect: true,
      },
      onchange: { type: String },
      hideIcons: { type: Boolean, default: true },
    };
  }

  constructor() {
    super();
    this.hideIcons = false;
  }

  onChange(e) {
    const event = new CustomEvent('change', {
      detail: {
        field: this.name,
        oldValue: this.checked,
        newValue: e.target.checked,
      },
    });
    this.checked = e.target.checked;

    this._setFormValue(this.checked);

    this.dispatchEvent(event);
  }

  render() {
    // prettier-ignore
    const check = (0,lit__WEBPACK_IMPORTED_MODULE_0__.html)`<svg width="18" height="14" viewBox="0 0 18 14" fill="none" xmlns="http://www.w3.org/2000/svg" aria-hidden="true" focusable="false" class="Toggle__icon Toggle__icon--checkmark"><path d="M6.08471 10.6237L2.29164 6.83059L1 8.11313L6.08471 13.1978L17 2.28255L15.7175 1L6.08471 10.6237Z" fill="currentcolor" stroke="currentcolor" /></svg>`
    // prettier-ignore
    const cross = (0,lit__WEBPACK_IMPORTED_MODULE_0__.html)`<svg width="13" height="13" viewBox="0 0 13 13" fill="none" xmlns="http://www.w3.org/2000/svg" aria-hidden="true" focusable="false" class="Toggle__icon Toggle__icon--cross"><path d="M11.167 0L6.5 4.667L1.833 0L0 1.833L4.667 6.5L0 11.167L1.833 13L6.5 8.333L11.167 13L13 11.167L8.333 6.5L13 1.833L11.167 0Z" fill="currentcolor" /></svg>`
    return (0,lit__WEBPACK_IMPORTED_MODULE_0__.html)`
      <label class="Toggle" for="${this.id}" dir="${this.RTL ? 'rtl' : 'ltr'}">
        ${this.label}
        <input
          type="checkbox"
          name="${this.id}"
          id="${this.id}"
          class="Toggle__input"
          ?checked=${this.checked}
          @click=${this.onChange}
          ?disabled=${this.disabled}
        />
        <span class="Toggle__display" hidden>
          ${!this.hideIcons ? (0,lit__WEBPACK_IMPORTED_MODULE_0__.html)` ${check} ${cross} ` : (0,lit__WEBPACK_IMPORTED_MODULE_0__.html)``}
        </span>
      </label>
    `;
  }
}

window.customElements.define('dt-toggle', DtToggle);


/***/ }),

/***/ "./node_modules/@disciple.tools/web-components/src/components/form/mixins/hasOptionsList.js":
/*!**************************************************************************************************!*\
  !*** ./node_modules/@disciple.tools/web-components/src/components/form/mixins/hasOptionsList.js ***!
  \**************************************************************************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   HasOptionsList: () => (/* binding */ HasOptionsList)
/* harmony export */ });
/* harmony import */ var lit__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! lit */ "./node_modules/lit/index.js");
/* harmony import */ var _lit_localize__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! @lit/localize */ "./node_modules/@lit/localize/lit-localize.js");



const HasOptionsList = (superClass) => class extends superClass {
  constructor() {
    super();
    this.activeIndex = -1;
    this.filteredOptions = [];
    this.detectTap = false;
  }

  static get properties() {
    return {
      ...super.properties,
      value: {
        type: Array,
        reflect: true,
      },
      query: {
        type: String,
        state: true,
      },
      options: { type: Array },
      filteredOptions: { type: Array, state: true },
      open: {
        type: Boolean,
        state: true,
      },
      activeIndex: {
        type: Number,
        state: true,
      },
      containerHeight: {
        type: Number,
        state: true,
      },
      loading: { type: Boolean },
    };
  }

  willUpdate(props) {
    super.willUpdate(props);

    if (props) {
      // Set the containerHeight for dropdown positioning if it hasn't been set yet
      if (
        !this.containerHeight &&
        this.shadowRoot.children &&
        this.shadowRoot.children.length
      ) {
        const inputGroup = this.shadowRoot.querySelector('.input-group');
        if (inputGroup) {
          this.containerHeight = inputGroup.offsetHeight;
        }
      }
    }
  }

  updated() {
    this._scrollOptionListToActive();

    // set variable with width of container for truncating selected options via CSS
    const container = this.shadowRoot.querySelector('.input-group');
    const currentValue = container.style.getPropertyValue('--container-width');
    if (!currentValue && container.clientWidth > 0) {
      container.style.setProperty(
        '--container-width',
        `${container.clientWidth}px`
      );
    }
  }

  _select() { // eslint-disable-line class-methods-use-this
    console.error("Must implement `_select(value)` function");
  }

  /* Search Input Field Events */
  static _focusInput(e) {
    if (e.target !== e.currentTarget) return;

    e.target.getElementsByTagName('input')[0].focus();
  }

  _inputFocusIn(e) {
    if (
      !e.relatedTarget ||
      !['BUTTON', 'LI'].includes(e.relatedTarget.nodeName)
    ) {
      this.open = true;
      this.activeIndex = -1;
    }
  }

  _inputFocusOut(e) {
    // allow clicks on option list button to not close the option list
    // Safari actually passes the parent <li> as the relatedTarget
    if (
      !e.relatedTarget ||
      !['BUTTON', 'LI'].includes(e.relatedTarget.nodeName)
    ) {
      this.open = false;
    }
  }

  _inputKeyDown(e) {
    const keycode = e.keyCode || e.which;

    switch (keycode) {
      case 8: // backspace
        if (e.target.value === '') {
          this.value = this.value.slice(0, -1);
        } else {
          this.open = true;
        }
        break;
      case 38: // arrow up
        this.open = true;
        this._listHighlightPrevious();
        break;
      case 40: // arrow down
        this.open = true;
        this._listHighlightNext();
        break;
      case 9: // tab
        if (this.activeIndex < 0) {
          // if pressing tab while no option is selected,
          // close the list so you can go to next field
          this.open = false;
        } else {
          e.preventDefault();
        }
        this._keyboardSelectOption();
        break;
      case 13: // enter
        this._keyboardSelectOption();
        break;
      case 27: // escape
        this.open = false;
        this.activeIndex = -1;
        break;
      default:
        this.open = true;
        break;
    }
  }

  _inputKeyUp(e) {
    this.query = e.target.value;
  }

  /**
   * When navigating via keyboard, keep active element within visible area of option list
   * @private
   */
  _scrollOptionListToActive() {
    const optionList = this.shadowRoot.querySelector('.option-list');
    const activeEl = this.shadowRoot.querySelector('button.active');
    if (optionList && activeEl) {
      const elTop = activeEl.offsetTop;
      const elBottom = activeEl.offsetTop + activeEl.clientHeight;
      const listTop = optionList.scrollTop;
      const listBottom = optionList.scrollTop + optionList.clientHeight;
      if (elBottom > listBottom) {
        // active element below visible area. scroll down
        optionList.scrollTo({
          top: elBottom - optionList.clientHeight,
          behavior: 'smooth',
        });
      } else if (elTop < listTop) {
        // active element above visible area. scroll up
        optionList.scrollTo({ top: elTop, behavior: 'smooth' });
      }
    }
  }

  /* Option List Events */
  _touchStart(e) {
    if (e.target) {
      this.detectTap = false;
    }
  }

  _touchMove(e) {
    if (e.target) {
      this.detectTap = true;
    }
  }

  _touchEnd(e) {
    if (!this.detectTap) {
      if (e.target && e.target.value) {
        this._clickOption(e);
      }
      this.detectTap = false;
    }
  }

  _keyboardSelectOption() {
    if (this.activeIndex > -1) {
      if (this.activeIndex + 1 > this.filteredOptions.length) {
        this._select(this.query);
      } else {
        this._select(this.filteredOptions[this.activeIndex].id);
      }
      this._clearSearch();
    }
  }

  _clickOption(e) {
    if (e.target && e.target.value) {
      this._select(e.target.value);
      this._clearSearch();
    }
  }

  _clickAddNew(e) {
    if (e.target) {
      this._select(e.target.dataset?.label);
      // clear search field if clicked with mouse, since field will lose focus
      this._clearSearch();
    }
  }

  _clearSearch()  {
    const input = this.shadowRoot.querySelector('input');
      if (input) {
        input.value = '';
      }
  }

  /* Option List Navigation */
  _listHighlightNext() {
    if (this.allowAdd) {
      this.activeIndex = Math.min(
        this.filteredOptions.length, // allow 1 more than the list length
        this.activeIndex + 1
      );
    } else {
      this.activeIndex = Math.min(
        this.filteredOptions.length - 1,
        this.activeIndex + 1
      );
    }
  }

  _listHighlightPrevious() {
    this.activeIndex = Math.max(0, this.activeIndex - 1);
  }

  /* Rendering */
  _renderOption(opt, idx) {
    return (0,lit__WEBPACK_IMPORTED_MODULE_0__.html)`
      <li tabindex="-1">
        <button
          value="${opt.id}"
          type="button"
          data-label="${opt.label}"
          @click="${this._clickOption}"
          @touchstart="${this._touchStart}"
          @touchmove="${this._touchMove}"
          @touchend="${this._touchEnd}"
          tabindex="-1"
          class="${this.activeIndex > -1 && this.activeIndex === idx
      ? 'active'
      : ''}"
        >
          ${opt.label}
        </button>
      </li>
    `;
  }

  _baseRenderOptions() {
    if (!this.filteredOptions.length) {
      if (this.loading) {
        return (0,lit__WEBPACK_IMPORTED_MODULE_0__.html)`<li><div>${(0,_lit_localize__WEBPACK_IMPORTED_MODULE_1__.msg)('Loading options...')}</div></li>`;
      }
      return (0,lit__WEBPACK_IMPORTED_MODULE_0__.html)`<li><div>${(0,_lit_localize__WEBPACK_IMPORTED_MODULE_1__.msg)('No Data Available')}</div></li>`;
    }

    return this.filteredOptions.map((opt, idx) => this._renderOption(opt, idx));
  }

  _renderOptions() {
    let optionsMarkup = this._baseRenderOptions();

    if (this.allowAdd && this.query) {
      if (!Array.isArray(optionsMarkup)) {
        optionsMarkup = [optionsMarkup];
      }
      optionsMarkup.push((0,lit__WEBPACK_IMPORTED_MODULE_0__.html)`<li tabindex="-1">
        <button
          data-label="${this.query}"
          @click="${this._clickAddNew}"
          @touchstart="${this._touchStart}"
          @touchmove="${this._touchMove}"
          @touchend="${this._touchEnd}"
          class="${this.activeIndex > -1 &&
      this.activeIndex >= this.filteredOptions.length
        ? 'active'
        : ''}"
        >
          ${(0,_lit_localize__WEBPACK_IMPORTED_MODULE_1__.msg)('Add')} "${this.query}"
        </button>
      </li>`);
    }
    return optionsMarkup;
  }
}


/***/ }),

/***/ "./node_modules/@disciple.tools/web-components/src/components/icons/dt-checkmark.js":
/*!******************************************************************************************!*\
  !*** ./node_modules/@disciple.tools/web-components/src/components/icons/dt-checkmark.js ***!
  \******************************************************************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   DtCheckmark: () => (/* binding */ DtCheckmark)
/* harmony export */ });
/* harmony import */ var lit__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! lit */ "./node_modules/lit/index.js");


class DtCheckmark extends lit__WEBPACK_IMPORTED_MODULE_0__.LitElement {
  static get styles() {
    return (0,lit__WEBPACK_IMPORTED_MODULE_0__.css)`
      @keyframes fadeOut {
        0% {
          opacity: 1;
        }
        75% {
          opacity: 1;
        }
        100% {
          opacity: 0;
        }
      }
      :host {
        margin-top: -0.25rem;
      }
      :host::before {
        content: '';
        transform: rotate(45deg);
        height: 1rem;
        width: 0.5rem;
        opacity: 0;
        color: inherit;
        border-bottom: var(--dt-checkmark-width) solid currentcolor;
        border-right: var(--dt-checkmark-width) solid currentcolor;
        animation: fadeOut 4s;
      }
    `;
  }
}

window.customElements.define('dt-checkmark', DtCheckmark);


/***/ }),

/***/ "./node_modules/@disciple.tools/web-components/src/components/icons/dt-exclamation-circle.js":
/*!***************************************************************************************************!*\
  !*** ./node_modules/@disciple.tools/web-components/src/components/icons/dt-exclamation-circle.js ***!
  \***************************************************************************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   DtExclamationCircle: () => (/* binding */ DtExclamationCircle)
/* harmony export */ });
/* harmony import */ var lit__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! lit */ "./node_modules/lit/index.js");


class DtExclamationCircle extends lit__WEBPACK_IMPORTED_MODULE_0__.LitElement {
  static get styles() {
    return (0,lit__WEBPACK_IMPORTED_MODULE_0__.css)`
      svg use {
        fill: currentcolor;
      }
    `;
  }

  render() {
    return (0,lit__WEBPACK_IMPORTED_MODULE_0__.html)`
      <svg
        width="24"
        height="24"
        viewBox="0 0 24 24"
        version="1.1"
        xmlns="http://www.w3.org/2000/svg"
        xmlns:xlink="http://www.w3.org/1999/xlink"
      >
        <g id="Canvas" transform="translate(1845 -2441)">
          <g id="alert-circle-exc">
            <g id="Group">
              <g id="Vector">
                <use
                  xlink:href="#path0_fill"
                  transform="translate(-1845 2441)"
                  fill="#000000"
                />
              </g>
            </g>
          </g>
        </g>
        <defs>
          <path
            id="path0_fill"
            d="M 12 0C 5.383 0 0 5.383 0 12C 0 18.617 5.383 24 12 24C 18.617 24 24 18.617 24 12C 24 5.383 18.617 0 12 0ZM 13.645 5L 13 14L 11 14L 10.392 5L 13.645 5ZM 12 20C 10.895 20 10 19.105 10 18C 10 16.895 10.895 16 12 16C 13.105 16 14 16.895 14 18C 14 19.105 13.105 20 12 20Z"
          />
        </defs>
      </svg>
    `;
  }
}

window.customElements.define('dt-exclamation-circle', DtExclamationCircle);


/***/ }),

/***/ "./node_modules/@disciple.tools/web-components/src/components/icons/dt-icon.js":
/*!*************************************************************************************!*\
  !*** ./node_modules/@disciple.tools/web-components/src/components/icons/dt-icon.js ***!
  \*************************************************************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   DtIcon: () => (/* binding */ DtIcon)
/* harmony export */ });
/* harmony import */ var lit__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! lit */ "./node_modules/lit/index.js");
/* harmony import */ var _dt_base_js__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ../dt-base.js */ "./node_modules/@disciple.tools/web-components/src/components/dt-base.js");
/* harmony import */ var iconify_icon__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! iconify-icon */ "./node_modules/iconify-icon/dist/iconify-icon.mjs");




class DtIcon extends _dt_base_js__WEBPACK_IMPORTED_MODULE_1__["default"] {
  static get styles() {
    return (0,lit__WEBPACK_IMPORTED_MODULE_0__.css)`
      :root {
        font-size: inherit;
        color: inherit;
        display: inline-flex;
        width: fit-content;
        height: fit-content;
        position: relative;
      }
      .tooltip {
        position: absolute;
        right: 0px;
        top: 100%;
        min-width: 9rem;
        border: solid 1px currentcolor;
        background-color: var(--dt-form-background-color, var(--surface-1));
        padding: .25rem;
        border-radius: .25rem;
        text-align: end;
        z-index: 1;
        display:block;
      }
      .tooltip:before {
        position: absolute;
        right: .7rem;
        top: -.55rem;
        content: " ";
        border-width: .25rem;
        border-style: solid;
        border-color: transparent transparent currentcolor transparent;
      }
      .tooltip[hidden] {
        display: none;
      }
    `;
  }

  static get properties() {
    return {
      ...super.properties,
      icon: { type: String },
      tooltip: { type: String },
      tooltip_open: { type: Boolean },
      size: { type: String },
    };
  }

  _showTooltip() {
    if (this.tooltip_open){
      this.tooltip_open = false;
    } else {
      this.tooltip_open = true;
    }
  }

  render() {
    const tooltip = this.tooltip ? (0,lit__WEBPACK_IMPORTED_MODULE_0__.html)`<div class="tooltip" ?hidden=${this.tooltip_open}>${this.tooltip}</div>` : null;
    return (0,lit__WEBPACK_IMPORTED_MODULE_0__.html)`
      <iconify-icon icon=${this.icon} width="${this.size}" @click=${this._showTooltip}></iconify-icon>
      ${tooltip}
    `;
  }
}

window.customElements.define('dt-icon', DtIcon);


/***/ }),

/***/ "./node_modules/@disciple.tools/web-components/src/components/icons/dt-spinner.js":
/*!****************************************************************************************!*\
  !*** ./node_modules/@disciple.tools/web-components/src/components/icons/dt-spinner.js ***!
  \****************************************************************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   DtSpinner: () => (/* binding */ DtSpinner)
/* harmony export */ });
/* harmony import */ var lit__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! lit */ "./node_modules/lit/index.js");


class DtSpinner extends lit__WEBPACK_IMPORTED_MODULE_0__.LitElement {
  static get styles() {
    return (0,lit__WEBPACK_IMPORTED_MODULE_0__.css)`
      @keyframes spin {
        0% {
          transform: rotate(0deg);
        }

        100% {
          transform: rotate(360deg);
        }
      }
      :host::before {
        content: '';
        animation: spin 1s linear infinite;
        border: 0.25rem solid var(--dt-spinner-color-1, #919191);
        border-radius: 50%;
        border-top-color: var(--dt-spinner-color-2, #000);
        display: inline-block;
        height: 1rem;
        width: 1rem;
      }
    `;
  }
}

window.customElements.define('dt-spinner', DtSpinner);


/***/ }),

/***/ "./node_modules/@disciple.tools/web-components/src/components/icons/dt-star.js":
/*!*************************************************************************************!*\
  !*** ./node_modules/@disciple.tools/web-components/src/components/icons/dt-star.js ***!
  \*************************************************************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   DtStar: () => (/* binding */ DtStar)
/* harmony export */ });
/* harmony import */ var lit__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! lit */ "./node_modules/lit/index.js");


class DtStar extends lit__WEBPACK_IMPORTED_MODULE_0__.LitElement {
  static get styles() {
    return (0,lit__WEBPACK_IMPORTED_MODULE_0__.css)`
      :host {
        fill: var(--star-unselected-color, #c7c6c1);
      }
      :host([selected]) {
        fill: var(--star-unselected-color, hsl(45, 100%, 51%));
      }
    `;
  }

  static get properties() {
    return {
      postID: { type: Number },
      selected: { type: Boolean, reflect: true },
    };
  }

  _onclick() {
    this.selected = !this.selected;

    const event = new CustomEvent('change', {
      detail: {
        postID: this.postID,
        favorited: this.selected,
      },
    });

    this.dispatchEvent(event);
  }

  _keyUp(e) {
    // If key pressed was enter, simulate a click
    const keycode = e.keyCode || e.which;

    if (keycode === 13) {
      // Enter
      this._onclick();
    }
  }

  render() {
    return (0,lit__WEBPACK_IMPORTED_MODULE_0__.html)`
      <svg
        @click="${this._onclick}"
        @keyup="${this._keyUp}"
        tabindex="0"
        id="star"
        height="32"
        viewBox="0 0 32 32"
        width="32"
        xmlns="http://www.w3.org/2000/svg"
      >
        <path
          d="M 31.916 12.092 C 31.706 11.417 31.131 10.937 30.451 10.873 L 21.215 9.996 L 17.564 1.077 C 17.295 0.423 16.681 0 16 0 C 15.318 0 14.706 0.423 14.435 1.079 L 10.784 9.996 L 1.546 10.873 C 0.868 10.937 0.295 11.417 0.084 12.092 C -0.126 12.769 0.068 13.51 0.581 13.978 L 7.563 20.367 L 5.503 29.83 C 5.354 30.524 5.613 31.245 6.165 31.662 C 6.462 31.886 6.811 32 7.161 32 C 7.463 32 7.764 31.915 8.032 31.747 L 16 26.778 L 23.963 31.747 C 24.546 32.113 25.281 32.08 25.834 31.662 C 26.386 31.243 26.645 30.524 26.494 29.83 L 24.436 20.367 L 31.417 13.978 C 31.931 13.51 32.127 12.769 31.916 12.092 Z M 31.916 12.092"
        />
      </svg>
    `;
  }
}

window.customElements.define('dt-star', DtStar);


/***/ }),

/***/ "./node_modules/@disciple.tools/web-components/src/components/layout/dt-alert/dt-alert.js":
/*!************************************************************************************************!*\
  !*** ./node_modules/@disciple.tools/web-components/src/components/layout/dt-alert/dt-alert.js ***!
  \************************************************************************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   DtAlert: () => (/* binding */ DtAlert)
/* harmony export */ });
/* harmony import */ var lit__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! lit */ "./node_modules/lit/index.js");
/* harmony import */ var lit_directives_class_map_js__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! lit/directives/class-map.js */ "./node_modules/lit/directives/class-map.js");
/* harmony import */ var _dt_base_js__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! ../../dt-base.js */ "./node_modules/@disciple.tools/web-components/src/components/dt-base.js");

// import { msg } from '@lit/localize';



class DtAlert extends _dt_base_js__WEBPACK_IMPORTED_MODULE_2__["default"] {
  static get styles() {
    return (0,lit__WEBPACK_IMPORTED_MODULE_0__.css)`
      :host {
        display: block;
      }

      .dt-alert {
        padding: var(--dt-alert-padding, 10px);
        font-family: var(--dt-alert-font-family);
        font-size: var(--dt-alert-font-size, 14px);
        font-weight: var(--dt-alert-font-weight, 700);
        background-color: var(
          --dt-alert-context-background-color,
          var(--dt-alert-background-color)
        );
        border: var(--dt-alert-border-width, 1px) solid
          var(--dt-alert-context-border-color, var(--dt-alert-border-color));
        border-radius: var(--dt-alert-border-radius, 10px);
        box-shadow: var(--dt-alert-box-shadow, 0 2px 4px rgb(0 0 0 / 25%));
        color: var(--dt-alert-context-text-color, var(--dt-alert-text-color));
        text-rendering: optimizeLegibility;
        display: flex;
        gap: var(--dt-alert-gap, 10px);
        justify-content: space-between;
        align-content: center;
        align-items: center;
        white-space: initial;
      }

      .dt-alert.dt-alert--outline {
        background-color: transparent;
        color: var(--dt-alert-context-text-color, var(--text-color-inverse));
      }

      .dt-alert--primary:not(.dt-alert--outline) {
        --dt-alert-context-border-color: var(--primary-color);
        --dt-alert-context-background-color: var(--primary-color);
        --dt-alert-context-text-color: var(--dt-alert-text-color-light);
      }

      .dt-alert--alert:not(.dt-alert--outline) {
        --dt-alert-context-border-color: var(--alert-color);
        --dt-alert-context-background-color: var(--alert-color);
        --dt-alert-context-text-color: var(--dt-alert-text-color-light);
      }

      .dt-alert--caution:not(.dt-alert--outline) {
        --dt-alert-context-border-color: var(--caution-color);
        --dt-alert-context-background-color: var(--caution-color);
        --dt-alert-context-text-color: var(--dt-alert-text-color-dark);
      }

      .dt-alert--success:not(.dt-alert--outline) {
        --dt-alert-context-border-color: var(--success-color);
        --dt-alert-context-background-color: var(--success-color);
        --dt-alert-context-text-color: var(--dt-alert-text-color-light);
      }

      .dt-alert--inactive:not(.dt-alert--outline) {
        --dt-alert-context-border-color: var(--inactive-color);
        --dt-alert-context-background-color: var(--inactive-color);
        --dt-alert-context-text-color: var(--dt-alert-text-color-light);
      }

      .dt-alert--disabled:not(.dt-alert--outline) {
        --dt-alert-context-border-color: var(--disabled-color);
        --dt-alert-context-background-color: var(--disabled-color);
        --dt-alert-context-text-color: var(--dt-alert-text-color-dark);
      }

      .dt-alert--primary.dt-alert--outline {
        --dt-alert-context-border-color: var(--primary-color);
        --dt-alert-context-text-color: var(--primary-color);
      }

      .dt-alert--alert.dt-alert--outline {
        --dt-alert-context-border-color: var(--alert-color);
        --dt-alert-context-text-color: var(--alert-color);
      }

      .dt-alert--caution.dt-alert--outline {
        --dt-alert-context-border-color: var(--caution-color);
        --dt-alert-context-text-color: var(--caution-color);
      }

      .dt-alert--success.dt-alert--outline {
        --dt-alert-context-border-color: var(--success-color);
        --dt-alert-context-text-color: var(--success-color);
      }

      .dt-alert--inactive.dt-alert--outline {
        --dt-alert-context-border-color: var(--inactive-color);
      }

      .dt-alert--disabled.dt-alert--outline {
        --dt-alert-context-border-color: var(--disabled-color);
      }

      button.toggle {
        margin-inline-end: 0;
        margin-inline-start: auto;
        background: none;
        border: none;
        color: inherit;
        cursor: pointer;
        display: flex;
        align-items: center;
      }
    `;
  }

  static get properties() {
    return {
      context: { type: String },
      dismissable: { type: Boolean },
      timeout: { type: Number },
      hide: { type: Boolean },
      outline: { type: Boolean },
    };
  }

  get classes() {
    const classes = {
      'dt-alert': true,
      'dt-alert--outline': this.outline,
    };
    const contextClass = `dt-alert--${this.context}`;
    classes[contextClass] = true;
    return classes;
  }

  constructor() {
    super();

    this.context = 'default';
  }

  connectedCallback() {
    super.connectedCallback();
    if (this.timeout) {
      setTimeout(() => {
        this._dismiss();
      }, this.timeout);
    }
  }

  _dismiss() {
    this.hide = true;
  }

  render() {
    if (this.hide) {
      return (0,lit__WEBPACK_IMPORTED_MODULE_0__.html)``;
    }

    // prettier-ignore
    const svg = (0,lit__WEBPACK_IMPORTED_MODULE_0__.html)`
      <svg viewPort="0 0 12 12" version="1.1" width='12' height='12'>
           xmlns="http://www.w3.org/2000/svg">
        <line x1="1" y1="11"
              x2="11" y2="1"
              stroke="currentColor"
              stroke-width="2"/>
        <line x1="1" y1="1"
              x2="11" y2="11"
              stroke="currentColor"
              stroke-width="2"/>
      </svg>
    `;

    return (0,lit__WEBPACK_IMPORTED_MODULE_0__.html)`
      <div role="alert" class=${(0,lit_directives_class_map_js__WEBPACK_IMPORTED_MODULE_1__.classMap)(this.classes)}>
        <div>
          <slot></slot>
        </div>
        ${this.dismissable
          ? (0,lit__WEBPACK_IMPORTED_MODULE_0__.html)`
              <button @click="${this._dismiss}" class="toggle">${svg}</button>
            `
          : null}
      </div>
    `;
  }
}

window.customElements.define('dt-alert', DtAlert);


/***/ }),

/***/ "./node_modules/@disciple.tools/web-components/src/components/layout/dt-list/dt-list.js":
/*!**********************************************************************************************!*\
  !*** ./node_modules/@disciple.tools/web-components/src/components/layout/dt-list/dt-list.js ***!
  \**********************************************************************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   DtList: () => (/* binding */ DtList)
/* harmony export */ });
/* harmony import */ var lit__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! lit */ "./node_modules/lit/index.js");
/* harmony import */ var _lit_localize__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! @lit/localize */ "./node_modules/@lit/localize/lit-localize.js");
/* harmony import */ var lit_directives_map_js__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! lit/directives/map.js */ "./node_modules/lit/directives/map.js");
/* harmony import */ var lit_directives_repeat_js__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(/*! lit/directives/repeat.js */ "./node_modules/lit/directives/repeat.js");
/* harmony import */ var lit_directives_if_defined_js__WEBPACK_IMPORTED_MODULE_4__ = __webpack_require__(/*! lit/directives/if-defined.js */ "./node_modules/lit/directives/if-defined.js");
/* harmony import */ var lit_directives_class_map_js__WEBPACK_IMPORTED_MODULE_5__ = __webpack_require__(/*! lit/directives/class-map.js */ "./node_modules/lit/directives/class-map.js");
/* harmony import */ var _dt_base_js__WEBPACK_IMPORTED_MODULE_6__ = __webpack_require__(/*! ../../dt-base.js */ "./node_modules/@disciple.tools/web-components/src/components/dt-base.js");
/* harmony import */ var _services_apiService_js__WEBPACK_IMPORTED_MODULE_7__ = __webpack_require__(/*! ../../../services/apiService.js */ "./node_modules/@disciple.tools/web-components/src/services/apiService.js");
/* harmony import */ var _icons_dt_star_js__WEBPACK_IMPORTED_MODULE_8__ = __webpack_require__(/*! ../../icons/dt-star.js */ "./node_modules/@disciple.tools/web-components/src/components/icons/dt-star.js");










class DtList extends _dt_base_js__WEBPACK_IMPORTED_MODULE_6__["default"] {
  static get styles() {
    return (0,lit__WEBPACK_IMPORTED_MODULE_0__.css)`
      :host {
        --number-of-columns: 7;
        font-family: var(--dt-list-font-family, var(--font-family));
        font-size: var(--dt-list-font-size, 15px);
        font-weight: var(--dt-list-font-weight, 300);
        line-height: var(--dt-list-line-height, 1.5);
        overflow: hidden;
        text-overflow: ellipsis;
        white-space: nowrap;
      }

      .section {
        container-type: inline-size;
        background-color: var(--dt-list-background-color, #fefefe);
        border: 1px solid var(--dt-list-border-color, #f1f1f1);
        border-radius: var(--dt-list-border-radius, 10px);
        box-shadow: var(--dt-list-box-shadow, 0 2px 4px rgb(0 0 0 / 25%));
        padding: var(--dt-list-section-padding, 1rem);
      }

      .header {
        display: flex;
        justify-content: flex-start;
        align-items: baseline;
        gap: var(--dt-list-header-gap, 1.5em);
        flex-wrap: wrap;
      }

      .section-header {
        color: var(--dt-list-header-color, var(--primary-color));
        font-size: 1.5rem;
        display: inline-block;
        text-transform: capitalize;
      }

      .toggleButton {
        color: var(--dt-list-header-color, var(--primary-color));
        font-size: 1rem;
        background: transparent;
        border: var(--dt-list-toggleButton, 0.1em solid rgb(0 0 0 / 0.2));
        border-radius: 0.25em;
        padding: 0.25em 0.5em;
        cursor: pointer;
      }

      .toggleButton svg {
        height: 0.9rem;
        transform: translateY(-2px);
        vertical-align: bottom;
        width: 1rem;
        fill: var(--dt-list-header-color, var(--primary-color));
        stroke: var(--dt-list-header-color, var(--primary-color));
      }

      .list_action_section {
        background-color: var(
          --dt-list-action-section-background-color,
          #ecf5fc
        );
        border-radius: var(--dt-list-border-radius, 10px);
        margin: var(--dt-list-action-section-margin, 30px 0);
        padding: var(--dt-list-action-section-padding, 20px);
      }
      .list_action_section_header {
        display: flex;
        flex-direction: row;
        justify-content: space-between;
      }
      .close-button {
        outline: none;
        font-size: 2.5em;
        line-height: 1;
        color: var(--dt-list-action-close-button, var(--inactive-color));
        background: transparent;
        border: none;
        cursor: pointer;
      }
      .fieldsList {
        list-style-type: none;
        column-count: 1;
      }

      .list-field-picker-item {
        list-style-type: none;
      }

      .list-field-picker-item input {
        margin: 1rem;
      }

      .list-field-picker-item .dt-icon {
        height: var(--dt-list-field-picker-icon-size, 1rem);
        width: var(--dt-list-field-picker-icon-size, 1rem);
      }

      table {
        display: grid;
        border: 1px solid var(--dt-list-border-color, #f1f1f1);
        border-top: 0;
        border-collapse: collapse;
        min-width: 100%;
        grid-template-columns: minmax(32px, 0.1fr) minmax(32px, 0.1fr) minmax(
            50px,
            0.8fr
          );
      }

      table td:last-child {
        border-bottom: 1px solid var(--dt-list-border-color, #f1f1f1);
        padding-bottom: 2rem;
      }

      thead,
      tbody,
      tr {
        display: contents;
      }

      tr {
        cursor: pointer;
      }

      tr:nth-child(2n + 1) {
        background: #f1f1f1;
      }

      tr:hover {
        background-color: var(--dt-list-hover-background-color, #ecf5fc);
      }

      tr a {
        color: var(--dt-list-link-color, var(--primary-color));
      }

      th {
        display: none;
      }

      .column-name {
        pointer-events: none;
      }
      #sort-arrows {
        grid-template-columns: 4fr 1fr;
        display: flex;
        flex-direction: column;
        height: 1.5em;
        justify-content: space-evenly;
      }
      th.all span.sort-arrow-up {
        border-color: transparent transparent
          var(--dt-list-sort-arrow-color, #808080) transparent;
        border-style: solid;
        border-width: 0 0.5em 0.5em 0.5em;
      }

      th.all span.sort-arrow-down {
        content: '';
        border-color: var(--dt-list-sort-arrow-color, #808080) transparent
          transparent;
        border-style: solid;
        border-width: 0.5em 0.5em 0;
      }

      th.all span.sort-arrow-up.sortedBy {
        border-color: transparent transparent
          var(--dt-list-sort-arrow-color-highlight, #999999) transparent;
      }

      th.all span.sort-arrow-down.sortedBy {
        border-color: var(--dt-list-sort-arrow-color-highlight, #999999)
          transparent transparent;
      }

      td {
        border: 0;
        grid-column: 1 / span 3;
        padding-inline-start: 1em;
      }

      td::before {
        content: attr(title) ': ';
        padding-inline-end: 1em;
      }

      td.no-title {
        grid-column: auto;
      }

      td.line-count {
        padding-block-start: 0.8em;
        padding-inline-start: 1em;
      }

      td.bulk_edit_checkbox {
        grid-column: 1 / auto;
      }

      td.no-title::before {
        content: '';
        padding-inline-end: 0.25em;
      }

      th.bulk_edit_checkbox,
      td.bulk_edit_checkbox {
        grid-column: none;
      }

      .bulk_edit_checkbox input {
        display: none;
      }

      .bulk_editing th.bulk_edit_checkbox,
      .bulk_editing td.bulk_edit_checkbox {
        grid-column: 1 / auto;
      }

      .bulk_editing .bulk_edit_checkbox input {
        display: initial;
      }

      ul {
        margin: 0;
        padding: 0;
      }

      ul li {
        list-style-type: none;
      }

      input[type='checkbox'] {
        margin: 1rem;
      }
      @container (min-width: 650px) {
        .fieldsList {
          column-count: 2;
        }
        table {
          grid-template-columns:
            minmax(32px, 0.5fr)
            minmax(32px, 0.5fr)
            minmax(32px, 0.5fr)
            repeat(var(--number-of-columns, 7), minmax(50px, 1fr));
        }

        th {
          position: sticky;
          top: 0;
          background: var(
            --dt-list-header-background-color,
            var(--dt-tile-background-color, #fefefe)
          );
          text-align: start;
          justify-self: start;
          font-weight: normal;
          font-size: 1.1rem;
          color: var(--dt-list-header-color, #0a0a0a);
          white-space: pre-wrap;
          display: grid;
          place-items: center;
          grid-template-columns: 2fr 1fr;
        }

        th:last-child {
          border: 0;
        }
        td {
          display: flex;
          align-items: center;
          overflow: hidden;
          text-overflow: ellipsis;
          white-space: nowrap;
          padding-top: 0.5rem;
          padding-bottom: 0.5rem;
          padding-inline-start: 0;
          color: var(--text-color-mid);
          border-bottom: 1px solid var(--dt-list-border-color, #f1f1f1);
          grid-column: auto;
        }
        td::before {
          content: '';
          display: none;
        }
      }
      @container (min-width: 950px) {
        .fieldsList {
          column-count: 3;
        }
      }
      @container (min-width: 1500px) {
        .fieldsList {
          column-count: 4;
        }
      }
    `;
  }

  static get properties() {
    return {
      postType: { type: String },
      postTypeLabel: { type: String },
      postTypeSettings: { type: Object, attribute: true },
      posts: { type: Array },
      total: { type: Number },
      columns: { type: Array },
      sortedBy: { type: String },
      loading: { type: Boolean, default: true },
      offset: { type: Number },
      showArchived: { type: Boolean, default: false },
      showFieldsSelector: { type: Boolean, default: false },
      showBulkEditSelector: { type: Boolean, default: false },
      nonce: { type: String },
    };
  }

  constructor() {
    super();
    this.sortedBy = 'name';
  }

  firstUpdated() {
    if (this.nonce && !this.api) {
      this.api = new _services_apiService_js__WEBPACK_IMPORTED_MODULE_7__["default"](this.nonce);
    }
  }

  async _getPosts(offset = 0, sortBy = 'name', sortOrder = 'desc') {
    this.loading = true;
    this.filteredOptions = [];
    const sort = `${sortOrder === 'desc' ? '-' : ''}${sortBy}`;
    const URLParams = encodeURI(
      `?offset=${offset}&sortBy=${sort}&offset=${offset}${this.columns
        .map(column => `&fields_to_return=${column}`)
        .join('')}`
    );
    const response = await this.api.makeRequestOnPosts(
      'GET',
      `${this.postType}${URLParams}`
    );

    return response;
  }

  _headerClick(e) {
    const column = e.target.dataset.id;
    this._getPosts(this.offset ? this.offset : 0, column).then(response => {
      this.posts = response;
      this.sortedBy = column;
    });
  }

  _bulkEdit() {
    this.showBulkEditSelector = !this.showBulkEditSelector;
  }

  _fieldsEdit() {
    this.showFieldsSelector = !this.showFieldsSelector;
  }

  _toggleShowArchived() {
    this.showArchived = !this.showArchived;
  }

  _sortArrowsClass(column) {
    return this.sortedBy === column ? 'sortedBy' : '';
  }

  _sortArrowsToggle(column) {
    if (this.sortedBy !== `-${column}`) {
      return `-${column}`;
    }
    return column;
  }

  _headerTemplate() {
    // const classes = {
    //   sortedBy: this.sortedBy,
    // };
    return (0,lit__WEBPACK_IMPORTED_MODULE_0__.html)`
      <thead>
        <tr>
          <th id="bulk_edit_master" class="bulk_edit_checkbox">
            <input
              type="checkbox"
              name="bulk_send_app_id"
              value=""
              id="bulk_edit_master_checkbox"
            />
          </th>

          <th></th>

          ${(0,lit_directives_map_js__WEBPACK_IMPORTED_MODULE_2__.map)(
            this.columns,
            column =>
              (0,lit__WEBPACK_IMPORTED_MODULE_0__.html)`<th
                class="all"
                data-id="${this._sortArrowsToggle(column)}"
                @click=${this._headerClick}
              >
                <span class="column-name"
                  >${this.postTypeSettings[column].name}</span
                >
                <span id="sort-arrows">
                  <span
                    class="sort-arrow-up ${this._sortArrowsClass(`-${column}`)}"
                    data-id="-${column}"
                  ></span>
                  <span
                    class="sort-arrow-down ${this._sortArrowsClass(column)}"
                    data-id="${column}"
                  ></span>
                </span>
              </th>`
          )}
        </tr>
      </thead>
    `;
  }

  _rowTemplate() {
    return (0,lit_directives_map_js__WEBPACK_IMPORTED_MODULE_2__.map)(this.posts, (post, i) => {
      if (
        this.showArchived ||
        (!this.showArchived && post.overall_status.key !== 'closed')
      ) {
        return (0,lit__WEBPACK_IMPORTED_MODULE_0__.html)`
          <tr class="dnd-moved" data-link="${this.posts.permalink}">
            <td class="bulk_edit_checkbox no-title">
              <input type="checkbox" name="bulk_edit_id" .value="${post.ID}" />
            </td>
            <td class="no-title line-count">${i + 1}.</td>

            ${this._cellTemplate(post)}
          </tr>
        `;
      }
      return null;
    });
  }

  _cellTemplate(post) {
    return (0,lit_directives_map_js__WEBPACK_IMPORTED_MODULE_2__.map)(this.columns, column => {
      if (
        ['text', 'textarea', 'number'].includes(
          this.postTypeSettings[column].type
        )
      ) {
        return (0,lit__WEBPACK_IMPORTED_MODULE_0__.html)` <td
          dir="auto"
          title="${this.postTypeSettings[column].name}"
        >
          <a href="${post[column]}" title="test">${post[column]}</a>
        </td>`;
      }
      if (this.postTypeSettings[column].type === 'date') {
        // TODO: format date
        return (0,lit__WEBPACK_IMPORTED_MODULE_0__.html)` <td
          dir="auto"
          title="${this.postTypeSettings[column].name}"
        >
          ${post[column].formatted}
        </td>`;
      }
      if (
        this.postTypeSettings[column].type === 'user_select' &&
        post[column] &&
        post[column].display
      ) {
        return (0,lit__WEBPACK_IMPORTED_MODULE_0__.html)` <td
          dir="auto"
          title="${this.postTypeSettings[column].name}"
        >
          ${(0,lit_directives_if_defined_js__WEBPACK_IMPORTED_MODULE_4__.ifDefined)(post[column].display)}
        </td>`;
      }
      if (
        this.postTypeSettings[column].type === 'key_select' &&
        post[column] &&
        (post[column].label || post[column].name)
      ) {
        return (0,lit__WEBPACK_IMPORTED_MODULE_0__.html)` <td
          dir="auto"
          title="${this.postTypeSettings[column].name}"
        >
          ${post[column].label || post[column].name}
        </td>`;
      }
      if (
        this.postTypeSettings[column].type === 'multi_select' ||
        (this.postTypeSettings[column].type === 'tags' &&
          post[column] &&
          post[column].length > 0)
      ) {
        return (0,lit__WEBPACK_IMPORTED_MODULE_0__.html)` <td
          dir="auto"
          title="${this.postTypeSettings[column].name}"
        >
          <ul>
            ${(0,lit_directives_map_js__WEBPACK_IMPORTED_MODULE_2__.map)(
              post[column],
              value =>
                (0,lit__WEBPACK_IMPORTED_MODULE_0__.html)`<li>
                  ${this.postTypeSettings[column].default[value].label}
                </li>`
            )}
          </ul>
        </td>`;
      }
      if (
        this.postTypeSettings[column].type === 'location' ||
        this.postTypeSettings[column].type === 'location_meta'
      ) {
        return (0,lit__WEBPACK_IMPORTED_MODULE_0__.html)` <td
          dir="auto"
          title="${this.postTypeSettings[column].name}"
        >
          ${(0,lit_directives_if_defined_js__WEBPACK_IMPORTED_MODULE_4__.ifDefined)(post[column].label)}
        </td>`;
      }
      if (this.postTypeSettings[column].type === 'communication_channel') {
        return (0,lit__WEBPACK_IMPORTED_MODULE_0__.html)` <td
          dir="auto"
          title="${this.postTypeSettings[column].name}"
        >
          ${(0,lit_directives_if_defined_js__WEBPACK_IMPORTED_MODULE_4__.ifDefined)(post[column].value)}
        </td>`;
      }
      if (this.postTypeSettings[column].type === 'connection') {
        return (0,lit__WEBPACK_IMPORTED_MODULE_0__.html)` <td
          dir="auto"
          title="${this.postTypeSettings[column].name}"
        >
          <!-- TODO: look at this, it doesn't match the current theme. -->
          ${(0,lit_directives_if_defined_js__WEBPACK_IMPORTED_MODULE_4__.ifDefined)(post[column].value)}
        </td>`;
      }
      if (this.postTypeSettings[column].type === 'boolean') {
        if (column === 'favorite') {
          return (0,lit__WEBPACK_IMPORTED_MODULE_0__.html)`<td
            dir="auto"
            title="${this.postTypeSettings[column].name}"
            class=""
          >
            <dt-star postID=${post.ID} ?selected=${post.favorite}></dt-star>
          </td>`;
        }
        if (this.postTypeSettings[column] === true) {
          return (0,lit__WEBPACK_IMPORTED_MODULE_0__.html)`<td
            dir="auto"
            title="${this.postTypeSettings[column].name}"
          >
            ['&check;']
          </td>`;
        }
      }
      return (0,lit__WEBPACK_IMPORTED_MODULE_0__.html)`<td
        dir="auto"
        title="${this.postTypeSettings[column].name}"
      ></td>`;
    });
  }

  _fieldListIconTemplate(field) {
    if (this.postTypeSettings[field].icon) {
      return (0,lit__WEBPACK_IMPORTED_MODULE_0__.html)`<img
        class="dt-icon"
        src="${this.postTypeSettings[field].icon}"
        alt="${this.postTypeSettings[field].name}"
      />`;
    }
    return null;
  }

  _fieldsListTemplate() {
    return (0,lit_directives_repeat_js__WEBPACK_IMPORTED_MODULE_3__.repeat)(
      Object.keys(this.postTypeSettings).sort((a, b) => {
        const nameA = this.postTypeSettings[a].name.toUpperCase(); // ignore upper and lowercase
        const nameB = this.postTypeSettings[b].name.toUpperCase(); // ignore upper and lowercase
        if (nameA < nameB) {
          return -1;
        }
        if (nameA > nameB) {
          return 1;
        }
        // names must be equal
        return 0;
      }),
      field => field,
      field => {
        if (!this.postTypeSettings[field].hidden) {
          return (0,lit__WEBPACK_IMPORTED_MODULE_0__.html)`<li class="list-field-picker-item">
            <label>
              <input
                type="checkbox"
                id="${field}"
                name="${field}"
                .value="${field}"
                @change=${this._updateFields}
                ?checked=${this.columns.includes(field)}
              />
              ${this._fieldListIconTemplate(field)}
              ${this.postTypeSettings[field].name}</label
            >
          </li> `;
        }
        return null;
      }
    );
  }

  _fieldsSelectorTemplate() {
    if (this.showFieldsSelector) {
      return (0,lit__WEBPACK_IMPORTED_MODULE_0__.html)`<div
        id="list_column_picker"
        class="list_field_picker list_action_section"
      >
        <div class="list_action_section_header">
          <p style="font-weight:bold">
            ${(0,_lit_localize__WEBPACK_IMPORTED_MODULE_1__.msg)('Choose which fields to display as columns in the list')}
          </p>
          <button
            class="close-button list-action-close-button"
            data-close="list_column_picker"
            aria-label="Close modal"
            type="button"
            @click=${this._fieldsEdit}
          >
            <span aria-hidden="true"></span>
          </button>
        </div>
        <ul class="fieldsList">
          ${this._fieldsListTemplate()}
        </ul>
      </div>`;
    }
    return null;
  }

  _updateFields(e) {
    const field = e.target.value;
    const viewableColumns = this.columns;

    if (!viewableColumns.includes(field)) {
      viewableColumns.push(field);
    } else {
      viewableColumns.filter(column => column !== field);
      viewableColumns.splice(viewableColumns.indexOf(field), 1);
    }

    this.columns = viewableColumns;
    this.style.setProperty('--number-of-columns', this.columns.length - 1);

    this.requestUpdate();
  }

  _bulkSelectorTemplate() {
    if (this.showBulkEditSelector) {
      return (0,lit__WEBPACK_IMPORTED_MODULE_0__.html)`<div id="bulk_edit_picker" class="list_action_section">
        <div class="list_action_section_header">
          <p style="font-weight:bold">
            ${(0,_lit_localize__WEBPACK_IMPORTED_MODULE_1__.msg)(
              (0,_lit_localize__WEBPACK_IMPORTED_MODULE_1__.str)`Select all the ${this.postType} you want to update from the list, and update them below`
            )}
          </p>
          <button
            class="close-button list-action-close-button"
            aria-label="Close modal"
            type="button"
            @click=${this._bulkEdit}
          >
            <span aria-hidden="true"></span>
          </button>
        </div>
        <ul class="fieldsList">
          This is where the bulk edit form will go.
        </ul>
      </div>`;
    }
    return null;
  }

  connectedCallback() {
    super.connectedCallback();
    if (!this.posts) {
      this._getPosts().then(posts => {
        this.posts = posts;
      });
    }
  }

  render() {
    const bulkEditClass = {
      bulk_editing: this.showBulkEditSelector,
      hidden: false,
    };

    // prettier-ignore
    const bulkEditSvg = (0,lit__WEBPACK_IMPORTED_MODULE_0__.html)`
      <svg viewBox="0 0 100 100" fill="#000000" style="enable-background:new 0 0 100 100;" xmlns="http://www.w3.org/2000/svg">
        <line style="stroke-linecap: round; paint-order: fill; fill: none; stroke-width: 15px;" x1="7.97" y1="50.199" x2="76.069" y2="50.128" transform="matrix(0.999999, 0.001017, -0.001017, 0.999999, 0.051038, -0.042708)"/>
        <line style="stroke-linecap: round; stroke-width: 15px;" x1="7.97" y1="17.751" x2="92.058" y2="17.751"/>
        <line style="stroke-linecap: round; stroke-width: 15px;" x1="7.97" y1="82.853" x2="42.343" y2="82.853"/>
        <polygon style="stroke-linecap: round; stroke-miterlimit: 1; stroke-linejoin: round; fill: rgb(255, 255, 255); paint-order: stroke; stroke-width: 9px;" points="22.982 64.982 33.592 53.186 50.916 70.608 82.902 21.308 95 30.85 52.256 95"/>
      </svg>
    `;
    // prettier-ignore
    const fieldsSvg = (0,lit__WEBPACK_IMPORTED_MODULE_0__.html)`<svg height='100px' width='100px'  fill="#000000" xmlns:x="http://ns.adobe.com/Extensibility/1.0/" xmlns:i="http://ns.adobe.com/AdobeIllustrator/10.0/" xmlns:graph="http://ns.adobe.com/Graphs/1.0/" xmlns="http://www.w3.org/2000/svg" xmlns:xlink="http://www.w3.org/1999/xlink" version="1.1" x="0px" y="0px" viewBox="0 0 100 100" style="enable-background:new 0 0 100 100;" xml:space="preserve"><g><g i:extraneous="self"><g><path d="M94.4,63c0-5.7-3.6-10.5-8.6-12.5V7.3c0-2.7-2.2-4.8-4.8-4.8c-2.7,0-4.8,2.2-4.8,4.8v43.2c-5,1.9-8.6,6.8-8.6,12.5     s3.6,10.5,8.6,12.5v17.2c0,2.7,2.2,4.8,4.8,4.8c2.7,0,4.8-2.2,4.8-4.8V75.5C90.9,73.6,94.4,68.7,94.4,63z M81,66.7     c-2,0-3.7-1.7-3.7-3.7c0-2,1.7-3.7,3.7-3.7s3.7,1.7,3.7,3.7C84.7,65.1,83.1,66.7,81,66.7z"></path><path d="M54.8,24.5V7.3c0-2.7-2.2-4.8-4.8-4.8c-2.7,0-4.8,2.2-4.8,4.8v17.2c-5,1.9-8.6,6.8-8.6,12.5s3.6,10.5,8.6,12.5v43.2     c0,2.7,2.2,4.8,4.8,4.8c2.7,0,4.8-2.2,4.8-4.8V49.5c5-1.9,8.6-6.8,8.6-12.5S59.8,26.5,54.8,24.5z M50,40.7c-2,0-3.7-1.7-3.7-3.7     c0-2,1.7-3.7,3.7-3.7c2,0,3.7,1.7,3.7,3.7C53.7,39.1,52,40.7,50,40.7z"></path><path d="M23.8,50.5V7.3c0-2.7-2.2-4.8-4.8-4.8c-2.7,0-4.8,2.2-4.8,4.8v43.2c-5,1.9-8.6,6.8-8.6,12.5s3.6,10.5,8.6,12.5v17.2     c0,2.7,2.2,4.8,4.8,4.8c2.7,0,4.8-2.2,4.8-4.8V75.5c5-1.9,8.6-6.8,8.6-12.5S28.8,52.5,23.8,50.5z M19,66.7c-2,0-3.7-1.7-3.7-3.7     c0-2,1.7-3.7,3.7-3.7c2,0,3.7,1.7,3.7,3.7C22.7,65.1,21,66.7,19,66.7z"></path></g></g></g></svg>`;

    return (0,lit__WEBPACK_IMPORTED_MODULE_0__.html)`
      <div class="section">
        <div class="header">
          <div class="section-header">
            <span
              class="section-header posts-header"
              style="display: inline-block"
              >${(0,_lit_localize__WEBPACK_IMPORTED_MODULE_1__.msg)(
                (0,_lit_localize__WEBPACK_IMPORTED_MODULE_1__.str)`${
                  this.postTypeLabel ? this.postTypeLabel : this.postType
                } List`
              )}</span
            >
          </div>
          <span class="filter-result-text"
            >${(0,_lit_localize__WEBPACK_IMPORTED_MODULE_1__.msg)((0,_lit_localize__WEBPACK_IMPORTED_MODULE_1__.str)`Showing 1 of ${this.total}`)}</span
          >

          <button
            class="bulkToggle toggleButton"
            id="bulk_edit_button"
            @click=${this._bulkEdit}
          >
            ${bulkEditSvg} ${(0,_lit_localize__WEBPACK_IMPORTED_MODULE_1__.msg)('Bulk Edit')}
          </button>
          <button
            class="fieldsToggle toggleButton"
            id="fields_edit_button"
            @click=${this._fieldsEdit}
          >
            ${fieldsSvg} ${(0,_lit_localize__WEBPACK_IMPORTED_MODULE_1__.msg)('Fields')}
          </button>

          <dt-toggle
            name="showArchived"
            label=${(0,_lit_localize__WEBPACK_IMPORTED_MODULE_1__.msg)('Show Archived')}
            ?checked=${this.showArchived}
            hideIcons
            onchange=${this._toggleShowArchived}
            @click=${this._toggleShowArchived}
          ></dt-toggle>
        </div>
        ${this._fieldsSelectorTemplate()} ${this._bulkSelectorTemplate()}
        <table class=${(0,lit_directives_class_map_js__WEBPACK_IMPORTED_MODULE_5__.classMap)(bulkEditClass)}>
          ${this._headerTemplate()}
          ${this.posts ? this._rowTemplate() : (0,_lit_localize__WEBPACK_IMPORTED_MODULE_1__.msg)('Loading')}
        </table>
      </div>
    `;
  }
}

window.customElements.define('dt-list', DtList);


/***/ }),

/***/ "./node_modules/@disciple.tools/web-components/src/components/layout/dt-modal/dt-modal.js":
/*!************************************************************************************************!*\
  !*** ./node_modules/@disciple.tools/web-components/src/components/layout/dt-modal/dt-modal.js ***!
  \************************************************************************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   DtModal: () => (/* binding */ DtModal)
/* harmony export */ });
/* harmony import */ var lit__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! lit */ "./node_modules/lit/index.js");
/* harmony import */ var _lit_localize__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! @lit/localize */ "./node_modules/@lit/localize/lit-localize.js");
/* harmony import */ var lit_directives_class_map_js__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! lit/directives/class-map.js */ "./node_modules/lit/directives/class-map.js");
/* harmony import */ var lit_directives_style_map_js__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(/*! lit/directives/style-map.js */ "./node_modules/lit/directives/style-map.js");
/* harmony import */ var _dt_base_js__WEBPACK_IMPORTED_MODULE_4__ = __webpack_require__(/*! ../../dt-base.js */ "./node_modules/@disciple.tools/web-components/src/components/dt-base.js");






class DtModal extends _dt_base_js__WEBPACK_IMPORTED_MODULE_4__["default"] {
  static get styles() {
    return (0,lit__WEBPACK_IMPORTED_MODULE_0__.css)`
      :host {
        display: block;
        font-family: var(--font-family);
      }
      :host:has(dialog[open]) {
        overflow: hidden;
      }

      .dt-modal {
        display: block;
        background: var(--dt-modal-background-color, #fff);
        color: var(--dt-modal-color, #000);
        max-inline-size: min(90vw, 100%);
        max-block-size: min(80vh, 100%);
        max-block-size: min(80dvb, 100%);
        margin: auto;
        height: fit-content;
        padding: var(--dt-modal-padding, 1em);
        position: fixed;
        inset: 0;
        border-radius: 1em;
        border: none;
        box-shadow: var(--shadow-6);
        z-index: 1000;
        transition: opacity 0.1s ease-in-out;
      }

      dialog:not([open]) {
        pointer-events: none;
        opacity: 0;
      }

      dialog::backdrop {
        background: var(--dt-modal-backdrop-color, rgba(0, 0, 0, 0.25));
        animation: var(--dt-modal-animation, fade-in 0.75s);
      }

      @keyframes fade-in {
        from {
          opacity: 0;
        }
        to {
          opacity: 1;
        }
      }

      h1,
      h2,
      h3,
      h4,
      h5,
      h6 {
        line-height: 1.4;
        text-rendering: optimizeLegibility;
        color: inherit;
        font-style: normal;
        font-weight: 300;
        margin: 0;
      }

      form {
        display: grid;
        height: fit-content;
        grid-template-columns: 1fr;
        grid-template-rows: 100px auto 100px;
        grid-template-areas:
          'header'
          'main'
          'footer';
        position: relative;
      }

      form.no-header {
        grid-template-rows: auto auto;
        grid-template-areas:
          'main'
          'footer';
      }

      header {
        grid-area: header;
        display: flex;
        justify-content: space-between;
      }

      .button {
        color: var(--dt-modal-button-color, #fff);
        background: var(--dt-modal-button-background, #000);
        font-size: 1rem;
        border: 0.1em solid var(--dt-modal-button-background, #000);
        border-radius: 0.25em;
        padding: 0.25rem 0.5rem;
        cursor: pointer;
        text-decoration: none;
      }
      .button.opener {
        color: var(--dt-modal-button-opener-color,var(--dt-modal-button-color, #fff) );
        background: var(--dt-modal-button-opener-background, var(--dt-modal-button-background, #000) );
        border: 0.1em solid var(--dt-modal-button-opener-background, #000);
      }
      button.toggle {
        margin-inline-end: 0;
        margin-inline-start: auto;
        background: none;
        border: none;
        color: inherit;
        cursor: pointer;
        display: flex;
        align-items: flex-start;
      }

      article {
        grid-area: main;
        overflow: auto;
      }

      footer {
        grid-area: footer;
        display: flex;
        justify-content: space-between;
      }

      .help-more h5 {
        font-size: 0.75rem;
        display: block;
      }
      .help-more .button {
        font-size: 0.75rem;
        display: block;
      }
    `;
  }

  static get properties() {
    return {
      title: { type: String },
      context: { type: String },
      isHelp: { type: Boolean },
      isOpen: { type: Boolean },
      hideHeader: { type: Boolean },
      hideButton: { type: Boolean },
      buttonClass: { type: Object },
      buttonStyle: { type: Object },
    };
  }

  constructor() {
    super();
    this.context = 'default';
    this.addEventListener('open', (e) => this._openModal());
    this.addEventListener('close', (e) => this._closeModal());
  }

  _openModal() {
    this.isOpen = true;
    this.shadowRoot.querySelector('dialog').showModal();

    document.querySelector('body').style.overflow = "hidden"
  }

  _dialogHeader(svg) {
    if (!this.hideHeader) {
      return (0,lit__WEBPACK_IMPORTED_MODULE_0__.html)`
      <header>
            <h1 id="modal-field-title">${this.title}</h1>
            <button @click="${this._cancelModal}" class="toggle">${svg}</button>
          </header>
      `;
    }
    return (0,lit__WEBPACK_IMPORTED_MODULE_0__.html)``;
  }

  _closeModal() {
    this.isOpen = false;
    this.shadowRoot.querySelector('dialog').close();
    document.querySelector('body').style.overflow = "initial"
  }
  _cancelModal() {
    this._triggerClose('cancel');
  }
  _triggerClose(action) {
    this.dispatchEvent(new CustomEvent('close', {
      detail: {
        action,
      },
    }));
  }

  _dialogClick(e) {
    if (e.target.tagName !== 'DIALOG') {
      // This prevents issues with forms
      return;
    }

    // Close the modal if the user clicks outside of the modal
    const rect = e.target.getBoundingClientRect();

    const clickedInDialog =
      rect.top <= e.clientY &&
      e.clientY <= rect.top + rect.height &&
      rect.left <= e.clientX &&
      e.clientX <= rect.left + rect.width;

    if (clickedInDialog === false) {
      this._cancelModal();
    }
  }

  _dialogKeypress(e) {
    if (e.key === 'Escape') {
      this._cancelModal();
    }
  }

  _helpMore() {
    return this.isHelp
      ? (0,lit__WEBPACK_IMPORTED_MODULE_0__.html)`
          <div class="help-more">
            <h5>${(0,_lit_localize__WEBPACK_IMPORTED_MODULE_1__.msg)('Need more help?')}</h5>
            <a
              class="button small"
              id="docslink"
              href="https://disciple.tools/user-docs"
              target="_blank"
              >${(0,_lit_localize__WEBPACK_IMPORTED_MODULE_1__.msg)('Read the documentation')}</a
            >
          </div>
        `
      : null;
  }

  firstUpdated() {
    if (this.isOpen) {
      this._openModal();
    }
  }

  _onButtonClick() {
    this._triggerClose('button');
  }

  render() {
    // prettier-ignore
    const svg = (0,lit__WEBPACK_IMPORTED_MODULE_0__.html)`
      <svg viewPort="0 0 12 12" version="1.1" width='12' height='12'>
          xmlns="http://www.w3.org/2000/svg">
        <line x1="1" y1="11"
              x2="11" y2="1"
              stroke="currentColor"
              stroke-width="2"/>
        <line x1="1" y1="1"
              x2="11" y2="11"
              stroke="currentColor"
              stroke-width="2"/>
      </svg>
    `;
    return (0,lit__WEBPACK_IMPORTED_MODULE_0__.html)`
      <dialog
        id=""
        class="dt-modal"
        @click=${this._dialogClick}
        @keypress=${this._dialogKeypress}
      >
        <form method="dialog" class=${this.hideHeader ? "no-header" : ""}>
      ${this._dialogHeader(svg)}
          <article>
            <slot name="content"></slot>
          </article>
          <footer>
            <button
              class="button small"
              data-close=""
              aria-label="Close reveal"
              type="button"
              @click=${this._onButtonClick}
            >
              <slot name="close-button">${(0,_lit_localize__WEBPACK_IMPORTED_MODULE_1__.msg)('Close')}</slot>
            </button>
            ${this._helpMore()}
          </footer>
        </form>
      </dialog>

      ${!this.hideButton
      ? (0,lit__WEBPACK_IMPORTED_MODULE_0__.html)`
      <button
        class="button small opener ${(0,lit_directives_class_map_js__WEBPACK_IMPORTED_MODULE_2__.classMap)(this.buttonClass || {})}"
        data-open=""
        aria-label="Open reveal"
        type="button"
        @click="${this._openModal}"
        style=${(0,lit_directives_style_map_js__WEBPACK_IMPORTED_MODULE_3__.styleMap)(this.buttonStyle || {})}
      >
        <slot name="openButton">${(0,_lit_localize__WEBPACK_IMPORTED_MODULE_1__.msg)('Open Dialog')}</slot>
      </button>
      ` : null}
    `;
  }
}

window.customElements.define('dt-modal', DtModal);


/***/ }),

/***/ "./node_modules/@disciple.tools/web-components/src/components/layout/dt-tile/dt-tile.js":
/*!**********************************************************************************************!*\
  !*** ./node_modules/@disciple.tools/web-components/src/components/layout/dt-tile/dt-tile.js ***!
  \**********************************************************************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   DtTile: () => (/* binding */ DtTile)
/* harmony export */ });
/* harmony import */ var lit__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! lit */ "./node_modules/lit/index.js");
/* harmony import */ var _dt_base_js__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ../../dt-base.js */ "./node_modules/@disciple.tools/web-components/src/components/dt-base.js");



class DtTile extends _dt_base_js__WEBPACK_IMPORTED_MODULE_1__["default"] {
  static get styles() {
    return (0,lit__WEBPACK_IMPORTED_MODULE_0__.css)`
      :host {
        font-family: var(--dt-tile-font-family, var(--font-family));
        font-size: var(--dt-tile-font-size, 14px);
        font-weight: var(--dt-tile-font-weight, 700);
        overflow: hidden;
        text-overflow: ellipsis;
      }

      section {
        background-color: var(--dt-tile-background-color, #fefefe);
        border-top: var(--dt-tile-border-top, 1px solid #cecece);
        border-bottom: var(--dt-tile-border-bottom, 1px solid #cecece);
        border-right: var(--dt-tile-border-right, 1px solid #cecece);
        border-left: var(--dt-tile-border-left, 1px solid #cecece);
        border-radius: var(--dt-tile-border-radius, 10px);
        box-shadow: var(--dt-tile-box-shadow, 0 2px 4px rgb(0 0 0 / 25%));
        padding: 1rem;
        margin: var(--dt-tile-margin, 0); 
      }

      h3 {
        line-height: 1.4;
        margin: var(--dt-tile-header-margin, 0 0 0.5rem 0);
        text-rendering: optimizeLegibility;
        font-family: var(--dt-tile-font-family, var(--font-family));
        font-style: normal;
        font-weight: var(--dt-tile-header-font-weight, 300);
      }

      .section-header {
        color: var(--dt-tile-header-color, #3f729b);
        font-size: 1.5rem;
        display: flex;
        text-transform: var(--dt-tile-header-text-transform, capitalize);
        justify-content: var(--dt-tile-header-justify-content);
      }

      .section-body {
        display: grid;
        grid-template-columns: repeat(auto-fill, minmax(200px, 1fr));
        column-gap: 1.4rem;
        transition: height 1s ease 0s;
        height: auto;
      }
      .section-body.collapsed {
        height: 0 !important;
        overflow: hidden;
      }

      button.toggle {
        margin-inline-end: 0;
        margin-inline-start: auto;
        background: none;
        border: none;
      }

      .chevron::before {
        border-color: var(--dt-tile-header-color, var(--primary-color));
        border-style: solid;
        border-width: 2px 2px 0 0;
        content: '';
        display: inline-block;
        height: 1em;
        width: 1em;
        left: 0.15em;
        position: relative;
        top: 0.15em;
        transform: rotate(-45deg);
        vertical-align: top;
      }

      .chevron.down:before {
        top: 0;
        transform: rotate(135deg);
      }
    `;
  }

  static get properties() {
    return {
      title: { type: String },
      expands: { type: Boolean },
      collapsed: { type: Boolean },
    };
  }

  get hasHeading() {
    return this.title || this.expands;
  }

  _toggle() {
    // const body = this.renderRoot.querySelector('.section-body');
    // if (!this.collapsed && body && body.clientHeight) {
    //   body.style.height = body.clientHeight + 'px';
    // }
    this.collapsed = !this.collapsed;
  }

  renderHeading() {
    if (!this.hasHeading) {
      return lit__WEBPACK_IMPORTED_MODULE_0__.nothing
    }

    return (0,lit__WEBPACK_IMPORTED_MODULE_0__.html)`
        <h3 class="section-header">
          ${this.title}
          ${this.expands
            ? (0,lit__WEBPACK_IMPORTED_MODULE_0__.html)`
                <button
                  @click="${this._toggle}"
                  class="toggle chevron ${this.collapsed ? 'down' : 'up'}"
                >
                  &nbsp;
                </button>
              `
            : null}
        </h3>
    `
  }

  render() {
    return (0,lit__WEBPACK_IMPORTED_MODULE_0__.html)`
      <section>
        ${this.renderHeading()}
        <div class="section-body ${this.collapsed ? 'collapsed' : null}">
          <slot></slot>
        </div>
      </section>
    `;
  }
}

window.customElements.define('dt-tile', DtTile);


/***/ }),

/***/ "./node_modules/@disciple.tools/web-components/src/i18n/generated lazy recursive ^\\.\\/.*\\.js$":
/*!************************************************************************************************************!*\
  !*** ./node_modules/@disciple.tools/web-components/src/i18n/generated/ lazy ^\.\/.*\.js$ namespace object ***!
  \************************************************************************************************************/
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

var map = {
	"./am_ET.js": [
		"./node_modules/@disciple.tools/web-components/src/i18n/generated/am_ET.js",
		"node_modules_disciple_tools_web-components_src_i18n_generated_am_ET_js"
	],
	"./ar.js": [
		"./node_modules/@disciple.tools/web-components/src/i18n/generated/ar.js",
		"node_modules_disciple_tools_web-components_src_i18n_generated_ar_js"
	],
	"./ar_MA.js": [
		"./node_modules/@disciple.tools/web-components/src/i18n/generated/ar_MA.js",
		"node_modules_disciple_tools_web-components_src_i18n_generated_ar_MA_js"
	],
	"./bg_BG.js": [
		"./node_modules/@disciple.tools/web-components/src/i18n/generated/bg_BG.js",
		"node_modules_disciple_tools_web-components_src_i18n_generated_bg_BG_js"
	],
	"./bn_BD.js": [
		"./node_modules/@disciple.tools/web-components/src/i18n/generated/bn_BD.js",
		"node_modules_disciple_tools_web-components_src_i18n_generated_bn_BD_js"
	],
	"./bs_BA.js": [
		"./node_modules/@disciple.tools/web-components/src/i18n/generated/bs_BA.js",
		"node_modules_disciple_tools_web-components_src_i18n_generated_bs_BA_js"
	],
	"./cs.js": [
		"./node_modules/@disciple.tools/web-components/src/i18n/generated/cs.js",
		"node_modules_disciple_tools_web-components_src_i18n_generated_cs_js"
	],
	"./de_DE.js": [
		"./node_modules/@disciple.tools/web-components/src/i18n/generated/de_DE.js",
		"node_modules_disciple_tools_web-components_src_i18n_generated_de_DE_js"
	],
	"./el.js": [
		"./node_modules/@disciple.tools/web-components/src/i18n/generated/el.js",
		"node_modules_disciple_tools_web-components_src_i18n_generated_el_js"
	],
	"./en_US.js": [
		"./node_modules/@disciple.tools/web-components/src/i18n/generated/en_US.js",
		"node_modules_disciple_tools_web-components_src_i18n_generated_en_US_js"
	],
	"./es-419.js": [
		"./node_modules/@disciple.tools/web-components/src/i18n/generated/es-419.js",
		"node_modules_disciple_tools_web-components_src_i18n_generated_es-419_js"
	],
	"./es_419.js": [
		"./node_modules/@disciple.tools/web-components/src/i18n/generated/es_419.js",
		"node_modules_disciple_tools_web-components_src_i18n_generated_es_419_js"
	],
	"./es_ES.js": [
		"./node_modules/@disciple.tools/web-components/src/i18n/generated/es_ES.js",
		"node_modules_disciple_tools_web-components_src_i18n_generated_es_ES_js"
	],
	"./fa_IR.js": [
		"./node_modules/@disciple.tools/web-components/src/i18n/generated/fa_IR.js",
		"node_modules_disciple_tools_web-components_src_i18n_generated_fa_IR_js"
	],
	"./fr_FR.js": [
		"./node_modules/@disciple.tools/web-components/src/i18n/generated/fr_FR.js",
		"node_modules_disciple_tools_web-components_src_i18n_generated_fr_FR_js"
	],
	"./hi_IN.js": [
		"./node_modules/@disciple.tools/web-components/src/i18n/generated/hi_IN.js",
		"node_modules_disciple_tools_web-components_src_i18n_generated_hi_IN_js"
	],
	"./hr.js": [
		"./node_modules/@disciple.tools/web-components/src/i18n/generated/hr.js",
		"node_modules_disciple_tools_web-components_src_i18n_generated_hr_js"
	],
	"./hu_HU.js": [
		"./node_modules/@disciple.tools/web-components/src/i18n/generated/hu_HU.js",
		"node_modules_disciple_tools_web-components_src_i18n_generated_hu_HU_js"
	],
	"./id_ID.js": [
		"./node_modules/@disciple.tools/web-components/src/i18n/generated/id_ID.js",
		"node_modules_disciple_tools_web-components_src_i18n_generated_id_ID_js"
	],
	"./it_IT.js": [
		"./node_modules/@disciple.tools/web-components/src/i18n/generated/it_IT.js",
		"node_modules_disciple_tools_web-components_src_i18n_generated_it_IT_js"
	],
	"./ja.js": [
		"./node_modules/@disciple.tools/web-components/src/i18n/generated/ja.js",
		"node_modules_disciple_tools_web-components_src_i18n_generated_ja_js"
	],
	"./ko_KR.js": [
		"./node_modules/@disciple.tools/web-components/src/i18n/generated/ko_KR.js",
		"node_modules_disciple_tools_web-components_src_i18n_generated_ko_KR_js"
	],
	"./mk_MK.js": [
		"./node_modules/@disciple.tools/web-components/src/i18n/generated/mk_MK.js",
		"node_modules_disciple_tools_web-components_src_i18n_generated_mk_MK_js"
	],
	"./mr.js": [
		"./node_modules/@disciple.tools/web-components/src/i18n/generated/mr.js",
		"node_modules_disciple_tools_web-components_src_i18n_generated_mr_js"
	],
	"./my_MM.js": [
		"./node_modules/@disciple.tools/web-components/src/i18n/generated/my_MM.js",
		"node_modules_disciple_tools_web-components_src_i18n_generated_my_MM_js"
	],
	"./ne_NP.js": [
		"./node_modules/@disciple.tools/web-components/src/i18n/generated/ne_NP.js",
		"node_modules_disciple_tools_web-components_src_i18n_generated_ne_NP_js"
	],
	"./nl_NL.js": [
		"./node_modules/@disciple.tools/web-components/src/i18n/generated/nl_NL.js",
		"node_modules_disciple_tools_web-components_src_i18n_generated_nl_NL_js"
	],
	"./pa_IN.js": [
		"./node_modules/@disciple.tools/web-components/src/i18n/generated/pa_IN.js",
		"node_modules_disciple_tools_web-components_src_i18n_generated_pa_IN_js"
	],
	"./pl.js": [
		"./node_modules/@disciple.tools/web-components/src/i18n/generated/pl.js",
		"node_modules_disciple_tools_web-components_src_i18n_generated_pl_js"
	],
	"./pt_BR.js": [
		"./node_modules/@disciple.tools/web-components/src/i18n/generated/pt_BR.js",
		"node_modules_disciple_tools_web-components_src_i18n_generated_pt_BR_js"
	],
	"./ro_RO.js": [
		"./node_modules/@disciple.tools/web-components/src/i18n/generated/ro_RO.js",
		"node_modules_disciple_tools_web-components_src_i18n_generated_ro_RO_js"
	],
	"./ru_RU.js": [
		"./node_modules/@disciple.tools/web-components/src/i18n/generated/ru_RU.js",
		"node_modules_disciple_tools_web-components_src_i18n_generated_ru_RU_js"
	],
	"./sl_SI.js": [
		"./node_modules/@disciple.tools/web-components/src/i18n/generated/sl_SI.js",
		"node_modules_disciple_tools_web-components_src_i18n_generated_sl_SI_js"
	],
	"./sr_BA.js": [
		"./node_modules/@disciple.tools/web-components/src/i18n/generated/sr_BA.js",
		"node_modules_disciple_tools_web-components_src_i18n_generated_sr_BA_js"
	],
	"./sw.js": [
		"./node_modules/@disciple.tools/web-components/src/i18n/generated/sw.js",
		"node_modules_disciple_tools_web-components_src_i18n_generated_sw_js"
	],
	"./th.js": [
		"./node_modules/@disciple.tools/web-components/src/i18n/generated/th.js",
		"node_modules_disciple_tools_web-components_src_i18n_generated_th_js"
	],
	"./tl.js": [
		"./node_modules/@disciple.tools/web-components/src/i18n/generated/tl.js",
		"node_modules_disciple_tools_web-components_src_i18n_generated_tl_js"
	],
	"./tr_TR.js": [
		"./node_modules/@disciple.tools/web-components/src/i18n/generated/tr_TR.js",
		"node_modules_disciple_tools_web-components_src_i18n_generated_tr_TR_js"
	],
	"./uk.js": [
		"./node_modules/@disciple.tools/web-components/src/i18n/generated/uk.js",
		"node_modules_disciple_tools_web-components_src_i18n_generated_uk_js"
	],
	"./vi.js": [
		"./node_modules/@disciple.tools/web-components/src/i18n/generated/vi.js",
		"node_modules_disciple_tools_web-components_src_i18n_generated_vi_js"
	],
	"./zh_CN.js": [
		"./node_modules/@disciple.tools/web-components/src/i18n/generated/zh_CN.js",
		"node_modules_disciple_tools_web-components_src_i18n_generated_zh_CN_js"
	],
	"./zh_TW.js": [
		"./node_modules/@disciple.tools/web-components/src/i18n/generated/zh_TW.js",
		"node_modules_disciple_tools_web-components_src_i18n_generated_zh_TW_js"
	]
};
function webpackAsyncContext(req) {
	if(!__webpack_require__.o(map, req)) {
		return Promise.resolve().then(() => {
			var e = new Error("Cannot find module '" + req + "'");
			e.code = 'MODULE_NOT_FOUND';
			throw e;
		});
	}

	var ids = map[req], id = ids[0];
	return __webpack_require__.e(ids[1]).then(() => {
		return __webpack_require__(id);
	});
}
webpackAsyncContext.keys = () => (Object.keys(map));
webpackAsyncContext.id = "./node_modules/@disciple.tools/web-components/src/i18n/generated lazy recursive ^\\.\\/.*\\.js$";
module.exports = webpackAsyncContext;

/***/ }),

/***/ "./node_modules/@disciple.tools/web-components/src/i18n/locale-codes.js":
/*!******************************************************************************!*\
  !*** ./node_modules/@disciple.tools/web-components/src/i18n/locale-codes.js ***!
  \******************************************************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   allLocales: () => (/* binding */ allLocales),
/* harmony export */   sourceLocale: () => (/* binding */ sourceLocale),
/* harmony export */   targetLocales: () => (/* binding */ targetLocales)
/* harmony export */ });
// Do not modify this file by hand!
// Re-generate this file by running lit-localize.

/**
 * The locale code that templates in this source code are written in.
 */
const sourceLocale = `en`;

/**
 * The other locale codes that this application is localized into. Sorted
 * lexicographically.
 */
const targetLocales = [
  `am_ET`,
  `ar`,
  `ar_MA`,
  `bg_BG`,
  `bn_BD`,
  `bs_BA`,
  `cs`,
  `de_DE`,
  `el`,
  `en_US`,
  `es_419`,
  `es_ES`,
  `fa_IR`,
  `fr_FR`,
  `hi_IN`,
  `hr`,
  `hu_HU`,
  `id_ID`,
  `it_IT`,
  `ja`,
  `ko_KR`,
  `mk_MK`,
  `mr`,
  `my_MM`,
  `ne_NP`,
  `nl_NL`,
  `pa_IN`,
  `pl`,
  `pt_BR`,
  `ro_RO`,
  `ru_RU`,
  `sl_SI`,
  `sr_BA`,
  `sw`,
  `th`,
  `tl`,
  `tr_TR`,
  `uk`,
  `vi`,
  `zh_CN`,
  `zh_TW`,
];

/**
 * All valid project locale codes. Sorted lexicographically.
 */
const allLocales = [
  `am_ET`,
  `ar`,
  `ar_MA`,
  `bg_BG`,
  `bn_BD`,
  `bs_BA`,
  `cs`,
  `de_DE`,
  `el`,
  `en`,
  `en_US`,
  `es_419`,
  `es_ES`,
  `fa_IR`,
  `fr_FR`,
  `hi_IN`,
  `hr`,
  `hu_HU`,
  `id_ID`,
  `it_IT`,
  `ja`,
  `ko_KR`,
  `mk_MK`,
  `mr`,
  `my_MM`,
  `ne_NP`,
  `nl_NL`,
  `pa_IN`,
  `pl`,
  `pt_BR`,
  `ro_RO`,
  `ru_RU`,
  `sl_SI`,
  `sr_BA`,
  `sw`,
  `th`,
  `tl`,
  `tr_TR`,
  `uk`,
  `vi`,
  `zh_CN`,
  `zh_TW`,
];


/***/ }),

/***/ "./node_modules/@disciple.tools/web-components/src/i18n/localization.js":
/*!******************************************************************************!*\
  !*** ./node_modules/@disciple.tools/web-components/src/i18n/localization.js ***!
  \******************************************************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   getLocale: () => (/* binding */ getLocale),
/* harmony export */   setLocale: () => (/* binding */ setLocale)
/* harmony export */ });
/* harmony import */ var _lit_localize__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! @lit/localize */ "./node_modules/@lit/localize/lit-localize.js");
/* harmony import */ var _locale_codes_js__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ./locale-codes.js */ "./node_modules/@disciple.tools/web-components/src/i18n/locale-codes.js");



const {getLocale, setLocale} = (0,_lit_localize__WEBPACK_IMPORTED_MODULE_0__.configureLocalization)({
  sourceLocale: _locale_codes_js__WEBPACK_IMPORTED_MODULE_1__.sourceLocale,
  targetLocales: _locale_codes_js__WEBPACK_IMPORTED_MODULE_1__.targetLocales,
  loadLocale: (locale) => __webpack_require__("./node_modules/@disciple.tools/web-components/src/i18n/generated lazy recursive ^\\.\\/.*\\.js$")(`./${locale}.js`),
});


/***/ }),

/***/ "./node_modules/@disciple.tools/web-components/src/services/apiService.js":
/*!********************************************************************************!*\
  !*** ./node_modules/@disciple.tools/web-components/src/services/apiService.js ***!
  \********************************************************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "default": () => (/* binding */ ApiService)
/* harmony export */ });
class ApiService {
  /**
   * @param nonce - WordPress nonce for authentication
   * @param apiRoot - Root of API (default: wp-json) (i.e. the part before dt/v1/ or dt-posts/v2/)
   */
  constructor(nonce, apiRoot = 'wp-json') {
    this.nonce = nonce;
    this.apiRoot = apiRoot.endsWith("/")? `${apiRoot}`: `${apiRoot} + "/"`;// ensure it ends with /
    this.apiRoot = `/${apiRoot}/`.replace(/\/\//g, '/'); // ensure it starts/ends with /
  }

  /**
   * Send request to server
   * @param {string} type HTTP Method
   * @param {string} url Either full URL to API endpoint or just the URL segment after base
   * @param {Object} data Post data to send in body of request
   * @param {string} base Base of URL endpoint. Defaults to "dt/v1/"
   * @returns {Promise<any>}
   */
  async makeRequest(type, url, data, base = 'dt/v1/') {
    // make sure base has a trailing slash if url does not start with one
    let urlBase = base;
    if (!urlBase.endsWith('/') && !url.startsWith('/')) {
      urlBase += '/';
    }
    const fullURL = url.startsWith('http')
      ? url
      : `${this.apiRoot}${urlBase}${url}`;

    const options = {
      method: type,
      credentials: 'same-origin',
      headers: {
        'Content-Type': 'application/json',
        'X-WP-Nonce': this.nonce,
      },
    };

    if (type !== 'GET') {
      options.body = JSON.stringify(data);
    }

    const response = await fetch(fullURL, options);

    const content = await response.json();
    if (!response.ok) {
      const error = new Error(content?.message || content.toString());
      error.args = {
        status: response.status,
        statusText: response.statusText,
        body: content,
      }
      throw error;
    }

    return content;
  }

  /**
   * Send request to server for /dt-posts/v2/
   * @param {string} type HTTP Method
   * @param {string} url Either full URL to API endpoint or just the URL segment after base
   * @param {Object} data Post data to send in body of request
   * @returns {Promise<any>}
   */
  async makeRequestOnPosts(type, url, data = {}) {
    return this.makeRequest(type, url, data, 'dt-posts/v2/');
  }

  // region Posts
  /**
   * Get Post from API
   * @param {string} postType
   * @param {number} postId
   * @returns {Promise<any>}
   */
  async getPost(postType, postId) {
    return this.makeRequestOnPosts('GET', `${postType}/${postId}`);
  }

  /**
   * Create Post via API
   * @param {string} postType
   * @param {Object} fields
   * @returns {Promise<any>}
   */
  async createPost(postType, fields) {
    return this.makeRequestOnPosts('POST', postType, fields);
  }

  /**
   * Update Post via API
   * @param {string} postType
   * @param {number} postId
   * @param {Object} data Post data to be updated
   * @returns {Promise<any>}
   */
  async updatePost(postType, postId, data) {
    return this.makeRequestOnPosts('POST', `${postType}/${postId}`, data);
  }

  /**
   * Delete Post via API
   * @param {string} postType
   * @param {number} postId
   * @returns {Promise<any>}
   */
  async deletePost(postType, postId) {
    return this.makeRequestOnPosts('DELETE', `${postType}/${postId}`);
  }

  /**
   * Get compact list of posts for autocomplete fields
   * @param {string} postType
   * @param {string} query - the string to filter the list to. Or the id of the target record
   * @returns {Promise<any>}
   * @see https://developers.disciple.tools/theme-core/api-posts/list-posts-compact
   */
  async listPostsCompact(postType, query = '') {
    const params = new URLSearchParams({
      s: query
    });
    return this.makeRequestOnPosts(
      'GET',
      `${postType}/compact?${params}`
    );
  }

  /**
   * Get duplicates for a post
   * @param {string} postType
   * @param {number} postId
   * @param {Object} args
   * @returns {Promise<any>}
   */
  async getPostDuplicates(postType, postId, args) {
    return this.makeRequestOnPosts(
      'GET',
      `${postType}/${postId}/all_duplicates`,
      args
    );
  }

  /**
   * Get values for a multi_select field
   * @param {string} postType
   * @param {string} field
   * @param {string} query - Search Query
   * @returns {Promise<any>}
   */
  async getMultiSelectValues(postType, field, query = '') {
    const params = new URLSearchParams({
      s: query,
      field,
    });
    return this.makeRequestOnPosts(
      'GET',
      `${postType}/multi-select-values?${params}`
    );
  }

  /**
   * Transfer contact to another site
   * @param {number} contactId
   * @param {string} siteId
   * @returns {Promise<any>}
   */
  async transferContact(contactId, siteId) {
    return this.makeRequestOnPosts('POST', 'contacts/transfer', {
      contact_id: contactId,
      site_post_id: siteId,
    });
  }

  /**
   * Transfer contact summary update
   * @param {number} contactId
   * @param {Object} update
   * @returns {Promise<any>}
   */
  async transferContactSummaryUpdate(contactId, update) {
    return this.makeRequestOnPosts(
      'POST',
      'contacts/transfer/summary/send-update',
      {
        contact_id: contactId,
        update,
      }
    );
  }

  /**
   * Request access to post
   * @param {string} postType
   * @param {number} postId
   * @param {number} userId
   * @returns {Promise<any>}
   */
  async requestRecordAccess(postType, postId, userId) {
    return this.makeRequestOnPosts(
      'POST',
      `${postType}/${postId}/request_record_access`,
      {
        user_id: userId,
      }
    );
  }
  // endregion

  // region Comments
  /**
   * Create comment on post via API
   * @param {string} postType
   * @param {number} postId
   * @param {string} comment Text of comment
   * @param {string} commentType Type of comment
   * @returns {Promise<any>}
   */
  async createComment(postType, postId, comment, commentType = 'comment') {
    return this.makeRequestOnPosts('POST', `${postType}/${postId}/comments`, {
      comment,
      comment_type: commentType,
    });
  }

  /**
   * Update post comment via API
   * @param {string} postType
   * @param {number} postId
   * @param {number} commentId
   * @param {string} commentContent
   * @param {string} commentType
   * @returns {Promise<any>}
   */
  async updateComment(
    postType,
    postId,
    commentId,
    commentContent,
    commentType = 'comment'
  ) {
    return this.makeRequestOnPosts(
      'POST',
      `${postType}/${postId}/comments/${commentId}`,
      {
        comment: commentContent,
        comment_type: commentType,
      }
    );
  }

  /**
   * Delete post comment via API
   * @param {string} postType
   * @param {number} postId
   * @param {number} commentId
   * @returns {Promise<any>}
   */
  async deleteComment(postType, postId, commentId) {
    return this.makeRequestOnPosts(
      'DELETE',
      `${postType}/${postId}/comments/${commentId}`
    );
  }

  /**
   * Get post comments via API
   * @param {string} postType
   * @param {number} postId
   * @returns {Promise<any>}
   */
  async getComments(postType, postId) {
    return this.makeRequestOnPosts('GET', `${postType}/${postId}/comments`);
  }

  /**
   * Toggle post comment reaction
   * @param {string} postType
   * @param {number} postId
   * @param {number} commentId
   * @param {number} userId
   * @param {string} reaction
   * @returns {Promise<any>}
   */
  async toggle_comment_reaction(postType, postId, commentId, userId, reaction) {
    return this.makeRequestOnPosts(
      'POST',
      `${postType}/${postId}/comments/${commentId}/react`,
      {
        user_id: userId,
        reaction,
      }
    );
  }
  // endregion

  // region Activity
  /**
   * Get all activity for a post
   * @param {string} postType
   * @param {number} postId
   * @returns {Promise<any>}
   */
  async getPostActivity(postType, postId) {
    return this.makeRequestOnPosts('GET', `${postType}/${postId}/activity`);
  }

  /**
   * Get single activity for a post
   * @param {string} postType
   * @param {number} postId
   * @param {number} activityId
   * @returns {Promise<any>}
   */
  async getSingleActivity(postType, postId, activityId) {
    return this.makeRequestOnPosts(
      'GET',
      `${postType}/${postId}/activity/${activityId}`
    );
  }

  /**
   * Revert post activity
   * @param {string} postType
   * @param {number} postId
   * @param {number} activityId
   * @returns {Promise<any>}
   */
  async revertActivity(postType, postId, activityId) {
    return this.makeRequestOnPosts(
      'GET',
      `${postType}/${postId}/revert/${activityId}`
    );
  }

  // endregion

  // region Shares
  /**
   * Get all share for a post
   * @param {string} postType
   * @param {number} postId
   * @returns {Promise<any>}
   */
  async getPostShares(postType, postId) {
    return this.makeRequestOnPosts('GET', `${postType}/${postId}/shares`);
  }

  /**
   * Share a post with a user
   * @param {string} postType
   * @param {number} postId
   * @param {number} userId
   * @returns {Promise<any>}
   */
  async addPostShare(postType, postId, userId) {
    return this.makeRequestOnPosts('POST', `${postType}/${postId}/shares`, {
      user_id: userId,
    });
  }

  /**
   * Un-share a post with a user
   * @param {string} postType
   * @param {number} postId
   * @param {number} userId
   * @returns {Promise<any>}
   */
  async removePostShare(postType, postId, userId) {
    return this.makeRequestOnPosts('DELETE', `${postType}/${postId}/shares`, {
      user_id: userId,
    });
  }
  // endregion

  // region Filters
  /**
   * Get Filters
   * @returns {Promise<any>}
   */
  async getFilters() {
    return this.makeRequest('GET', 'users/get_filters');
  }

  /**
   * Save filters
   * @param {string} postType
   * @param {Object} filter
   * @returns {Promise<any>}
   */
  async saveFilters(postType, filter) {
    return this.makeRequest('POST', 'users/save_filters', { filter, postType });
  }

  /**
   * Delete filter
   * @param {string} postType
   * @param {number} id
   * @returns {Promise<void>}
   */
  async deleteFilter(postType, id) {
    return this.makeRequest('DELETE', 'users/save_filters', { id, postType });
  }
  // endregion

  // region Users
  /**
   * Search users
   * @param {string} query
   * @returns {Promise<any>}
   */
  async searchUsers(query) {
    return this.makeRequest('GET', `users/get_users?s=${query}`);
  }

  /**
   * Create user
   * @param {Object} user
   * @returns {Promise<any>}
   */
  async createUser(user) {
    return this.makeRequest('POST', 'users/create', user);
  }
  // endregion

  /**
   * Advanced search
   * @param {string} query
   * @param {string} postType
   * @param {number} offset
   * @param {Object} filters
   * @param {Object} filters.post
   * @param {Object} filters.comment
   * @param {Object} filters.meta
   * @param {Object} filters.status
   * @returns {Promise<any>}
   */
  async advanced_search(query, postType, offset, filters) {
    return this.makeRequest(
      'GET',
      'advanced_search',
      {
        query,
        postType,
        offset,
        post: filters.post,
        comment: filters.comment,
        meta: filters.meta,
        status: filters.status,
      },
      'dt-posts/v2/posts/search/'
    );
  }
}


/***/ }),

/***/ "./node_modules/@disciple.tools/web-components/src/services/googleGeocodeService.js":
/*!******************************************************************************************!*\
  !*** ./node_modules/@disciple.tools/web-components/src/services/googleGeocodeService.js ***!
  \******************************************************************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "default": () => (/* binding */ GoogleGeocodeService)
/* harmony export */ });
class GoogleGeocodeService {
  constructor(token, window, document) {
    this.token = token;
    this.window = window;

    if (!window.google?.maps?.places?.AutocompleteService) {
      let script = document.createElement('script');
      script.src = `https://maps.googleapis.com/maps/api/js?libraries=places&key=${token}`;
      document.body.appendChild(script);
    }
  }

  /**
   * Search places via Mapbox API
   * @param query
   * @returns {Promise<any>}
   */
  async getPlacePredictions(query, language = 'en') {
    if (this.window.google) {
      const service = new this.window.google.maps.places.AutocompleteService();
      const { predictions } = await service.getPlacePredictions({
        input: query,
        language,
      });

      return predictions;
    }
    return null;
  }

  /**
   * Get details for a given address
   * @param address
   * @param language
   * @returns {Promise<null>}
   */
  async getPlaceDetails(address, language = 'en') {
    const params = new URLSearchParams({
      key: this.token,
      address,
      language,
    });
    const apiUrl = `https://maps.googleapis.com/maps/api/geocode/json?${params}`;
    const response = await fetch(apiUrl, { method: 'GET' });

    const data = await response.json();
    let results = [];

    // https://developers.google.com/maps/documentation/geocoding/requests-geocoding#StatusCodes
    switch (data.status) {
      case 'OK':
        results = data.results;
        break;
      case 'ZERO_RESULTS':
      default:
        // general error catch
        break;
    }

    return results && results.length ? results[0] : null;
  }

  /**
   * Reverse geocode a lng/lat pair to get place details
   * @param longitude
   * @param latitude
   * @param language
   * @returns {Promise<Array>}
   */
  async reverseGeocode(longitude, latitude, language = 'en') {
    const params = new URLSearchParams({
      key: this.token,
      latlng: `${latitude},${longitude}`,
      language,
      result_type: [
        'point_of_interest',
        'establishment',
        'premise',
        'street_address',
        'neighborhood',
        'sublocality',
        'locality',
        'colloquial_area',
        'political',
        'country',
      ].join('|')
    });
    const apiUrl = `https://maps.googleapis.com/maps/api/geocode/json?${params}`;
    const response = await fetch(apiUrl, { method: 'GET' });

    const result = await response.json();
    return result?.results;
  }
}


/***/ }),

/***/ "./node_modules/@disciple.tools/web-components/src/services/mapboxService.js":
/*!***********************************************************************************!*\
  !*** ./node_modules/@disciple.tools/web-components/src/services/mapboxService.js ***!
  \***********************************************************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "default": () => (/* binding */ MapboxService)
/* harmony export */ });
class MapboxService {
  constructor(token) {
    this.token = token;
  }

  /**
   * Search places via Mapbox API
   * @param query
   * @param language
   * @returns {Promise<Array>}
   */
  async searchPlaces(query, language = 'en') {
    const params = new URLSearchParams({
      types: ['country', 'region', 'postcode', 'district', 'place', 'locality', 'neighborhood', 'address'],
      limit: 6,
      access_token: this.token,
      language,
    });

    const options = {
      method: 'GET',
      headers: {
        'Content-Type': 'application/json',
      },
    };

    const apiUrl = `https://api.mapbox.com/geocoding/v5/mapbox.places/${encodeURI(query)}.json?${params}`;
    const response = await fetch(apiUrl, options);

    const result = await response.json();
    return result?.features;
  }

  /**
   * Reverse geocode a long/lat pair to get place details
   * @param longitude
   * @param latitude
   * @param language
   * @returns {Promise<Array>}
   */
  async reverseGeocode(longitude, latitude, language = 'en') {
    const params = new URLSearchParams({
      types: ['country', 'region', 'postcode', 'district', 'place', 'locality', 'neighborhood', 'address'],
      access_token: this.token,
      language,
    });

    const options = {
      method: 'GET',
      headers: {
        'Content-Type': 'application/json',
      },
    };

    const apiUrl = `https://api.mapbox.com/geocoding/v5/mapbox.places/${encodeURI(longitude)},${encodeURI(latitude)}.json?${params}`;
    const response = await fetch(apiUrl, options);

    const result = await response.json();
    return result?.features;
  }
}


/***/ }),

/***/ "./assets/js/chat/chat_message.js":
/*!****************************************!*\
  !*** ./assets/js/chat/chat_message.js ***!
  \****************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   smmChatMessage: () => (/* binding */ smmChatMessage)
/* harmony export */ });
/* harmony import */ var lit__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! lit */ "./node_modules/lit/index.js");
/* harmony import */ var _lit_localize__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! @lit/localize */ "./node_modules/@lit/localize/lit-localize.js");
/* harmony import */ var lit_directives_class_map_js__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! lit/directives/class-map.js */ "./node_modules/lit/directives/class-map.js");
/* harmony import */ var _disciple_tools_web_components__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(/*! @disciple.tools/web-components */ "./node_modules/@disciple.tools/web-components/index.js");
function _typeof(o) { "@babel/helpers - typeof"; return _typeof = "function" == typeof Symbol && "symbol" == typeof Symbol.iterator ? function (o) { return typeof o; } : function (o) { return o && "function" == typeof Symbol && o.constructor === Symbol && o !== Symbol.prototype ? "symbol" : typeof o; }, _typeof(o); }
var _templateObject, _templateObject2, _templateObject3, _templateObject4;
function _taggedTemplateLiteral(strings, raw) { if (!raw) { raw = strings.slice(0); } return Object.freeze(Object.defineProperties(strings, { raw: { value: Object.freeze(raw) } })); }
function _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } }
function _defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if ("value" in descriptor) descriptor.writable = true; Object.defineProperty(target, _toPropertyKey(descriptor.key), descriptor); } }
function _createClass(Constructor, protoProps, staticProps) { if (protoProps) _defineProperties(Constructor.prototype, protoProps); if (staticProps) _defineProperties(Constructor, staticProps); Object.defineProperty(Constructor, "prototype", { writable: false }); return Constructor; }
function _toPropertyKey(t) { var i = _toPrimitive(t, "string"); return "symbol" == _typeof(i) ? i : i + ""; }
function _toPrimitive(t, r) { if ("object" != _typeof(t) || !t) return t; var e = t[Symbol.toPrimitive]; if (void 0 !== e) { var i = e.call(t, r || "default"); if ("object" != _typeof(i)) return i; throw new TypeError("@@toPrimitive must return a primitive value."); } return ("string" === r ? String : Number)(t); }
function _callSuper(t, o, e) { return o = _getPrototypeOf(o), _possibleConstructorReturn(t, _isNativeReflectConstruct() ? Reflect.construct(o, e || [], _getPrototypeOf(t).constructor) : o.apply(t, e)); }
function _possibleConstructorReturn(self, call) { if (call && (_typeof(call) === "object" || typeof call === "function")) { return call; } else if (call !== void 0) { throw new TypeError("Derived constructors may only return object or undefined"); } return _assertThisInitialized(self); }
function _assertThisInitialized(self) { if (self === void 0) { throw new ReferenceError("this hasn't been initialised - super() hasn't been called"); } return self; }
function _isNativeReflectConstruct() { try { var t = !Boolean.prototype.valueOf.call(Reflect.construct(Boolean, [], function () {})); } catch (t) {} return (_isNativeReflectConstruct = function _isNativeReflectConstruct() { return !!t; })(); }
function _getPrototypeOf(o) { _getPrototypeOf = Object.setPrototypeOf ? Object.getPrototypeOf.bind() : function _getPrototypeOf(o) { return o.__proto__ || Object.getPrototypeOf(o); }; return _getPrototypeOf(o); }
function _inherits(subClass, superClass) { if (typeof superClass !== "function" && superClass !== null) { throw new TypeError("Super expression must either be null or a function"); } subClass.prototype = Object.create(superClass && superClass.prototype, { constructor: { value: subClass, writable: true, configurable: true } }); Object.defineProperty(subClass, "prototype", { writable: false }); if (superClass) _setPrototypeOf(subClass, superClass); }
function _setPrototypeOf(o, p) { _setPrototypeOf = Object.setPrototypeOf ? Object.setPrototypeOf.bind() : function _setPrototypeOf(o, p) { o.__proto__ = p; return o; }; return _setPrototypeOf(o, p); }




var smmChatMessage = /*#__PURE__*/function (_DtBase) {
  function smmChatMessage() {
    _classCallCheck(this, smmChatMessage);
    return _callSuper(this, smmChatMessage, arguments);
  }
  _inherits(smmChatMessage, _DtBase);
  return _createClass(smmChatMessage, [{
    key: "_formatDate",
    value: function _formatDate(date) {
      var dateObj = new Date(date);
      var dateString = new Intl.DateTimeFormat('default', {
        month: 'short',
        day: 'numeric'
      }).format(dateObj);
      return dateString;
    }
  }, {
    key: "render",
    value: function render() {
      var classes = {
        incoming: this.incomingMessage,
        outgoing: false,
        'chat-message': true
      };
      return (0,lit__WEBPACK_IMPORTED_MODULE_0__.html)(_templateObject || (_templateObject = _taggedTemplateLiteral(["\n      <div class=\"", "\">\n          <div class=\"chat-message__avatar\">\n            ", "\n          </div>\n        <div class=\"chat-message__body\">\n          <div class=\"chat-message__header\">\n            <div class=\"chat-message__name\">", "</div>\n            <div class=\"chat-message__date\">", "</div>\n          </div>\n          <div class=\"chat-message__text\">", "</div>\n        </div>\n      </div>\n    "])), (0,lit_directives_class_map_js__WEBPACK_IMPORTED_MODULE_2__.classMap)(classes), this.message.avatar ? (0,lit__WEBPACK_IMPORTED_MODULE_0__.html)(_templateObject2 || (_templateObject2 = _taggedTemplateLiteral(["<img src=\"", "\" alt=\"", "\" />"])), this.message.avatar, this.message.comment_author) : (0,lit__WEBPACK_IMPORTED_MODULE_0__.html)(_templateObject3 || (_templateObject3 = _taggedTemplateLiteral(["<dt-icon icon=\"user\" size=\"2em\"></dt-icon>"]))), this.message.comment_author, this._formatDate(this.message.comment_date), this.message.comment_content);
    }
  }], [{
    key: "styles",
    get: function get() {
      return (0,lit__WEBPACK_IMPORTED_MODULE_0__.css)(_templateObject4 || (_templateObject4 = _taggedTemplateLiteral(["\n      :host {\n        --smm-incoming-message-background: var(--gray-1, #919191);\n        --smm-outgoing-message-background: var(--success-color, #4caf50);\n      }\n      .chat-message {\n        display: flex;\n        align-items: flex-end;\n        margin-bottom: 1em;\n        flex-direction: row-reverse;\n      }\n\n      .chat-message__avatar {\n        width: clamp(3em, 5vw, 5em);\n      }\n\n      .chat-message__avatar img {\n        width: 100%;\n        border-radius: 50%;\n      }\n\n      .chat-message__body {\n        max-width: clamp(10em, 52vw, 60%);\n        padding: 1em;\n        border-radius: 1em;\n        /* @todo make this right to left compatible */\n        border-bottom-right-radius: 0;\n        background: var(--smm-outgoing-message-background);\n      }\n\n      .chat-message__header {\n        display: flex;\n        flex-direction: row;\n        justify-content: space-between;\n      }\n\n      .chat-message__name {\n        font-weight: bold;\n        font-size: 1.1em;\n      }\n      .chat-message.incoming {\n        flex-direction: row;\n      }\n\n      .chat-message.incoming .chat-message__body {\n        background: var(--smm-incoming-message-background);\n        /* @todo make this right to left compatible */\n        border-bottom-right-radius: 1em;\n        border-bottom-left-radius: 0;\n      }\n      "])));
    }
  }, {
    key: "properties",
    get: function get() {
      return {
        message: {
          type: Object
        },
        incomingMessage: {
          type: Boolean
        }
      };
    }
  }]);
}(_disciple_tools_web_components__WEBPACK_IMPORTED_MODULE_3__.DtBase);
window.customElements.define("smm-chat-message", smmChatMessage);

/***/ }),

/***/ "./assets/js/chat/chat_window.js":
/*!***************************************!*\
  !*** ./assets/js/chat/chat_window.js ***!
  \***************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   smmChatWindow: () => (/* binding */ smmChatWindow)
/* harmony export */ });
/* harmony import */ var lit__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! lit */ "./node_modules/lit/index.js");
/* harmony import */ var _lit_localize__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! @lit/localize */ "./node_modules/@lit/localize/lit-localize.js");
/* harmony import */ var lit_directives_style_map_js__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! lit/directives/style-map.js */ "./node_modules/lit/directives/style-map.js");
/* harmony import */ var _disciple_tools_web_components__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(/*! @disciple.tools/web-components */ "./node_modules/@disciple.tools/web-components/index.js");
function _typeof(o) { "@babel/helpers - typeof"; return _typeof = "function" == typeof Symbol && "symbol" == typeof Symbol.iterator ? function (o) { return typeof o; } : function (o) { return o && "function" == typeof Symbol && o.constructor === Symbol && o !== Symbol.prototype ? "symbol" : typeof o; }, _typeof(o); }
var _templateObject, _templateObject2, _templateObject3, _templateObject4, _templateObject5, _templateObject6;
function ownKeys(e, r) { var t = Object.keys(e); if (Object.getOwnPropertySymbols) { var o = Object.getOwnPropertySymbols(e); r && (o = o.filter(function (r) { return Object.getOwnPropertyDescriptor(e, r).enumerable; })), t.push.apply(t, o); } return t; }
function _objectSpread(e) { for (var r = 1; r < arguments.length; r++) { var t = null != arguments[r] ? arguments[r] : {}; r % 2 ? ownKeys(Object(t), !0).forEach(function (r) { _defineProperty(e, r, t[r]); }) : Object.getOwnPropertyDescriptors ? Object.defineProperties(e, Object.getOwnPropertyDescriptors(t)) : ownKeys(Object(t)).forEach(function (r) { Object.defineProperty(e, r, Object.getOwnPropertyDescriptor(t, r)); }); } return e; }
function _defineProperty(obj, key, value) { key = _toPropertyKey(key); if (key in obj) { Object.defineProperty(obj, key, { value: value, enumerable: true, configurable: true, writable: true }); } else { obj[key] = value; } return obj; }
function _createForOfIteratorHelper(o, allowArrayLike) { var it = typeof Symbol !== "undefined" && o[Symbol.iterator] || o["@@iterator"]; if (!it) { if (Array.isArray(o) || (it = _unsupportedIterableToArray(o)) || allowArrayLike && o && typeof o.length === "number") { if (it) o = it; var i = 0; var F = function F() {}; return { s: F, n: function n() { if (i >= o.length) return { done: true }; return { done: false, value: o[i++] }; }, e: function e(_e) { throw _e; }, f: F }; } throw new TypeError("Invalid attempt to iterate non-iterable instance.\nIn order to be iterable, non-array objects must have a [Symbol.iterator]() method."); } var normalCompletion = true, didErr = false, err; return { s: function s() { it = it.call(o); }, n: function n() { var step = it.next(); normalCompletion = step.done; return step; }, e: function e(_e2) { didErr = true; err = _e2; }, f: function f() { try { if (!normalCompletion && it["return"] != null) it["return"](); } finally { if (didErr) throw err; } } }; }
function _unsupportedIterableToArray(o, minLen) { if (!o) return; if (typeof o === "string") return _arrayLikeToArray(o, minLen); var n = Object.prototype.toString.call(o).slice(8, -1); if (n === "Object" && o.constructor) n = o.constructor.name; if (n === "Map" || n === "Set") return Array.from(o); if (n === "Arguments" || /^(?:Ui|I)nt(?:8|16|32)(?:Clamped)?Array$/.test(n)) return _arrayLikeToArray(o, minLen); }
function _arrayLikeToArray(arr, len) { if (len == null || len > arr.length) len = arr.length; for (var i = 0, arr2 = new Array(len); i < len; i++) arr2[i] = arr[i]; return arr2; }
function _taggedTemplateLiteral(strings, raw) { if (!raw) { raw = strings.slice(0); } return Object.freeze(Object.defineProperties(strings, { raw: { value: Object.freeze(raw) } })); }
function _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } }
function _defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if ("value" in descriptor) descriptor.writable = true; Object.defineProperty(target, _toPropertyKey(descriptor.key), descriptor); } }
function _createClass(Constructor, protoProps, staticProps) { if (protoProps) _defineProperties(Constructor.prototype, protoProps); if (staticProps) _defineProperties(Constructor, staticProps); Object.defineProperty(Constructor, "prototype", { writable: false }); return Constructor; }
function _toPropertyKey(t) { var i = _toPrimitive(t, "string"); return "symbol" == _typeof(i) ? i : i + ""; }
function _toPrimitive(t, r) { if ("object" != _typeof(t) || !t) return t; var e = t[Symbol.toPrimitive]; if (void 0 !== e) { var i = e.call(t, r || "default"); if ("object" != _typeof(i)) return i; throw new TypeError("@@toPrimitive must return a primitive value."); } return ("string" === r ? String : Number)(t); }
function _callSuper(t, o, e) { return o = _getPrototypeOf(o), _possibleConstructorReturn(t, _isNativeReflectConstruct() ? Reflect.construct(o, e || [], _getPrototypeOf(t).constructor) : o.apply(t, e)); }
function _possibleConstructorReturn(self, call) { if (call && (_typeof(call) === "object" || typeof call === "function")) { return call; } else if (call !== void 0) { throw new TypeError("Derived constructors may only return object or undefined"); } return _assertThisInitialized(self); }
function _assertThisInitialized(self) { if (self === void 0) { throw new ReferenceError("this hasn't been initialised - super() hasn't been called"); } return self; }
function _isNativeReflectConstruct() { try { var t = !Boolean.prototype.valueOf.call(Reflect.construct(Boolean, [], function () {})); } catch (t) {} return (_isNativeReflectConstruct = function _isNativeReflectConstruct() { return !!t; })(); }
function _inherits(subClass, superClass) { if (typeof superClass !== "function" && superClass !== null) { throw new TypeError("Super expression must either be null or a function"); } subClass.prototype = Object.create(superClass && superClass.prototype, { constructor: { value: subClass, writable: true, configurable: true } }); Object.defineProperty(subClass, "prototype", { writable: false }); if (superClass) _setPrototypeOf(subClass, superClass); }
function _setPrototypeOf(o, p) { _setPrototypeOf = Object.setPrototypeOf ? Object.setPrototypeOf.bind() : function _setPrototypeOf(o, p) { o.__proto__ = p; return o; }; return _setPrototypeOf(o, p); }
function _get() { if (typeof Reflect !== "undefined" && Reflect.get) { _get = Reflect.get.bind(); } else { _get = function _get(target, property, receiver) { var base = _superPropBase(target, property); if (!base) return; var desc = Object.getOwnPropertyDescriptor(base, property); if (desc.get) { return desc.get.call(arguments.length < 3 ? target : receiver); } return desc.value; }; } return _get.apply(this, arguments); }
function _superPropBase(object, property) { while (!Object.prototype.hasOwnProperty.call(object, property)) { object = _getPrototypeOf(object); if (object === null) break; } return object; }
function _getPrototypeOf(o) { _getPrototypeOf = Object.setPrototypeOf ? Object.getPrototypeOf.bind() : function _getPrototypeOf(o) { return o.__proto__ || Object.getPrototypeOf(o); }; return _getPrototypeOf(o); }




var smmChatWindow = /*#__PURE__*/function (_DtBase) {
  function smmChatWindow() {
    var _this;
    _classCallCheck(this, smmChatWindow);
    _this = _callSuper(this, smmChatWindow);
    _this.conversation_messages = window.commentsSettings.comments.comments;
    console.log(_this.conversation_messages);
    return _this;
  }
  _inherits(smmChatWindow, _DtBase);
  return _createClass(smmChatWindow, [{
    key: "connectedCallback",
    value: function connectedCallback() {
      _get(_getPrototypeOf(smmChatWindow.prototype), "connectedCallback", this).call(this);
    }
  }, {
    key: "ChatButtonClick",
    value: function ChatButtonClick(e) {
      var messageText = this.shadowRoot.querySelector('textarea').value;
      //We will do something with this later
      console.log(messageText);
      this.shadowRoot.querySelector('textarea').value = '';
    }
  }, {
    key: "claimConvo",
    value: function claimConvo() {
      var _this2 = this;
      var payload = {
        claimed: true,
        claimed_by: this.userid
      };
      API.update_post('smm_conversation', this.convoid, payload).then(function (response) {
        _this2.conversation = response;
        _this2.claimed = true;
      });
    }
  }, {
    key: "unclaimConvo",
    value: function unclaimConvo() {
      var _this3 = this;
      var payload = {
        claimed: false,
        claimed_by: 0
      };
      API.update_post('smm_conversation', this.convoid, payload).then(function (response) {
        _this3.conversation = response;
        _this3.claimed = false;
      });
    }
  }, {
    key: "_moreActions",
    value: function _moreActions() {
      if (this.moreActionOpen) {
        this.moreActionOpen = false;
      } else {
        this.moreActionOpen = true;
      }
    }
  }, {
    key: "_chatWindowFooterRender",
    value: function _chatWindowFooterRender() {
      if (this.claimed) {
        if (this.userid != this.conversation.claimed_by.id) {
          return (0,lit__WEBPACK_IMPORTED_MODULE_0__.html)(_templateObject || (_templateObject = _taggedTemplateLiteral(["\n            <span>This Conversation is claimed by another user</span>\n            <button @click=", ">Claim this Conversation</button>"])), this.claimConvo);
        } else {
          return (0,lit__WEBPACK_IMPORTED_MODULE_0__.html)(_templateObject2 || (_templateObject2 = _taggedTemplateLiteral(["<textarea\n            id=\"smm-chat-input\"\n            name=\"smm-chat-input\"\n            aria-label=\"Chat Response Input\"\n            type=\"text\"\n            ?disabled=", "\n            class=\"text-input\"\n            @change=", "\n            .value=\"", "\"\n          ></textarea>\n          <button class=\"send-button\" @click=", ">Send</button>"])), this.disabled, this.onChange, this.value || '', this.ChatButtonClick);
        }
      } else {
        return (0,lit__WEBPACK_IMPORTED_MODULE_0__.html)(_templateObject3 || (_templateObject3 = _taggedTemplateLiteral(["<button @click=", ">Claim this Conversation</button>"])), this.claimConvo);
      }
    }
  }, {
    key: "render",
    value: function render() {
      var fakeMessageIn = {
        name: 'John Doe',
        avatar: 'https://www.gravatar.com/avatar/205e460b479e2e5b48aec07710c08d50',
        date: '2021-01-01',
        body: 'This is a test message.'
      };
      var fakeMessageOut = {
        name: 'CodeZone',
        avatar: 'https://dt.local/wp-content/plugins/disciple-tools-social-media-manager/assets/logo.svg',
        date: '2021-01-01',
        body: 'This is test reply.'
      };
      var messagesTemplates = [];
      var _iterator = _createForOfIteratorHelper(this.conversation_messages),
        _step;
      try {
        for (_iterator.s(); !(_step = _iterator.n()).done;) {
          var i = _step.value;
          console.log(i);
          messagesTemplates.push((0,lit__WEBPACK_IMPORTED_MODULE_0__.html)(_templateObject5 || (_templateObject5 = _taggedTemplateLiteral(["<smm-chat-message .message=", " incomingMessage></smm-chat-message>"])), i));
        }
      } catch (err) {
        _iterator.e(err);
      } finally {
        _iterator.f();
      }
      var moreActionsStyles = {
        display: this.moreActionOpen ? 'grid' : 'none'
      };
      return (0,lit__WEBPACK_IMPORTED_MODULE_0__.html)(_templateObject4 || (_templateObject4 = _taggedTemplateLiteral(["\n      <div class=\"chat-window\">\n        <div class=\"chat-window__header\">\n          <img src=\"https://www.gravatar.com/avatar/205e460b479e2e5b48aec07710c08d50\" height=\"250px\" width=\"250px\" alt=\"John Smith\" class=\"avatar\"/>\n          <h1 class=\"name\">John Smith</h1>\n          <span class=\"location\">Istanbul, Turkey</span>\n          <span class=\"age\">25 years old</span>\n\n          <div class=\"action-buttons container\">\n              <button>\n                <dt-icon class=\"delete_icon\" icon=\"material-symbols:delete-outline\"></dt-icon>\n              </button>\n              <button>\n                <dt-icon class=\"check_icon\" icon=\"material-symbols:check-small\"></dt-icon>\n              </button>\n              <button>\n                <dt-icon class=\"more_icon\" icon=\"material-symbols:more-vert\" @click=", "></dt-icon>\n              </button>\n              <ul id=\"moreActions\"  style=", ">\n                <li><button @click=", ">Release This Conversation</button></li>\n                <li><button @click=", ">Claim This Conversation for yourself</button></li>\n              </ul>\n          </div>\n\n        </div>\n        <div class=\"conversation\">\n          ", "\n        </div>\n        <div class=\"chat-window__footer\">\n          ", "\n        </div>\n      </div>\n    "])), this._moreActions, (0,lit_directives_style_map_js__WEBPACK_IMPORTED_MODULE_2__.styleMap)(moreActionsStyles), this.unclaimConvo, this.claimConvo, messagesTemplates, this._chatWindowFooterRender());
    }
  }], [{
    key: "styles",
    get: function get() {
      return (0,lit__WEBPACK_IMPORTED_MODULE_0__.css)(_templateObject6 || (_templateObject6 = _taggedTemplateLiteral(["\n      :host {\n      }\n      .chat-window {\n        display: flex;\n        flex-direction: column;\n        height: 100%;\n        width: 100%;\n      }\n      .chat-window__header {\n        flex: 1;\n        display: grid;\n        grid-template-columns: 1fr 2fr 1fr;\n        gap: 0em 1em;\n        border-bottom: 1px solid var(--border-color);\n        line-height: 1em;\n        padding: 1em 0.25em;\n      }\n      .chat-window__header .avatar {\n        width: clamp(3em, 100%, 5em);\n        height: clamp(3em, 100%, 5em);\n        aspect-ratio: 1 / 1;\n        border-radius: 50%;\n        grid-area: 1 / 1 / span 3 / auto;\n        justify-self: flex-start;\n        place-self: center;\n      }\n      .chat-window__header h1 {\n        margin: 0;\n        line-height: 1;\n        font-size: clamp(1.5em, 2vw, 2em);\n        color: var(--primary-color);\n        grid-row: 1;\n        grid-column: 2;\n      }\n\n      .chat-window__header .location {\n        grid-column: 2;\n        grid-row: 2;\n      }\n\n      .chat-window__header .age {\n        grid-column: 2;\n        grid-row: 3;\n      }\n\n      .chat-window__header .action-buttons.container {\n        grid-column: 3;\n        grid-row: span 3;\n        display: flex;\n        gap: 5px;\n        padding: 0.25em;\n        place-self: center;\n      }\n\n      #moreActions {\n        display: none;\n        margin: 0;\n        padding: 0;\n        list-style: none;\n        transform: translate(0, 2.5em);\n        width: 7.5em;\n        position: absolute;\n        background: var(--gray-1);\n      }\n\n      #moreAction.open {\n        display: grid;\n      }\n\n      #moreActions li {\n        display: block;\n        width: 100%;\n        height: 3em;\n      }\n\n      #moreActions li button {\n        width: 100%;\n        height: 100%;\n        display: block;\n      }\n\n      .chat-window__header .action-buttons.container button {\n        width: 2.5em;\n        height: 2.5em;\n        padding: 0;\n      }\n\n      .chat-window__header .action-buttons.container button dt-icon {\n        font-size: clamp(1.5em, 2vw, 2em);\n      }\n\n      .conversation {\n        flex: 10;\n        overflow: auto;\n        padding: 1em 0;\n      }\n      .chat-window__footer {\n        flex: 1 2 0px;\n        border-top: 1px solid var(--border-color);\n        display: grid;\n        grid-template-columns: 10fr 1fr;\n        gap: 10px;\n        padding: 1em 0.5em 1em 1em;\n        place-content: center space-between;\n        place-items: stretch;\n        align-items: center;\n      }\n\n      .chat-window__footer textarea {\n        grid-row-start: 1;\n        grid-column-start: 1;\n        border-radius: 0.25em;\n        border: 1px solid var(--border-color);\n        resize: none;\n        padding: 1em;\n      }\n\n      .chat-window__footer .send-button {\n        background: var(--primary-color);\n        border: none;\n        color: var(--text-color-inverse);\n        height: 3.5em;\n        width: 3.5em;\n        border-radius: 50%;\n        grid-row-start: 1;\n        grid-column-start: 2;\n        justify-self: center;\n      }\n      "])));
    }
  }, {
    key: "properties",
    get: function get() {
      return _objectSpread(_objectSpread({}, _get(_getPrototypeOf(smmChatWindow), "properties", this)), {}, {
        message: {
          type: Object
        },
        open: {
          type: Boolean
        },
        claimed: {
          type: Boolean
        },
        convoid: {
          type: Number
        },
        userid: {
          type: Number
        },
        conversation: {
          type: Object
        },
        conversation_messages: {
          type: Array
        },
        moreActionOpen: {
          type: Boolean
        }
      });
    }
  }]);
}(_disciple_tools_web_components__WEBPACK_IMPORTED_MODULE_3__.DtBase);
window.customElements.define("smm-chat-window", smmChatWindow);

/***/ }),

/***/ "./assets/js/conversation_scripts.js":
/*!*******************************************!*\
  !*** ./assets/js/conversation_scripts.js ***!
  \*******************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony import */ var _disciple_tools_web_components__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! @disciple.tools/web-components */ "./node_modules/@disciple.tools/web-components/index.js");
/* harmony import */ var _convo_list_convo_list_js__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ./convo_list/convo_list.js */ "./assets/js/convo_list/convo_list.js");
/* harmony import */ var _convo_list_convo_list_item_js__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! ./convo_list/convo_list_item.js */ "./assets/js/convo_list/convo_list_item.js");
/* harmony import */ var _convo_list_convo_modal_js__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(/*! ./convo_list/convo_modal.js */ "./assets/js/convo_list/convo_modal.js");
/* harmony import */ var _convo_list_convo_list_search_js__WEBPACK_IMPORTED_MODULE_4__ = __webpack_require__(/*! ./convo_list/convo_list_search.js */ "./assets/js/convo_list/convo_list_search.js");
/* harmony import */ var _chat_chat_window_js__WEBPACK_IMPORTED_MODULE_5__ = __webpack_require__(/*! ./chat/chat_window.js */ "./assets/js/chat/chat_window.js");
/* harmony import */ var _chat_chat_message_js__WEBPACK_IMPORTED_MODULE_6__ = __webpack_require__(/*! ./chat/chat_message.js */ "./assets/js/chat/chat_message.js");

// import "./dt-button/dt-button.js";






// import "./dt-icon.js";

/***/ }),

/***/ "./assets/js/convo_list/convo_list.js":
/*!********************************************!*\
  !*** ./assets/js/convo_list/convo_list.js ***!
  \********************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   conversationList: () => (/* binding */ conversationList)
/* harmony export */ });
/* harmony import */ var lit__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! lit */ "./node_modules/lit/index.js");
/* harmony import */ var lit_directives_repeat_js__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! lit/directives/repeat.js */ "./node_modules/lit/directives/repeat.js");
/* harmony import */ var lit_directives_class_map_js__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! lit/directives/class-map.js */ "./node_modules/lit/directives/class-map.js");
/* harmony import */ var lit_directives_if_defined_js__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(/*! lit/directives/if-defined.js */ "./node_modules/lit/directives/if-defined.js");
/* harmony import */ var _lit_localize__WEBPACK_IMPORTED_MODULE_4__ = __webpack_require__(/*! @lit/localize */ "./node_modules/@lit/localize/lit-localize.js");
/* harmony import */ var _disciple_tools_web_components__WEBPACK_IMPORTED_MODULE_5__ = __webpack_require__(/*! @disciple.tools/web-components */ "./node_modules/@disciple.tools/web-components/index.js");
var _templateObject, _templateObject2, _templateObject3, _templateObject4, _templateObject5, _templateObject6, _templateObject7, _templateObject8, _templateObject9, _templateObject10, _templateObject11, _templateObject12;
function _typeof(o) { "@babel/helpers - typeof"; return _typeof = "function" == typeof Symbol && "symbol" == typeof Symbol.iterator ? function (o) { return typeof o; } : function (o) { return o && "function" == typeof Symbol && o.constructor === Symbol && o !== Symbol.prototype ? "symbol" : typeof o; }, _typeof(o); }
function ownKeys(e, r) { var t = Object.keys(e); if (Object.getOwnPropertySymbols) { var o = Object.getOwnPropertySymbols(e); r && (o = o.filter(function (r) { return Object.getOwnPropertyDescriptor(e, r).enumerable; })), t.push.apply(t, o); } return t; }
function _objectSpread(e) { for (var r = 1; r < arguments.length; r++) { var t = null != arguments[r] ? arguments[r] : {}; r % 2 ? ownKeys(Object(t), !0).forEach(function (r) { _defineProperty(e, r, t[r]); }) : Object.getOwnPropertyDescriptors ? Object.defineProperties(e, Object.getOwnPropertyDescriptors(t)) : ownKeys(Object(t)).forEach(function (r) { Object.defineProperty(e, r, Object.getOwnPropertyDescriptor(t, r)); }); } return e; }
function _taggedTemplateLiteral(strings, raw) { if (!raw) { raw = strings.slice(0); } return Object.freeze(Object.defineProperties(strings, { raw: { value: Object.freeze(raw) } })); }
function _regeneratorRuntime() { "use strict"; /*! regenerator-runtime -- Copyright (c) 2014-present, Facebook, Inc. -- license (MIT): https://github.com/facebook/regenerator/blob/main/LICENSE */ _regeneratorRuntime = function _regeneratorRuntime() { return e; }; var t, e = {}, r = Object.prototype, n = r.hasOwnProperty, o = Object.defineProperty || function (t, e, r) { t[e] = r.value; }, i = "function" == typeof Symbol ? Symbol : {}, a = i.iterator || "@@iterator", c = i.asyncIterator || "@@asyncIterator", u = i.toStringTag || "@@toStringTag"; function define(t, e, r) { return Object.defineProperty(t, e, { value: r, enumerable: !0, configurable: !0, writable: !0 }), t[e]; } try { define({}, ""); } catch (t) { define = function define(t, e, r) { return t[e] = r; }; } function wrap(t, e, r, n) { var i = e && e.prototype instanceof Generator ? e : Generator, a = Object.create(i.prototype), c = new Context(n || []); return o(a, "_invoke", { value: makeInvokeMethod(t, r, c) }), a; } function tryCatch(t, e, r) { try { return { type: "normal", arg: t.call(e, r) }; } catch (t) { return { type: "throw", arg: t }; } } e.wrap = wrap; var h = "suspendedStart", l = "suspendedYield", f = "executing", s = "completed", y = {}; function Generator() {} function GeneratorFunction() {} function GeneratorFunctionPrototype() {} var p = {}; define(p, a, function () { return this; }); var d = Object.getPrototypeOf, v = d && d(d(values([]))); v && v !== r && n.call(v, a) && (p = v); var g = GeneratorFunctionPrototype.prototype = Generator.prototype = Object.create(p); function defineIteratorMethods(t) { ["next", "throw", "return"].forEach(function (e) { define(t, e, function (t) { return this._invoke(e, t); }); }); } function AsyncIterator(t, e) { function invoke(r, o, i, a) { var c = tryCatch(t[r], t, o); if ("throw" !== c.type) { var u = c.arg, h = u.value; return h && "object" == _typeof(h) && n.call(h, "__await") ? e.resolve(h.__await).then(function (t) { invoke("next", t, i, a); }, function (t) { invoke("throw", t, i, a); }) : e.resolve(h).then(function (t) { u.value = t, i(u); }, function (t) { return invoke("throw", t, i, a); }); } a(c.arg); } var r; o(this, "_invoke", { value: function value(t, n) { function callInvokeWithMethodAndArg() { return new e(function (e, r) { invoke(t, n, e, r); }); } return r = r ? r.then(callInvokeWithMethodAndArg, callInvokeWithMethodAndArg) : callInvokeWithMethodAndArg(); } }); } function makeInvokeMethod(e, r, n) { var o = h; return function (i, a) { if (o === f) throw Error("Generator is already running"); if (o === s) { if ("throw" === i) throw a; return { value: t, done: !0 }; } for (n.method = i, n.arg = a;;) { var c = n.delegate; if (c) { var u = maybeInvokeDelegate(c, n); if (u) { if (u === y) continue; return u; } } if ("next" === n.method) n.sent = n._sent = n.arg;else if ("throw" === n.method) { if (o === h) throw o = s, n.arg; n.dispatchException(n.arg); } else "return" === n.method && n.abrupt("return", n.arg); o = f; var p = tryCatch(e, r, n); if ("normal" === p.type) { if (o = n.done ? s : l, p.arg === y) continue; return { value: p.arg, done: n.done }; } "throw" === p.type && (o = s, n.method = "throw", n.arg = p.arg); } }; } function maybeInvokeDelegate(e, r) { var n = r.method, o = e.iterator[n]; if (o === t) return r.delegate = null, "throw" === n && e.iterator["return"] && (r.method = "return", r.arg = t, maybeInvokeDelegate(e, r), "throw" === r.method) || "return" !== n && (r.method = "throw", r.arg = new TypeError("The iterator does not provide a '" + n + "' method")), y; var i = tryCatch(o, e.iterator, r.arg); if ("throw" === i.type) return r.method = "throw", r.arg = i.arg, r.delegate = null, y; var a = i.arg; return a ? a.done ? (r[e.resultName] = a.value, r.next = e.nextLoc, "return" !== r.method && (r.method = "next", r.arg = t), r.delegate = null, y) : a : (r.method = "throw", r.arg = new TypeError("iterator result is not an object"), r.delegate = null, y); } function pushTryEntry(t) { var e = { tryLoc: t[0] }; 1 in t && (e.catchLoc = t[1]), 2 in t && (e.finallyLoc = t[2], e.afterLoc = t[3]), this.tryEntries.push(e); } function resetTryEntry(t) { var e = t.completion || {}; e.type = "normal", delete e.arg, t.completion = e; } function Context(t) { this.tryEntries = [{ tryLoc: "root" }], t.forEach(pushTryEntry, this), this.reset(!0); } function values(e) { if (e || "" === e) { var r = e[a]; if (r) return r.call(e); if ("function" == typeof e.next) return e; if (!isNaN(e.length)) { var o = -1, i = function next() { for (; ++o < e.length;) if (n.call(e, o)) return next.value = e[o], next.done = !1, next; return next.value = t, next.done = !0, next; }; return i.next = i; } } throw new TypeError(_typeof(e) + " is not iterable"); } return GeneratorFunction.prototype = GeneratorFunctionPrototype, o(g, "constructor", { value: GeneratorFunctionPrototype, configurable: !0 }), o(GeneratorFunctionPrototype, "constructor", { value: GeneratorFunction, configurable: !0 }), GeneratorFunction.displayName = define(GeneratorFunctionPrototype, u, "GeneratorFunction"), e.isGeneratorFunction = function (t) { var e = "function" == typeof t && t.constructor; return !!e && (e === GeneratorFunction || "GeneratorFunction" === (e.displayName || e.name)); }, e.mark = function (t) { return Object.setPrototypeOf ? Object.setPrototypeOf(t, GeneratorFunctionPrototype) : (t.__proto__ = GeneratorFunctionPrototype, define(t, u, "GeneratorFunction")), t.prototype = Object.create(g), t; }, e.awrap = function (t) { return { __await: t }; }, defineIteratorMethods(AsyncIterator.prototype), define(AsyncIterator.prototype, c, function () { return this; }), e.AsyncIterator = AsyncIterator, e.async = function (t, r, n, o, i) { void 0 === i && (i = Promise); var a = new AsyncIterator(wrap(t, r, n, o), i); return e.isGeneratorFunction(r) ? a : a.next().then(function (t) { return t.done ? t.value : a.next(); }); }, defineIteratorMethods(g), define(g, u, "Generator"), define(g, a, function () { return this; }), define(g, "toString", function () { return "[object Generator]"; }), e.keys = function (t) { var e = Object(t), r = []; for (var n in e) r.push(n); return r.reverse(), function next() { for (; r.length;) { var t = r.pop(); if (t in e) return next.value = t, next.done = !1, next; } return next.done = !0, next; }; }, e.values = values, Context.prototype = { constructor: Context, reset: function reset(e) { if (this.prev = 0, this.next = 0, this.sent = this._sent = t, this.done = !1, this.delegate = null, this.method = "next", this.arg = t, this.tryEntries.forEach(resetTryEntry), !e) for (var r in this) "t" === r.charAt(0) && n.call(this, r) && !isNaN(+r.slice(1)) && (this[r] = t); }, stop: function stop() { this.done = !0; var t = this.tryEntries[0].completion; if ("throw" === t.type) throw t.arg; return this.rval; }, dispatchException: function dispatchException(e) { if (this.done) throw e; var r = this; function handle(n, o) { return a.type = "throw", a.arg = e, r.next = n, o && (r.method = "next", r.arg = t), !!o; } for (var o = this.tryEntries.length - 1; o >= 0; --o) { var i = this.tryEntries[o], a = i.completion; if ("root" === i.tryLoc) return handle("end"); if (i.tryLoc <= this.prev) { var c = n.call(i, "catchLoc"), u = n.call(i, "finallyLoc"); if (c && u) { if (this.prev < i.catchLoc) return handle(i.catchLoc, !0); if (this.prev < i.finallyLoc) return handle(i.finallyLoc); } else if (c) { if (this.prev < i.catchLoc) return handle(i.catchLoc, !0); } else { if (!u) throw Error("try statement without catch or finally"); if (this.prev < i.finallyLoc) return handle(i.finallyLoc); } } } }, abrupt: function abrupt(t, e) { for (var r = this.tryEntries.length - 1; r >= 0; --r) { var o = this.tryEntries[r]; if (o.tryLoc <= this.prev && n.call(o, "finallyLoc") && this.prev < o.finallyLoc) { var i = o; break; } } i && ("break" === t || "continue" === t) && i.tryLoc <= e && e <= i.finallyLoc && (i = null); var a = i ? i.completion : {}; return a.type = t, a.arg = e, i ? (this.method = "next", this.next = i.finallyLoc, y) : this.complete(a); }, complete: function complete(t, e) { if ("throw" === t.type) throw t.arg; return "break" === t.type || "continue" === t.type ? this.next = t.arg : "return" === t.type ? (this.rval = this.arg = t.arg, this.method = "return", this.next = "end") : "normal" === t.type && e && (this.next = e), y; }, finish: function finish(t) { for (var e = this.tryEntries.length - 1; e >= 0; --e) { var r = this.tryEntries[e]; if (r.finallyLoc === t) return this.complete(r.completion, r.afterLoc), resetTryEntry(r), y; } }, "catch": function _catch(t) { for (var e = this.tryEntries.length - 1; e >= 0; --e) { var r = this.tryEntries[e]; if (r.tryLoc === t) { var n = r.completion; if ("throw" === n.type) { var o = n.arg; resetTryEntry(r); } return o; } } throw Error("illegal catch attempt"); }, delegateYield: function delegateYield(e, r, n) { return this.delegate = { iterator: values(e), resultName: r, nextLoc: n }, "next" === this.method && (this.arg = t), y; } }, e; }
function asyncGeneratorStep(gen, resolve, reject, _next, _throw, key, arg) { try { var info = gen[key](arg); var value = info.value; } catch (error) { reject(error); return; } if (info.done) { resolve(value); } else { Promise.resolve(value).then(_next, _throw); } }
function _asyncToGenerator(fn) { return function () { var self = this, args = arguments; return new Promise(function (resolve, reject) { var gen = fn.apply(self, args); function _next(value) { asyncGeneratorStep(gen, resolve, reject, _next, _throw, "next", value); } function _throw(err) { asyncGeneratorStep(gen, resolve, reject, _next, _throw, "throw", err); } _next(undefined); }); }; }
function _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } }
function _defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if ("value" in descriptor) descriptor.writable = true; Object.defineProperty(target, _toPropertyKey(descriptor.key), descriptor); } }
function _createClass(Constructor, protoProps, staticProps) { if (protoProps) _defineProperties(Constructor.prototype, protoProps); if (staticProps) _defineProperties(Constructor, staticProps); Object.defineProperty(Constructor, "prototype", { writable: false }); return Constructor; }
function _callSuper(t, o, e) { return o = _getPrototypeOf(o), _possibleConstructorReturn(t, _isNativeReflectConstruct() ? Reflect.construct(o, e || [], _getPrototypeOf(t).constructor) : o.apply(t, e)); }
function _possibleConstructorReturn(self, call) { if (call && (_typeof(call) === "object" || typeof call === "function")) { return call; } else if (call !== void 0) { throw new TypeError("Derived constructors may only return object or undefined"); } return _assertThisInitialized(self); }
function _assertThisInitialized(self) { if (self === void 0) { throw new ReferenceError("this hasn't been initialised - super() hasn't been called"); } return self; }
function _isNativeReflectConstruct() { try { var t = !Boolean.prototype.valueOf.call(Reflect.construct(Boolean, [], function () {})); } catch (t) {} return (_isNativeReflectConstruct = function _isNativeReflectConstruct() { return !!t; })(); }
function _inherits(subClass, superClass) { if (typeof superClass !== "function" && superClass !== null) { throw new TypeError("Super expression must either be null or a function"); } subClass.prototype = Object.create(superClass && superClass.prototype, { constructor: { value: subClass, writable: true, configurable: true } }); Object.defineProperty(subClass, "prototype", { writable: false }); if (superClass) _setPrototypeOf(subClass, superClass); }
function _setPrototypeOf(o, p) { _setPrototypeOf = Object.setPrototypeOf ? Object.setPrototypeOf.bind() : function _setPrototypeOf(o, p) { o.__proto__ = p; return o; }; return _setPrototypeOf(o, p); }
function _get() { if (typeof Reflect !== "undefined" && Reflect.get) { _get = Reflect.get.bind(); } else { _get = function _get(target, property, receiver) { var base = _superPropBase(target, property); if (!base) return; var desc = Object.getOwnPropertyDescriptor(base, property); if (desc.get) { return desc.get.call(arguments.length < 3 ? target : receiver); } return desc.value; }; } return _get.apply(this, arguments); }
function _superPropBase(object, property) { while (!Object.prototype.hasOwnProperty.call(object, property)) { object = _getPrototypeOf(object); if (object === null) break; } return object; }
function _getPrototypeOf(o) { _getPrototypeOf = Object.setPrototypeOf ? Object.getPrototypeOf.bind() : function _getPrototypeOf(o) { return o.__proto__ || Object.getPrototypeOf(o); }; return _getPrototypeOf(o); }
function _defineProperty(obj, key, value) { key = _toPropertyKey(key); if (key in obj) { Object.defineProperty(obj, key, { value: value, enumerable: true, configurable: true, writable: true }); } else { obj[key] = value; } return obj; }
function _toPropertyKey(t) { var i = _toPrimitive(t, "string"); return "symbol" == _typeof(i) ? i : i + ""; }
function _toPrimitive(t, r) { if ("object" != _typeof(t) || !t) return t; var e = t[Symbol.toPrimitive]; if (void 0 !== e) { var i = e.call(t, r || "default"); if ("object" != _typeof(i)) return i; throw new TypeError("@@toPrimitive must return a primitive value."); } return ("string" === r ? String : Number)(t); }







var conversationList = /*#__PURE__*/function (_DtBase) {
  function conversationList() {
    var _this;
    _classCallCheck(this, conversationList);
    _this = _callSuper(this, conversationList);
    //this has to be an arrow function so that the this keyword is bound to the component class
    _defineProperty(_this, "_handleSearch", /*#__PURE__*/function () {
      var _ref = _asyncToGenerator( /*#__PURE__*/_regeneratorRuntime().mark(function _callee(e) {
        var query, response;
        return _regeneratorRuntime().wrap(function _callee$(_context) {
          while (1) switch (_context.prev = _context.next) {
            case 0:
              if (!(e.target !== _this)) {
                _context.next = 2;
                break;
              }
              return _context.abrupt("return");
            case 2:
              query = {
                "sort": "last_modified"
              };
              if (e.detail.value !== "") {
                query["text"] = e.detail.value;
              }
              if (_this.showOnlyUnclaimed && !_this.showOnlyClaimed) {
                query["claimed"] = [false];
              }
              if (_this.showOnlyClaimed && !_this.showOnlyUnclaimed) {
                query["claimed"] = [true];
              }
              if (_this.showOnlyUnclaimed && _this.showOnlyClaimed) {
                console.log('You can\'t show only unclaimed and only claimed at the same time. Remove one of the attributes to the <smm-conversation-list> element.');
              }
              if (_this.showOnlyMyConversations) {
                query["claimed_by"] = [_this.userid];
              }
              if (_this.showOnlyContactConversations) {
                query["contacts"] = [_this.showOnlyContactConversations];
              }
              _context.next = 11;
              return window.makeRequestOnPosts('GET', "disciple-tools-conversations", query);
            case 11:
              response = _context.sent;
              console.log(response);
              _this.conversations = response.posts;
            case 14:
            case "end":
              return _context.stop();
          }
        }, _callee);
      }));
      return function (_x) {
        return _ref.apply(this, arguments);
      };
    }());
    _this.offset = 0;
    _this.perPage = 6;
    return _this;
  }
  _inherits(conversationList, _DtBase);
  return _createClass(conversationList, [{
    key: "connectedCallback",
    value: function connectedCallback() {
      _get(_getPrototypeOf(conversationList.prototype), "connectedCallback", this).call(this);
      window.addEventListener('search', this._handleSearch);
    }
  }, {
    key: "disconnectedCallback",
    value: function disconnectedCallback() {
      window.removeEventListener('search', this._handleSearch);
      _get(_getPrototypeOf(conversationList.prototype), "disconnectedCallback", this).call(this);
    }
  }, {
    key: "_leftarrowSVG",
    value: function _leftarrowSVG() {
      return (0,lit__WEBPACK_IMPORTED_MODULE_0__.svg)(_templateObject || (_templateObject = _taggedTemplateLiteral(["<svg width=\"5\" height=\"8\" viewBox=\"0 0 5 8\" fill=\"none\" xmlns=\"http://www.w3.org/2000/svg\"><path d=\"M1.6333 0.46666L4.69997 3.53333C4.76663 3.59999 4.81375 3.67221 4.8413 3.74999C4.8693 3.82777 4.8833 3.9111 4.8833 3.99999C4.8833 4.08888 4.8693 4.17222 4.8413 4.24999C4.81375 4.32777 4.76663 4.39999 4.69997 4.46666L1.6333 7.53333C1.51108 7.65555 1.35552 7.71666 1.16663 7.71666C0.977745 7.71666 0.82219 7.65555 0.699967 7.53333C0.577745 7.4111 0.516634 7.25555 0.516634 7.06666C0.516634 6.87777 0.577746 6.72221 0.699967 6.59999L3.29997 3.99999L0.699968 1.39999C0.577746 1.27777 0.516635 1.12221 0.516635 0.933325C0.516635 0.744437 0.577746 0.588882 0.699968 0.46666C0.82219 0.344437 0.977746 0.283325 1.16663 0.283325C1.35552 0.283325 1.51108 0.344437 1.6333 0.46666Z\" fill=\"var(--gray-1, #B7B7B7)\"/></svg>"])));
    }
  }, {
    key: "_rightarrowSVG",
    value: function _rightarrowSVG() {
      return (0,lit__WEBPACK_IMPORTED_MODULE_0__.svg)(_templateObject2 || (_templateObject2 = _taggedTemplateLiteral(["<svg width=\"5\" height=\"8\" viewBox=\"0 0 5 8\" fill=\"none\" xmlns=\"http://www.w3.org/2000/svg\"><path d=\"M3.3667 7.53334L0.300032 4.46667C0.233366 4.40001 0.186255 4.32779 0.158699 4.25001C0.130699 4.17223 0.116699 4.0889 0.116699 4.00001C0.116699 3.91112 0.130699 3.82778 0.158699 3.75001C0.186255 3.67223 0.233366 3.60001 0.300032 3.53334L3.3667 0.466674C3.48892 0.344451 3.64448 0.28334 3.83337 0.28334C4.02225 0.28334 4.17781 0.344451 4.30003 0.466674C4.42225 0.588896 4.48337 0.744452 4.48337 0.93334C4.48337 1.12223 4.42225 1.27779 4.30003 1.40001L1.70003 4.00001L4.30003 6.60001C4.42225 6.72223 4.48337 6.87779 4.48337 7.06667C4.48337 7.25556 4.42225 7.41112 4.30003 7.53334C4.17781 7.65556 4.02225 7.71667 3.83337 7.71667C3.64448 7.71667 3.48892 7.65556 3.3667 7.53334Z\" fill=\"var(--gray-1, #B7B7B7)\"/></svg>"])));
    }
  }, {
    key: "_prevArrowSVG",
    value: function _prevArrowSVG() {
      if (this.RTL) {
        return this._leftarrowSVG();
      }
      return this._rightarrowSVG();
    }
  }, {
    key: "_nextArrowSVG",
    value: function _nextArrowSVG() {
      if (this.RTL) {
        return this._rightarrowSVG();
      }
      return this._leftarrowSVG();
    }
  }, {
    key: "_paginationRender",
    value: function _paginationRender() {
      var _this2 = this;
      var pages = Math.ceil(this.conversations.length / this.perPage);
      if (pages > 1) {
        if (this.offset === 0) {
          return (0,lit__WEBPACK_IMPORTED_MODULE_0__.html)(_templateObject3 || (_templateObject3 = _taggedTemplateLiteral(["\n          ", "\n          <button class=\"button small\" @click=", ">", "</button>"])), this._paginationButtonsRender(pages), function () {
            return _this2.offset = _this2.offset + _this2.perPage;
          }, this._nextArrowSVG());
        }
        if (this.offset === (pages - 1) * this.perPage) {
          return (0,lit__WEBPACK_IMPORTED_MODULE_0__.html)(_templateObject4 || (_templateObject4 = _taggedTemplateLiteral(["\n        <button class=\"button small\" @click=", ">", "</button>\n        ", ""])), function () {
            return _this2.offset = _this2.offset - _this2.perPage;
          }, this._prevArrowSVG(), this._paginationButtonsRender(pages));
        }
        return (0,lit__WEBPACK_IMPORTED_MODULE_0__.html)(_templateObject5 || (_templateObject5 = _taggedTemplateLiteral(["\n      <button class=\"button small\" @click=", ">", "</button>\n      ", "\n      <button class=\"button small\" @click=", ">", "</button>"])), function () {
          return _this2.offset = _this2.offset - _this2.perPage;
        }, this._prevArrowSVG(), this._paginationButtonsRender(pages), function () {
          return _this2.offset = _this2.offset + _this2.perPage;
        }, this._nextArrowSVG());
      } else {
        return (0,lit__WEBPACK_IMPORTED_MODULE_0__.html)(_templateObject6 || (_templateObject6 = _taggedTemplateLiteral([""])));
      }
    }
  }, {
    key: "_paginationButtonsRender",
    value: function _paginationButtonsRender(pages) {
      var _this3 = this;
      var buttons = [];
      var _loop = function _loop(i) {
        var classes = {
          button: true,
          small: true,
          active: _this3.offset === i * _this3.perPage ? true : false
        };
        buttons.push((0,lit__WEBPACK_IMPORTED_MODULE_0__.html)(_templateObject8 || (_templateObject8 = _taggedTemplateLiteral(["<button class=\"", "\" @click=", ">", "</button>"])), (0,lit_directives_class_map_js__WEBPACK_IMPORTED_MODULE_2__.classMap)(classes), function () {
          return _this3.offset = i * _this3.perPage;
        }, i + 1));
      };
      for (var i = 0; i < pages; i++) {
        _loop(i);
      }
      return (0,lit__WEBPACK_IMPORTED_MODULE_0__.html)(_templateObject7 || (_templateObject7 = _taggedTemplateLiteral(["", ""])), buttons);
    }
  }, {
    key: "_headerRender",
    value: function _headerRender() {
      return (0,lit__WEBPACK_IMPORTED_MODULE_0__.html)(_templateObject9 || (_templateObject9 = _taggedTemplateLiteral(["\n      <span class=\"smm-list-header-text\">\n      <smm-search id=\"convoListSearch\" name=\"convoListSearch\" value=\"\" type=\"text\" requiredmessage=\"\" privatelabel=\"\" onchange=\"\" internals-valid=\"\" aria-invalid=\"false\"></smm-search>\n      </span>\n      "])));
    }
  }, {
    key: "render",
    value: function render() {
      var _this4 = this;
      console.log(this.conversations);
      return (0,lit__WEBPACK_IMPORTED_MODULE_0__.html)(_templateObject10 || (_templateObject10 = _taggedTemplateLiteral(["\n      <div class=\"smm-list-header\">\n        ", "\n      </div>\n      <ul class=\"smm-conversation-list\">\n      ", "\n      </ul>\n      <span class=\"smm-list-pagination\">\n        ", "\n      </span>\n    "])), !this.showOnlyCurrentConversation ? this._headerRender() : "", (0,lit_directives_repeat_js__WEBPACK_IMPORTED_MODULE_1__.repeat)(this.conversations, function (conversation) {
        return conversation.ID;
      }, function (conversation, index) {
        return _this4.offset <= index && index < _this4.offset + _this4.perPage ? (0,lit__WEBPACK_IMPORTED_MODULE_0__.html)(_templateObject11 || (_templateObject11 = _taggedTemplateLiteral(["\n        <li><smm-list-item .conversation=", " userid=", "></smm-list-item></li>\n        "])), conversation, _this4.userid) : "";
      }), this._paginationRender());
    }
  }], [{
    key: "properties",
    get: function get() {
      return _objectSpread(_objectSpread({}, _get(_getPrototypeOf(conversationList), "properties", this)), {}, {
        conversations: {
          type: Array
        },
        offset: {
          type: Number
        },
        perPage: {
          type: Number
        },
        userid: {
          type: Number
        },
        showOnlyUnclaimed: {
          type: Boolean
        },
        showOnlyClaimed: {
          type: Boolean
        },
        showOnlyMyConversations: {
          type: Boolean
        },
        showOnlyContactConversations: {
          type: Number
        },
        showOnlyCurrentConversation: {
          type: Boolean
        }
      });
    }
  }, {
    key: "styles",
    get: function get() {
      return (0,lit__WEBPACK_IMPORTED_MODULE_0__.css)(_templateObject12 || (_templateObject12 = _taggedTemplateLiteral(["\n      .smm-conversation-list {\n          list-style: none;\n          margin: 0;\n          padding: 0;\n          border: 1px solid #E6E6E6;\n      }\n      button {\n        border: none;\n        background: none;\n        cursor: pointer;\n        color: var(--gray-1, #B7B7B7);\n        font-size: 1em;\n        padding: .25em 0.5em;\n      }\n\n      button svg {\n        display: block;\n        height: 1em;\n        width: 0.4em;\n      }\n\n      button.active {\n        background: var(--surface-0, e2e2e2);\n        color: var(--text-color, #0a0a0a);\n        border-radius: 5px;\n      }\n      .smm-list-pagination {\n        display: flex;\n        justify-content: center;\n        font-size: 1.5rem;\n      }\n    "])));
    }
  }]);
}(_disciple_tools_web_components__WEBPACK_IMPORTED_MODULE_5__.DtBase);
customElements.define("smm-conversation-list", conversationList);

/***/ }),

/***/ "./assets/js/convo_list/convo_list_item.js":
/*!*************************************************!*\
  !*** ./assets/js/convo_list/convo_list_item.js ***!
  \*************************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   conversationListItem: () => (/* binding */ conversationListItem)
/* harmony export */ });
/* harmony import */ var lit__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! lit */ "./node_modules/lit/index.js");
/* harmony import */ var lit_directives_class_map_js__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! lit/directives/class-map.js */ "./node_modules/lit/directives/class-map.js");
/* harmony import */ var lit_directives_if_defined_js__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! lit/directives/if-defined.js */ "./node_modules/lit/directives/if-defined.js");
/* harmony import */ var _disciple_tools_web_components__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(/*! @disciple.tools/web-components */ "./node_modules/@disciple.tools/web-components/index.js");
function _typeof(o) { "@babel/helpers - typeof"; return _typeof = "function" == typeof Symbol && "symbol" == typeof Symbol.iterator ? function (o) { return typeof o; } : function (o) { return o && "function" == typeof Symbol && o.constructor === Symbol && o !== Symbol.prototype ? "symbol" : typeof o; }, _typeof(o); }
var _templateObject, _templateObject2;
function ownKeys(e, r) { var t = Object.keys(e); if (Object.getOwnPropertySymbols) { var o = Object.getOwnPropertySymbols(e); r && (o = o.filter(function (r) { return Object.getOwnPropertyDescriptor(e, r).enumerable; })), t.push.apply(t, o); } return t; }
function _objectSpread(e) { for (var r = 1; r < arguments.length; r++) { var t = null != arguments[r] ? arguments[r] : {}; r % 2 ? ownKeys(Object(t), !0).forEach(function (r) { _defineProperty(e, r, t[r]); }) : Object.getOwnPropertyDescriptors ? Object.defineProperties(e, Object.getOwnPropertyDescriptors(t)) : ownKeys(Object(t)).forEach(function (r) { Object.defineProperty(e, r, Object.getOwnPropertyDescriptor(t, r)); }); } return e; }
function _defineProperty(obj, key, value) { key = _toPropertyKey(key); if (key in obj) { Object.defineProperty(obj, key, { value: value, enumerable: true, configurable: true, writable: true }); } else { obj[key] = value; } return obj; }
function _taggedTemplateLiteral(strings, raw) { if (!raw) { raw = strings.slice(0); } return Object.freeze(Object.defineProperties(strings, { raw: { value: Object.freeze(raw) } })); }
function _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } }
function _defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if ("value" in descriptor) descriptor.writable = true; Object.defineProperty(target, _toPropertyKey(descriptor.key), descriptor); } }
function _createClass(Constructor, protoProps, staticProps) { if (protoProps) _defineProperties(Constructor.prototype, protoProps); if (staticProps) _defineProperties(Constructor, staticProps); Object.defineProperty(Constructor, "prototype", { writable: false }); return Constructor; }
function _toPropertyKey(t) { var i = _toPrimitive(t, "string"); return "symbol" == _typeof(i) ? i : i + ""; }
function _toPrimitive(t, r) { if ("object" != _typeof(t) || !t) return t; var e = t[Symbol.toPrimitive]; if (void 0 !== e) { var i = e.call(t, r || "default"); if ("object" != _typeof(i)) return i; throw new TypeError("@@toPrimitive must return a primitive value."); } return ("string" === r ? String : Number)(t); }
function _callSuper(t, o, e) { return o = _getPrototypeOf(o), _possibleConstructorReturn(t, _isNativeReflectConstruct() ? Reflect.construct(o, e || [], _getPrototypeOf(t).constructor) : o.apply(t, e)); }
function _possibleConstructorReturn(self, call) { if (call && (_typeof(call) === "object" || typeof call === "function")) { return call; } else if (call !== void 0) { throw new TypeError("Derived constructors may only return object or undefined"); } return _assertThisInitialized(self); }
function _assertThisInitialized(self) { if (self === void 0) { throw new ReferenceError("this hasn't been initialised - super() hasn't been called"); } return self; }
function _isNativeReflectConstruct() { try { var t = !Boolean.prototype.valueOf.call(Reflect.construct(Boolean, [], function () {})); } catch (t) {} return (_isNativeReflectConstruct = function _isNativeReflectConstruct() { return !!t; })(); }
function _inherits(subClass, superClass) { if (typeof superClass !== "function" && superClass !== null) { throw new TypeError("Super expression must either be null or a function"); } subClass.prototype = Object.create(superClass && superClass.prototype, { constructor: { value: subClass, writable: true, configurable: true } }); Object.defineProperty(subClass, "prototype", { writable: false }); if (superClass) _setPrototypeOf(subClass, superClass); }
function _setPrototypeOf(o, p) { _setPrototypeOf = Object.setPrototypeOf ? Object.setPrototypeOf.bind() : function _setPrototypeOf(o, p) { o.__proto__ = p; return o; }; return _setPrototypeOf(o, p); }
function _get() { if (typeof Reflect !== "undefined" && Reflect.get) { _get = Reflect.get.bind(); } else { _get = function _get(target, property, receiver) { var base = _superPropBase(target, property); if (!base) return; var desc = Object.getOwnPropertyDescriptor(base, property); if (desc.get) { return desc.get.call(arguments.length < 3 ? target : receiver); } return desc.value; }; } return _get.apply(this, arguments); }
function _superPropBase(object, property) { while (!Object.prototype.hasOwnProperty.call(object, property)) { object = _getPrototypeOf(object); if (object === null) break; } return object; }
function _getPrototypeOf(o) { _getPrototypeOf = Object.setPrototypeOf ? Object.getPrototypeOf.bind() : function _getPrototypeOf(o) { return o.__proto__ || Object.getPrototypeOf(o); }; return _getPrototypeOf(o); }




var conversationListItem = /*#__PURE__*/function (_DtBase) {
  function conversationListItem() {
    _classCallCheck(this, conversationListItem);
    return _callSuper(this, conversationListItem);
  }
  _inherits(conversationListItem, _DtBase);
  return _createClass(conversationListItem, [{
    key: "connectedCallback",
    value: function connectedCallback() {
      _get(_getPrototypeOf(conversationListItem.prototype), "connectedCallback", this).call(this);
      this.claimed = this.conversation.claimed;
    }
  }, {
    key: "_formatDate",
    value: function _formatDate() {
      var dateObj = new Date(this.conversation.post_date.formatted);
      var dateString = new Intl.DateTimeFormat('default', {
        month: 'short',
        day: 'numeric'
      }).format(dateObj);
      return dateString;
    }
  }, {
    key: "render",
    value: function render() {
      return (0,lit__WEBPACK_IMPORTED_MODULE_0__.html)(_templateObject || (_templateObject = _taggedTemplateLiteral(["<div class=\"line-container\">\n      <div class=\"name\">", "</div>\n      <div class=\"mid-line-container\">\n        <div class=\"date\"><span>", "</span></div>\n        <div class=\"platform\">", "</div>\n      </div>\n\n      <smm-conversation-modal title=\"\" context=\"default\" ?claimed=", " convoid=\"", "\" userid=", " conversation=\"", "\" buttonclass=\"{&quot;alert&quot;:true}\" buttonstyle=\"{&quot;padding&quot;:&quot;40px&quot;}\">\n        <span slot=\"content\">Test</span>\n        <span slot=\"openButton\">\n          View Conversation\n        </span>\n    </smm-conversation-modal>\n    </div>"])), this.conversation.name, this._formatDate(), this.conversation.platform, this.claimed, this.conversation.ID, this.userid, JSON.stringify(this.conversation));
    }
  }], [{
    key: "properties",
    get: function get() {
      return _objectSpread(_objectSpread({}, _get(_getPrototypeOf(conversationListItem), "properties", this)), {}, {
        conversation: {
          type: Array
        },
        claimed: {
          type: Boolean
        },
        userid: {
          type: Number
        }
      });
    }
  }, {
    key: "styles",
    get: function get() {
      return (0,lit__WEBPACK_IMPORTED_MODULE_0__.css)(_templateObject2 || (_templateObject2 = _taggedTemplateLiteral(["\n      :host {\n        --dt-modal-button-background: var(--primary-color);\n        --dt-modal-button-opener-background: var(--primary-color);\n        --dt-modal-button-color: #FFFFFF;\n        --dt-button-font-weight: 100;\n        --dt-button-padding-y: 0em;\n        --dt-button-padding-y: 0.15em;\n        --dt-button-padding-x: 1em;\n        --dt-button-border-radius: 0.25em;\n        --dt-button-font-size: 1em;\n        color: currentcolor;\n        display: block;\n        container-type: inline-size;\n        container-name: line-container;\n      }\n\n      .line-container {\n        display: grid;\n        grid-template-columns: 1.5fr .75fr .75fr;\n        gap: 1em 0.35em;\n        place-items: center;\n        border-bottom: 1px solid rgb(230, 230, 230);\n        padding: 1em 0;\n        margin: 0 0.5em;\n      }\n\n      .mid-line-container {\n        display: flex;\n        flex-flow: column wrap;\n        align-items: center;\n        height: 100%;\n        justify-content: space-around;\n      }\n\n      .name {\n        font-weight: bold;\n      }\n\n      .date {\n        font-size: .75em;\n        align-content: center;\n      }\n\n      .date span {\n        background: var(--smm-list-date-background, #F0F0F0);\n        border-radius: .25em;\n        padding: .5em;\n      }\n\n      .platform {\n        font-size: .75em;\n      }\n      /* dt-button {\n        flex: 1;\n      } */\n\n      @container line-container (min-width: 500px) {\n        .line-container {\n          grid-template-columns: 1fr 1fr 1fr;\n        }\n\n        .mid-line-container {\n          flex-flow: row;\n          width: 100%;\n          justify-content: space-evenly;\n        }\n      }\n    "])));
    }
  }]);
}(_disciple_tools_web_components__WEBPACK_IMPORTED_MODULE_3__.DtBase);
customElements.define("smm-list-item", conversationListItem);

/***/ }),

/***/ "./assets/js/convo_list/convo_list_search.js":
/*!***************************************************!*\
  !*** ./assets/js/convo_list/convo_list_search.js ***!
  \***************************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   smmSearch: () => (/* binding */ smmSearch)
/* harmony export */ });
/* harmony import */ var lit__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! lit */ "./node_modules/lit/index.js");
/* harmony import */ var _disciple_tools_web_components__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! @disciple.tools/web-components */ "./node_modules/@disciple.tools/web-components/index.js");
function _typeof(o) { "@babel/helpers - typeof"; return _typeof = "function" == typeof Symbol && "symbol" == typeof Symbol.iterator ? function (o) { return typeof o; } : function (o) { return o && "function" == typeof Symbol && o.constructor === Symbol && o !== Symbol.prototype ? "symbol" : typeof o; }, _typeof(o); }
var _templateObject, _templateObject2;
function ownKeys(e, r) { var t = Object.keys(e); if (Object.getOwnPropertySymbols) { var o = Object.getOwnPropertySymbols(e); r && (o = o.filter(function (r) { return Object.getOwnPropertyDescriptor(e, r).enumerable; })), t.push.apply(t, o); } return t; }
function _objectSpread(e) { for (var r = 1; r < arguments.length; r++) { var t = null != arguments[r] ? arguments[r] : {}; r % 2 ? ownKeys(Object(t), !0).forEach(function (r) { _defineProperty(e, r, t[r]); }) : Object.getOwnPropertyDescriptors ? Object.defineProperties(e, Object.getOwnPropertyDescriptors(t)) : ownKeys(Object(t)).forEach(function (r) { Object.defineProperty(e, r, Object.getOwnPropertyDescriptor(t, r)); }); } return e; }
function _defineProperty(obj, key, value) { key = _toPropertyKey(key); if (key in obj) { Object.defineProperty(obj, key, { value: value, enumerable: true, configurable: true, writable: true }); } else { obj[key] = value; } return obj; }
function _taggedTemplateLiteral(strings, raw) { if (!raw) { raw = strings.slice(0); } return Object.freeze(Object.defineProperties(strings, { raw: { value: Object.freeze(raw) } })); }
function _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } }
function _defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if ("value" in descriptor) descriptor.writable = true; Object.defineProperty(target, _toPropertyKey(descriptor.key), descriptor); } }
function _createClass(Constructor, protoProps, staticProps) { if (protoProps) _defineProperties(Constructor.prototype, protoProps); if (staticProps) _defineProperties(Constructor, staticProps); Object.defineProperty(Constructor, "prototype", { writable: false }); return Constructor; }
function _toPropertyKey(t) { var i = _toPrimitive(t, "string"); return "symbol" == _typeof(i) ? i : i + ""; }
function _toPrimitive(t, r) { if ("object" != _typeof(t) || !t) return t; var e = t[Symbol.toPrimitive]; if (void 0 !== e) { var i = e.call(t, r || "default"); if ("object" != _typeof(i)) return i; throw new TypeError("@@toPrimitive must return a primitive value."); } return ("string" === r ? String : Number)(t); }
function _callSuper(t, o, e) { return o = _getPrototypeOf(o), _possibleConstructorReturn(t, _isNativeReflectConstruct() ? Reflect.construct(o, e || [], _getPrototypeOf(t).constructor) : o.apply(t, e)); }
function _possibleConstructorReturn(self, call) { if (call && (_typeof(call) === "object" || typeof call === "function")) { return call; } else if (call !== void 0) { throw new TypeError("Derived constructors may only return object or undefined"); } return _assertThisInitialized(self); }
function _assertThisInitialized(self) { if (self === void 0) { throw new ReferenceError("this hasn't been initialised - super() hasn't been called"); } return self; }
function _isNativeReflectConstruct() { try { var t = !Boolean.prototype.valueOf.call(Reflect.construct(Boolean, [], function () {})); } catch (t) {} return (_isNativeReflectConstruct = function _isNativeReflectConstruct() { return !!t; })(); }
function _inherits(subClass, superClass) { if (typeof superClass !== "function" && superClass !== null) { throw new TypeError("Super expression must either be null or a function"); } subClass.prototype = Object.create(superClass && superClass.prototype, { constructor: { value: subClass, writable: true, configurable: true } }); Object.defineProperty(subClass, "prototype", { writable: false }); if (superClass) _setPrototypeOf(subClass, superClass); }
function _setPrototypeOf(o, p) { _setPrototypeOf = Object.setPrototypeOf ? Object.setPrototypeOf.bind() : function _setPrototypeOf(o, p) { o.__proto__ = p; return o; }; return _setPrototypeOf(o, p); }
function _get() { if (typeof Reflect !== "undefined" && Reflect.get) { _get = Reflect.get.bind(); } else { _get = function _get(target, property, receiver) { var base = _superPropBase(target, property); if (!base) return; var desc = Object.getOwnPropertyDescriptor(base, property); if (desc.get) { return desc.get.call(arguments.length < 3 ? target : receiver); } return desc.value; }; } return _get.apply(this, arguments); }
function _superPropBase(object, property) { while (!Object.prototype.hasOwnProperty.call(object, property)) { object = _getPrototypeOf(object); if (object === null) break; } return object; }
function _getPrototypeOf(o) { _getPrototypeOf = Object.setPrototypeOf ? Object.getPrototypeOf.bind() : function _getPrototypeOf(o) { return o.__proto__ || Object.getPrototypeOf(o); }; return _getPrototypeOf(o); }


var smmSearch = /*#__PURE__*/function (_DtText) {
  function smmSearch() {
    var _this;
    _classCallCheck(this, smmSearch);
    _this = _callSuper(this, smmSearch);
    _this.placeholder = "Search";
    return _this;
  }
  _inherits(smmSearch, _DtText);
  return _createClass(smmSearch, [{
    key: "search",
    value: function search(e) {
      var input = e.target;
      if (input.value === this.value) {
        return;
      } else {
        this.value = input.value;
      }
      var event = new CustomEvent('search', {
        detail: {
          value: this.value
        },
        bubbles: true,
        composed: true
      });
      this.dispatchEvent(event);
    }
  }, {
    key: "render",
    value: function render() {
      var _this2 = this;
      return (0,lit__WEBPACK_IMPORTED_MODULE_0__.html)(_templateObject || (_templateObject = _taggedTemplateLiteral(["\n    <div class=\"search\">\n        <input\n          class=\"search_input\"\n          value=\"", "\"\n          placeholder=\"", "\"\n          @change=\"", "\"\n        />\n        <dt-icon\n          class=\"search_icon\"\n          icon=\"ic:outline-search\"\n          @click=\"", "\"\n        ></dt-icon>\n      </div>"])), this.value, this.placeholder, function (e) {
        return _this2.search(e);
      }, this.search);
    }
  }], [{
    key: "properties",
    get: function get() {
      return _objectSpread(_objectSpread({}, _get(_getPrototypeOf(smmSearch), "properties", this)), {}, {
        value: {
          type: String
        },
        placeholder: {
          type: String
        }
      });
    }
  }, {
    key: "styles",
    get: function get() {
      return [_get(_getPrototypeOf(smmSearch), "styles", this), (0,lit__WEBPACK_IMPORTED_MODULE_0__.css)(_templateObject2 || (_templateObject2 = _taggedTemplateLiteral(["\n      :host {\n        --dt-text-background-color: var(--surface-1);\n        --dt-text-border-color: none;\n        --dt-form-padding: 0 1em;\n      }\n      .search {\n        display: flex;\n        align-items: center;\n        height: 3rem;\n      }\n\n      .search_input {\n        flex: 1;\n        height: 100%;\n      }\n\n      .search_icon {\n        width: 2.5rem;\n        height: 100%;\n        text-align: center;\n        font-size: 2rem;\n      }\n    "])))];
    }
  }]);
}(_disciple_tools_web_components__WEBPACK_IMPORTED_MODULE_1__.DtText);
window.customElements.define("smm-search", smmSearch);

/***/ }),

/***/ "./assets/js/convo_list/convo_modal.js":
/*!*********************************************!*\
  !*** ./assets/js/convo_list/convo_modal.js ***!
  \*********************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   conversationModal: () => (/* binding */ conversationModal)
/* harmony export */ });
/* harmony import */ var lit__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! lit */ "./node_modules/lit/index.js");
/* harmony import */ var lit_directives_class_map_js__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! lit/directives/class-map.js */ "./node_modules/lit/directives/class-map.js");
/* harmony import */ var _disciple_tools_web_components__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! @disciple.tools/web-components */ "./node_modules/@disciple.tools/web-components/index.js");
/* harmony import */ var _lit_localize__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(/*! @lit/localize */ "./node_modules/@lit/localize/lit-localize.js");
function _typeof(o) { "@babel/helpers - typeof"; return _typeof = "function" == typeof Symbol && "symbol" == typeof Symbol.iterator ? function (o) { return typeof o; } : function (o) { return o && "function" == typeof Symbol && o.constructor === Symbol && o !== Symbol.prototype ? "symbol" : typeof o; }, _typeof(o); }
var _templateObject, _templateObject2;
function _taggedTemplateLiteral(strings, raw) { if (!raw) { raw = strings.slice(0); } return Object.freeze(Object.defineProperties(strings, { raw: { value: Object.freeze(raw) } })); }
function _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } }
function _defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if ("value" in descriptor) descriptor.writable = true; Object.defineProperty(target, _toPropertyKey(descriptor.key), descriptor); } }
function _createClass(Constructor, protoProps, staticProps) { if (protoProps) _defineProperties(Constructor.prototype, protoProps); if (staticProps) _defineProperties(Constructor, staticProps); Object.defineProperty(Constructor, "prototype", { writable: false }); return Constructor; }
function _toPropertyKey(t) { var i = _toPrimitive(t, "string"); return "symbol" == _typeof(i) ? i : i + ""; }
function _toPrimitive(t, r) { if ("object" != _typeof(t) || !t) return t; var e = t[Symbol.toPrimitive]; if (void 0 !== e) { var i = e.call(t, r || "default"); if ("object" != _typeof(i)) return i; throw new TypeError("@@toPrimitive must return a primitive value."); } return ("string" === r ? String : Number)(t); }
function _callSuper(t, o, e) { return o = _getPrototypeOf(o), _possibleConstructorReturn(t, _isNativeReflectConstruct() ? Reflect.construct(o, e || [], _getPrototypeOf(t).constructor) : o.apply(t, e)); }
function _possibleConstructorReturn(self, call) { if (call && (_typeof(call) === "object" || typeof call === "function")) { return call; } else if (call !== void 0) { throw new TypeError("Derived constructors may only return object or undefined"); } return _assertThisInitialized(self); }
function _assertThisInitialized(self) { if (self === void 0) { throw new ReferenceError("this hasn't been initialised - super() hasn't been called"); } return self; }
function _isNativeReflectConstruct() { try { var t = !Boolean.prototype.valueOf.call(Reflect.construct(Boolean, [], function () {})); } catch (t) {} return (_isNativeReflectConstruct = function _isNativeReflectConstruct() { return !!t; })(); }
function _getPrototypeOf(o) { _getPrototypeOf = Object.setPrototypeOf ? Object.getPrototypeOf.bind() : function _getPrototypeOf(o) { return o.__proto__ || Object.getPrototypeOf(o); }; return _getPrototypeOf(o); }
function _inherits(subClass, superClass) { if (typeof superClass !== "function" && superClass !== null) { throw new TypeError("Super expression must either be null or a function"); } subClass.prototype = Object.create(superClass && superClass.prototype, { constructor: { value: subClass, writable: true, configurable: true } }); Object.defineProperty(subClass, "prototype", { writable: false }); if (superClass) _setPrototypeOf(subClass, superClass); }
function _setPrototypeOf(o, p) { _setPrototypeOf = Object.setPrototypeOf ? Object.setPrototypeOf.bind() : function _setPrototypeOf(o, p) { o.__proto__ = p; return o; }; return _setPrototypeOf(o, p); }




var conversationModal = /*#__PURE__*/function (_DtModal) {
  function conversationModal() {
    _classCallCheck(this, conversationModal);
    return _callSuper(this, conversationModal, arguments);
  }
  _inherits(conversationModal, _DtModal);
  return _createClass(conversationModal, [{
    key: "render",
    value: function render() {
      return (0,lit__WEBPACK_IMPORTED_MODULE_0__.html)(_templateObject || (_templateObject = _taggedTemplateLiteral(["\n    <dialog\n        id=\"\"\n        class=\"dt-modal\"\n        @click=", "\n        @keypress=", "\n      >\n        <smm-chat-window ?claimed=", " convoid=", " userid=", " conversation=", "></smm-chat-window>\n    </dialog>\n    <button\n      class=\"button small opener\"\n      data-open=\"\"\n      aria-label=\"Open reveal\"\n      type=\"button\"\n      @click=\"", "\"\n    >\n      <slot name=\"openButton\">", "</slot>\n    </button>\n    "])), this._dialogClick, this._dialogKeypress, this.claimed, this.convoid, this.userid, JSON.stringify(this.conversation), this._openModal, (0,_lit_localize__WEBPACK_IMPORTED_MODULE_3__.msg)('Open Dialog'));
    }
  }], [{
    key: "properties",
    get: function get() {
      return {
        conversation: {
          type: Object
        },
        open: {
          type: Boolean
        },
        claimed: {
          type: Boolean
        },
        convoid: {
          type: Number
        },
        userid: {
          type: Number
        }
      };
    }
  }, {
    key: "styles",
    get: function get() {
      return (0,lit__WEBPACK_IMPORTED_MODULE_0__.css)(_templateObject2 || (_templateObject2 = _taggedTemplateLiteral(["\n      :host {\n      }\n      dialog {\n        width: 90vw;\n        height: 90vh;\n        padding: 0;\n      }\n      dialog::backdrop {\n        background: rgba(0, 0, 0, 0.7);\n      }\n      "])));
    }
  }]);
}(_disciple_tools_web_components__WEBPACK_IMPORTED_MODULE_2__.DtModal);
window.customElements.define("smm-conversation-modal", conversationModal);

/***/ }),

/***/ "./assets/css/styles.css":
/*!*******************************!*\
  !*** ./assets/css/styles.css ***!
  \*******************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

"use strict";
__webpack_require__.r(__webpack_exports__);
// extracted by mini-css-extract-plugin


/***/ }),

/***/ "./node_modules/@lit/localize/init/runtime.js":
/*!****************************************************!*\
  !*** ./node_modules/@lit/localize/init/runtime.js ***!
  \****************************************************/
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   configureLocalization: () => (/* binding */ configureLocalization)
/* harmony export */ });
/* harmony import */ var _lit_localize_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ../lit-localize.js */ "./node_modules/@lit/localize/lit-localize.js");
/* harmony import */ var _internal_deferred_js__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ../internal/deferred.js */ "./node_modules/@lit/localize/internal/deferred.js");
/* harmony import */ var _internal_locale_status_event_js__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! ../internal/locale-status-event.js */ "./node_modules/@lit/localize/internal/locale-status-event.js");
/* harmony import */ var _internal_runtime_msg_js__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(/*! ../internal/runtime-msg.js */ "./node_modules/@lit/localize/internal/runtime-msg.js");
/**
 * @license
 * Copyright 2021 Google LLC
 * SPDX-License-Identifier: BSD-3-Clause
 */




/**
 * Dispatch a "lit-localize-status" event to `window` with the given detail.
 */
function dispatchStatusEvent(detail) {
    window.dispatchEvent(new CustomEvent(_internal_locale_status_event_js__WEBPACK_IMPORTED_MODULE_2__.LOCALE_STATUS_EVENT, { detail }));
}
let activeLocale = '';
let loadingLocale;
let sourceLocale;
let validLocales;
let loadLocale;
let templates;
let loading = new _internal_deferred_js__WEBPACK_IMPORTED_MODULE_1__.Deferred();
// The loading promise must be initially resolved, because that's what we should
// return if the user immediately calls setLocale(sourceLocale).
loading.resolve();
let requestId = 0;
/**
 * Set configuration parameters for lit-localize when in runtime mode. Returns
 * an object with functions:
 *
 * - `getLocale`: Return the active locale code.
 * - `setLocale`: Set the active locale code.
 *
 * Throws if called more than once.
 */
const configureLocalization = (config) => {
    (0,_lit_localize_js__WEBPACK_IMPORTED_MODULE_0__._installMsgImplementation)(((template, options) => (0,_internal_runtime_msg_js__WEBPACK_IMPORTED_MODULE_3__.runtimeMsg)(templates, template, options)));
    activeLocale = sourceLocale = config.sourceLocale;
    validLocales = new Set(config.targetLocales);
    validLocales.add(config.sourceLocale);
    loadLocale = config.loadLocale;
    return { getLocale, setLocale };
};
/**
 * Return the active locale code.
 */
const getLocale = () => {
    return activeLocale;
};
/**
 * Set the active locale code, and begin loading templates for that locale using
 * the `loadLocale` function that was passed to `configureLocalization`. Returns
 * a promise that resolves when the next locale is ready to be rendered.
 *
 * Note that if a second call to `setLocale` is made while the first requested
 * locale is still loading, then the second call takes precedence, and the
 * promise returned from the first call will resolve when second locale is
 * ready. If you need to know whether a particular locale was loaded, check
 * `getLocale` after the promise resolves.
 *
 * Throws if the given locale is not contained by the configured `sourceLocale`
 * or `targetLocales`.
 */
const setLocale = (newLocale) => {
    if (newLocale === (loadingLocale !== null && loadingLocale !== void 0 ? loadingLocale : activeLocale)) {
        return loading.promise;
    }
    if (!validLocales || !loadLocale) {
        throw new Error('Internal error');
    }
    if (!validLocales.has(newLocale)) {
        throw new Error('Invalid locale code');
    }
    requestId++;
    const thisRequestId = requestId;
    loadingLocale = newLocale;
    if (loading.settled) {
        loading = new _internal_deferred_js__WEBPACK_IMPORTED_MODULE_1__.Deferred();
    }
    dispatchStatusEvent({ status: 'loading', loadingLocale: newLocale });
    const localePromise = newLocale === sourceLocale
        ? // We could switch to the source locale synchronously, but we prefer to
            // queue it on a microtask so that switching locales is consistently
            // asynchronous.
            Promise.resolve({ templates: undefined })
        : loadLocale(newLocale);
    localePromise.then((mod) => {
        if (requestId === thisRequestId) {
            activeLocale = newLocale;
            loadingLocale = undefined;
            templates = mod.templates;
            dispatchStatusEvent({ status: 'ready', readyLocale: newLocale });
            loading.resolve();
        }
        // Else another locale was requested in the meantime. Don't resolve or
        // reject, because the newer load call is going to use the same promise.
        // Note the user can call getLocale() after the promise resolves if they
        // need to check if the locale is still the one they expected to load.
    }, (err) => {
        if (requestId === thisRequestId) {
            dispatchStatusEvent({
                status: 'error',
                errorLocale: newLocale,
                errorMessage: err.toString(),
            });
            loading.reject(err);
        }
    });
    return loading.promise;
};
//# sourceMappingURL=runtime.js.map

/***/ }),

/***/ "./node_modules/@lit/localize/init/transform.js":
/*!******************************************************!*\
  !*** ./node_modules/@lit/localize/init/transform.js ***!
  \******************************************************/
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   configureTransformLocalization: () => (/* binding */ configureTransformLocalization)
/* harmony export */ });
/* harmony import */ var _lit_localize_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ../lit-localize.js */ "./node_modules/@lit/localize/lit-localize.js");
/* harmony import */ var _internal_default_msg_js__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ../internal/default-msg.js */ "./node_modules/@lit/localize/internal/default-msg.js");
/**
 * @license
 * Copyright 2021 Google LLC
 * SPDX-License-Identifier: BSD-3-Clause
 */


/**
 * Set configuration parameters for lit-localize when in transform mode. Returns
 * an object with function:
 *
 * - `getLocale`: Return the active locale code.
 *
 * Throws if called more than once.
 */
const configureTransformLocalization = (config) => {
    (0,_lit_localize_js__WEBPACK_IMPORTED_MODULE_0__._installMsgImplementation)(_internal_default_msg_js__WEBPACK_IMPORTED_MODULE_1__.defaultMsg);
    const sourceLocale = config.sourceLocale;
    return {
        getLocale: () => sourceLocale,
    };
};
//# sourceMappingURL=transform.js.map

/***/ }),

/***/ "./node_modules/@lit/localize/internal/default-msg.js":
/*!************************************************************!*\
  !*** ./node_modules/@lit/localize/internal/default-msg.js ***!
  \************************************************************/
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   defaultMsg: () => (/* binding */ defaultMsg)
/* harmony export */ });
/* harmony import */ var _str_tag_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./str-tag.js */ "./node_modules/@lit/localize/internal/str-tag.js");
/**
 * @license
 * Copyright 2021 Google LLC
 * SPDX-License-Identifier: BSD-3-Clause
 */

/**
 * Default identity msg implementation. Simply returns the input template with
 * no awareness of translations. If the template is str-tagged, returns it in
 * string form.
 */
const defaultMsg = ((template) => (0,_str_tag_js__WEBPACK_IMPORTED_MODULE_0__.isStrTagged)(template)
    ? (0,_str_tag_js__WEBPACK_IMPORTED_MODULE_0__.joinStringsAndValues)(template.strings, template.values)
    : template);
//# sourceMappingURL=default-msg.js.map

/***/ }),

/***/ "./node_modules/@lit/localize/internal/deferred.js":
/*!*********************************************************!*\
  !*** ./node_modules/@lit/localize/internal/deferred.js ***!
  \*********************************************************/
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   Deferred: () => (/* binding */ Deferred)
/* harmony export */ });
/**
 * @license
 * Copyright 2020 Google LLC
 * SPDX-License-Identifier: BSD-3-Clause
 */
class Deferred {
    constructor() {
        this.settled = false;
        this.promise = new Promise((resolve, reject) => {
            this._resolve = resolve;
            this._reject = reject;
        });
    }
    resolve(value) {
        this.settled = true;
        this._resolve(value);
    }
    reject(error) {
        this.settled = true;
        this._reject(error);
    }
}
//# sourceMappingURL=deferred.js.map

/***/ }),

/***/ "./node_modules/@lit/localize/internal/fnv1a64.js":
/*!********************************************************!*\
  !*** ./node_modules/@lit/localize/internal/fnv1a64.js ***!
  \********************************************************/
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   fnv1a64: () => (/* binding */ fnv1a64)
/* harmony export */ });
/**
 * @license
 * Copyright 2014 Travis Webb
 * SPDX-License-Identifier: MIT
 */
// This module is derived from the file:
// https://github.com/tjwebb/fnv-plus/blob/1e2ce68a07cb7dd4c3c85364f3d8d96c95919474/index.js#L309
//
// Changes:
// - Only the _hash64_1a_fast function is included.
// - Removed loop unrolling.
// - Converted to TypeScript ES module.
// - var -> let/const
//
// TODO(aomarks) Upstream improvements to https://github.com/tjwebb/fnv-plus/.
const hl = [];
for (let i = 0; i < 256; i++) {
    hl[i] = ((i >> 4) & 15).toString(16) + (i & 15).toString(16);
}
/**
 * Perform a FNV-1A 64-bit hash of the given string (as UTF-16 code units), and
 * return a hexadecimal digest (left zero padded to 16 characters).
 *
 * @see {@link http://tools.ietf.org/html/draft-eastlake-fnv-06}
 */
function fnv1a64(str) {
    let t0 = 0, v0 = 0x2325, t1 = 0, v1 = 0x8422, t2 = 0, v2 = 0x9ce4, t3 = 0, v3 = 0xcbf2;
    for (let i = 0; i < str.length; i++) {
        v0 ^= str.charCodeAt(i);
        t0 = v0 * 435;
        t1 = v1 * 435;
        t2 = v2 * 435;
        t3 = v3 * 435;
        t2 += v0 << 8;
        t3 += v1 << 8;
        t1 += t0 >>> 16;
        v0 = t0 & 65535;
        t2 += t1 >>> 16;
        v1 = t1 & 65535;
        v3 = (t3 + (t2 >>> 16)) & 65535;
        v2 = t2 & 65535;
    }
    return (hl[v3 >> 8] +
        hl[v3 & 255] +
        hl[v2 >> 8] +
        hl[v2 & 255] +
        hl[v1 >> 8] +
        hl[v1 & 255] +
        hl[v0 >> 8] +
        hl[v0 & 255]);
}
//# sourceMappingURL=fnv1a64.js.map

/***/ }),

/***/ "./node_modules/@lit/localize/internal/id-generation.js":
/*!**************************************************************!*\
  !*** ./node_modules/@lit/localize/internal/id-generation.js ***!
  \**************************************************************/
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   HASH_DELIMITER: () => (/* binding */ HASH_DELIMITER),
/* harmony export */   generateMsgId: () => (/* binding */ generateMsgId)
/* harmony export */ });
/* harmony import */ var _fnv1a64_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./fnv1a64.js */ "./node_modules/@lit/localize/internal/fnv1a64.js");
/**
 * @license
 * Copyright 2020 Google LLC
 * SPDX-License-Identifier: BSD-3-Clause
 */

/**
 * Delimiter used between each template string component before hashing. Used to
 * prevent e.g. "foobar" and "foo${baz}bar" from sharing a hash.
 *
 * This is the "record separator" ASCII character.
 */
const HASH_DELIMITER = '\x1e';
/**
 * Id prefix on html-tagged templates to distinguish e.g. `<b>x</b>` from
 * html`<b>x</b>`.
 */
const HTML_PREFIX = 'h';
/**
 * Id prefix on plain string templates to distinguish e.g. `<b>x</b>` from
 * html`<b>x</b>`.
 */
const STRING_PREFIX = 's';
/**
 * Generate a unique ID for a lit-localize message.
 *
 * Example:
 *   Template: html`Hello <b>${who}</b>!`
 *     Params: ["Hello <b>", "</b>!"], true
 *     Output: h82ccc38d4d46eaa9
 *
 * The ID is constructed as:
 *
 *   [0]    Kind of template: [h]tml or [s]tring.
 *   [1,16] 64-bit FNV-1a hash hex digest of the template strings, as UTF-16
 *          code points, delineated by an ASCII "record separator" character.
 *
 * We choose FNV-1a because:
 *
 *   1. It's pretty fast (e.g. much faster than SHA-1).
 *   2. It's pretty small (0.25 KiB minified + brotli).
 *   3. We don't require cryptographic security, and 64 bits should give
 *      sufficient collision resistance for any one application. Worst
 *      case, we will always detect collisions during analysis.
 *   4. We can't use Web Crypto API (e.g. SHA-1), because it's asynchronous.
 *   5. It's a well known non-cryptographic hash with implementations in many
 *      languages.
 *   6. There was an existing JavaScript implementation that doesn't require
 *      BigInt, for IE11 compatibility.
 */
function generateMsgId(strings, isHtmlTagged) {
    return ((isHtmlTagged ? HTML_PREFIX : STRING_PREFIX) +
        (0,_fnv1a64_js__WEBPACK_IMPORTED_MODULE_0__.fnv1a64)(typeof strings === 'string' ? strings : strings.join(HASH_DELIMITER)));
}
//# sourceMappingURL=id-generation.js.map

/***/ }),

/***/ "./node_modules/@lit/localize/internal/locale-status-event.js":
/*!********************************************************************!*\
  !*** ./node_modules/@lit/localize/internal/locale-status-event.js ***!
  \********************************************************************/
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   LOCALE_STATUS_EVENT: () => (/* binding */ LOCALE_STATUS_EVENT)
/* harmony export */ });
/**
 * @license
 * Copyright 2021 Google LLC
 * SPDX-License-Identifier: BSD-3-Clause
 */
/**
 * Name of the event dispatched to `window` whenever a locale change starts,
 * finishes successfully, or fails. Only relevant to runtime mode.
 *
 * The `detail` of this event is an object with a `status` string that can be:
 * "loading", "ready", or "error", along with the relevant locale code, and
 * error message if applicable.
 *
 * You can listen for this event to know when your application should be
 * re-rendered following a locale change. See also the Localized mixin, which
 * automatically re-renders LitElement classes using this event.
 */
const LOCALE_STATUS_EVENT = 'lit-localize-status';
//# sourceMappingURL=locale-status-event.js.map

/***/ }),

/***/ "./node_modules/@lit/localize/internal/localized-controller.js":
/*!*********************************************************************!*\
  !*** ./node_modules/@lit/localize/internal/localized-controller.js ***!
  \*********************************************************************/
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   updateWhenLocaleChanges: () => (/* binding */ updateWhenLocaleChanges)
/* harmony export */ });
/* harmony import */ var _locale_status_event_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./locale-status-event.js */ "./node_modules/@lit/localize/internal/locale-status-event.js");
/**
 * @license
 * Copyright 2021 Google LLC
 * SPDX-License-Identifier: BSD-3-Clause
 */

class LocalizeController {
    constructor(host) {
        this.__litLocalizeEventHandler = (event) => {
            if (event.detail.status === 'ready') {
                this.host.requestUpdate();
            }
        };
        this.host = host;
    }
    hostConnected() {
        window.addEventListener(_locale_status_event_js__WEBPACK_IMPORTED_MODULE_0__.LOCALE_STATUS_EVENT, this.__litLocalizeEventHandler);
    }
    hostDisconnected() {
        window.removeEventListener(_locale_status_event_js__WEBPACK_IMPORTED_MODULE_0__.LOCALE_STATUS_EVENT, this.__litLocalizeEventHandler);
    }
}
/**
 * Re-render the given LitElement whenever a new active locale has loaded.
 *
 * See also {@link localized} for the same functionality as a decorator.
 *
 * When using lit-localize in transform mode, calls to this function are
 * replaced with undefined.
 *
 * Usage:
 *
 *   import {LitElement, html} from 'lit';
 *   import {msg, updateWhenLocaleChanges} from '@lit/localize';
 *
 *   class MyElement extends LitElement {
 *     constructor() {
 *       super();
 *       updateWhenLocaleChanges(this);
 *     }
 *
 *     render() {
 *       return html`<b>${msg('Hello World')}</b>`;
 *     }
 *   }
 */
const _updateWhenLocaleChanges = (host) => host.addController(new LocalizeController(host));
const updateWhenLocaleChanges = _updateWhenLocaleChanges;
//# sourceMappingURL=localized-controller.js.map

/***/ }),

/***/ "./node_modules/@lit/localize/internal/localized-decorator.js":
/*!********************************************************************!*\
  !*** ./node_modules/@lit/localize/internal/localized-decorator.js ***!
  \********************************************************************/
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   localized: () => (/* binding */ localized)
/* harmony export */ });
/* harmony import */ var _localized_controller_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./localized-controller.js */ "./node_modules/@lit/localize/internal/localized-controller.js");
/**
 * @license
 * Copyright 2021 Google LLC
 * SPDX-License-Identifier: BSD-3-Clause
 */

/**
 * Class decorator to enable re-rendering the given LitElement whenever a new
 * active locale has loaded.
 *
 * See also {@link updateWhenLocaleChanges} for the same functionality without
 * the use of decorators.
 *
 * When using lit-localize in transform mode, applications of this decorator are
 * removed.
 *
 * Usage:
 *
 *   import {LitElement, html} from 'lit';
 *   import {customElement} from 'lit/decorators.js';
 *   import {msg, localized} from '@lit/localize';
 *
 *   @localized()
 *   @customElement('my-element')
 *   class MyElement extends LitElement {
 *     render() {
 *       return html`<b>${msg('Hello World')}</b>`;
 *     }
 *   }
 */
const _localized = () => (classOrDescriptor) => typeof classOrDescriptor === 'function'
    ? legacyLocalized(classOrDescriptor)
    : standardLocalized(classOrDescriptor);
const localized = _localized;
const standardLocalized = ({ kind, elements }) => {
    return {
        kind,
        elements,
        finisher(clazz) {
            clazz.addInitializer(_localized_controller_js__WEBPACK_IMPORTED_MODULE_0__.updateWhenLocaleChanges);
        },
    };
};
const legacyLocalized = (clazz) => {
    clazz.addInitializer(_localized_controller_js__WEBPACK_IMPORTED_MODULE_0__.updateWhenLocaleChanges);
    // eslint-disable-next-line @typescript-eslint/no-explicit-any
    return clazz;
};
//# sourceMappingURL=localized-decorator.js.map

/***/ }),

/***/ "./node_modules/@lit/localize/internal/runtime-msg.js":
/*!************************************************************!*\
  !*** ./node_modules/@lit/localize/internal/runtime-msg.js ***!
  \************************************************************/
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   runtimeMsg: () => (/* binding */ runtimeMsg)
/* harmony export */ });
/* harmony import */ var _default_msg_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./default-msg.js */ "./node_modules/@lit/localize/internal/default-msg.js");
/* harmony import */ var _str_tag_js__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ./str-tag.js */ "./node_modules/@lit/localize/internal/str-tag.js");
/* harmony import */ var _id_generation_js__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! ./id-generation.js */ "./node_modules/@lit/localize/internal/id-generation.js");
/**
 * @license
 * Copyright 2021 Google LLC
 * SPDX-License-Identifier: BSD-3-Clause
 */



const expressionOrders = new WeakMap();
const hashCache = new Map();
function runtimeMsg(templates, template, options) {
    var _a;
    if (templates) {
        const id = (_a = options === null || options === void 0 ? void 0 : options.id) !== null && _a !== void 0 ? _a : generateId(template);
        const localized = templates[id];
        if (localized) {
            if (typeof localized === 'string') {
                // E.g. "Hello World!"
                return localized;
            }
            else if ('strTag' in localized) {
                // E.g. str`Hello ${name}!`
                //
                // Localized templates have ${number} in place of real template
                // expressions. They can't have real template values, because the
                // variable scope would be wrong. The number tells us the index of the
                // source value to substitute in its place, because expressions can be
                // moved to a different position during translation.
                return (0,_str_tag_js__WEBPACK_IMPORTED_MODULE_1__.joinStringsAndValues)(localized.strings, 
                // Cast `template` because its type wasn't automatically narrowed (but
                // we know it must be the same type as `localized`).
                template.values, localized.values);
            }
            else {
                // E.g. html`Hello <b>${name}</b>!`
                //
                // We have to keep our own mapping of expression ordering because we do
                // an in-place update of `values`, and otherwise we'd lose ordering for
                // subsequent renders.
                let order = expressionOrders.get(localized);
                if (order === undefined) {
                    order = localized.values;
                    expressionOrders.set(localized, order);
                }
                return {
                    ...localized,
                    values: order.map((i) => template.values[i]),
                };
            }
        }
    }
    return (0,_default_msg_js__WEBPACK_IMPORTED_MODULE_0__.defaultMsg)(template);
}
function generateId(template) {
    const strings = typeof template === 'string' ? template : template.strings;
    let id = hashCache.get(strings);
    if (id === undefined) {
        id = (0,_id_generation_js__WEBPACK_IMPORTED_MODULE_2__.generateMsgId)(strings, typeof template !== 'string' && !('strTag' in template));
        hashCache.set(strings, id);
    }
    return id;
}
//# sourceMappingURL=runtime-msg.js.map

/***/ }),

/***/ "./node_modules/@lit/localize/internal/str-tag.js":
/*!********************************************************!*\
  !*** ./node_modules/@lit/localize/internal/str-tag.js ***!
  \********************************************************/
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   isStrTagged: () => (/* binding */ isStrTagged),
/* harmony export */   joinStringsAndValues: () => (/* binding */ joinStringsAndValues),
/* harmony export */   str: () => (/* binding */ str)
/* harmony export */ });
/**
 * @license
 * Copyright 2021 Google LLC
 * SPDX-License-Identifier: BSD-3-Clause
 */
/**
 * Tag that allows expressions to be used in localized non-HTML template
 * strings.
 *
 * Example: msg(str`Hello ${this.user}!`);
 *
 * The Lit html tag can also be used for this purpose, but HTML will need to be
 * escaped, and there is a small overhead for HTML parsing.
 *
 * Untagged template strings with expressions aren't supported by lit-localize
 * because they don't allow for values to be captured at runtime.
 */
const _str = (strings, ...values) => ({
    strTag: true,
    strings,
    values,
});
const str = _str;
const isStrTagged = (val) => typeof val !== 'string' && 'strTag' in val;
/**
 * Render the result of a `str` tagged template to a string. Note we don't need
 * to do this for Lit templates, since Lit itself handles rendering.
 */
const joinStringsAndValues = (strings, values, valueOrder) => {
    let concat = strings[0];
    for (let i = 1; i < strings.length; i++) {
        concat += values[valueOrder ? valueOrder[i - 1] : i - 1];
        concat += strings[i];
    }
    return concat;
};
//# sourceMappingURL=str-tag.js.map

/***/ }),

/***/ "./node_modules/@lit/localize/internal/types.js":
/*!******************************************************!*\
  !*** ./node_modules/@lit/localize/internal/types.js ***!
  \******************************************************/
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

"use strict";
__webpack_require__.r(__webpack_exports__);
/**
 * @license
 * Copyright 2021 Google LLC
 * SPDX-License-Identifier: BSD-3-Clause
 */

//# sourceMappingURL=types.js.map

/***/ }),

/***/ "./node_modules/@lit/localize/lit-localize.js":
/*!****************************************************!*\
  !*** ./node_modules/@lit/localize/lit-localize.js ***!
  \****************************************************/
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   LOCALE_STATUS_EVENT: () => (/* reexport safe */ _internal_locale_status_event_js__WEBPACK_IMPORTED_MODULE_1__.LOCALE_STATUS_EVENT),
/* harmony export */   _installMsgImplementation: () => (/* binding */ _installMsgImplementation),
/* harmony export */   configureLocalization: () => (/* reexport safe */ _init_runtime_js__WEBPACK_IMPORTED_MODULE_6__.configureLocalization),
/* harmony export */   configureTransformLocalization: () => (/* reexport safe */ _init_transform_js__WEBPACK_IMPORTED_MODULE_7__.configureTransformLocalization),
/* harmony export */   isStrTagged: () => (/* reexport safe */ _internal_str_tag_js__WEBPACK_IMPORTED_MODULE_2__.isStrTagged),
/* harmony export */   joinStringsAndValues: () => (/* reexport safe */ _internal_str_tag_js__WEBPACK_IMPORTED_MODULE_2__.joinStringsAndValues),
/* harmony export */   localized: () => (/* reexport safe */ _internal_localized_decorator_js__WEBPACK_IMPORTED_MODULE_5__.localized),
/* harmony export */   msg: () => (/* binding */ msg),
/* harmony export */   str: () => (/* reexport safe */ _internal_str_tag_js__WEBPACK_IMPORTED_MODULE_2__.str),
/* harmony export */   updateWhenLocaleChanges: () => (/* reexport safe */ _internal_localized_controller_js__WEBPACK_IMPORTED_MODULE_4__.updateWhenLocaleChanges)
/* harmony export */ });
/* harmony import */ var _internal_default_msg_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./internal/default-msg.js */ "./node_modules/@lit/localize/internal/default-msg.js");
/* harmony import */ var _internal_locale_status_event_js__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ./internal/locale-status-event.js */ "./node_modules/@lit/localize/internal/locale-status-event.js");
/* harmony import */ var _internal_str_tag_js__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! ./internal/str-tag.js */ "./node_modules/@lit/localize/internal/str-tag.js");
/* harmony import */ var _internal_types_js__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(/*! ./internal/types.js */ "./node_modules/@lit/localize/internal/types.js");
/* harmony import */ var _internal_localized_controller_js__WEBPACK_IMPORTED_MODULE_4__ = __webpack_require__(/*! ./internal/localized-controller.js */ "./node_modules/@lit/localize/internal/localized-controller.js");
/* harmony import */ var _internal_localized_decorator_js__WEBPACK_IMPORTED_MODULE_5__ = __webpack_require__(/*! ./internal/localized-decorator.js */ "./node_modules/@lit/localize/internal/localized-decorator.js");
/* harmony import */ var _init_runtime_js__WEBPACK_IMPORTED_MODULE_6__ = __webpack_require__(/*! ./init/runtime.js */ "./node_modules/@lit/localize/init/runtime.js");
/* harmony import */ var _init_transform_js__WEBPACK_IMPORTED_MODULE_7__ = __webpack_require__(/*! ./init/transform.js */ "./node_modules/@lit/localize/init/transform.js");
/**
 * @license
 * Copyright 2020 Google LLC
 * SPDX-License-Identifier: BSD-3-Clause
 */




// TODO(aomarks) In a future breaking version, remove these imports so that the
// bulk of the code isn't included in bundles by default. In particular imagine
// the component library use-case where msg() calls are made, but there is no
// need to actually initialize any of the localization runtime.




/**
 * Make a string or lit-html template localizable.
 *
 * @param template A string, a lit-html template, or a function that returns
 * either a string or lit-html template.
 * @param options Optional configuration object with the following properties:
 *   - id: Optional project-wide unique identifier for this template. If
 *     omitted, an id will be automatically generated from the template strings.
 *   - desc: Optional description
 */
let msg = _internal_default_msg_js__WEBPACK_IMPORTED_MODULE_0__.defaultMsg;
let installed = false;
/**
 * Internal only. Do not use this function.
 *
 * Installs an implementation of the msg function to replace the default
 * identity function. Throws if called more than once.
 *
 * @internal
 */
function _installMsgImplementation(impl) {
    if (installed) {
        throw new Error('lit-localize can only be configured once');
    }
    msg = impl;
    installed = true;
}
//# sourceMappingURL=lit-localize.js.map

/***/ }),

/***/ "./node_modules/@lit/reactive-element/development/css-tag.js":
/*!*******************************************************************!*\
  !*** ./node_modules/@lit/reactive-element/development/css-tag.js ***!
  \*******************************************************************/
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   CSSResult: () => (/* binding */ CSSResult),
/* harmony export */   adoptStyles: () => (/* binding */ adoptStyles),
/* harmony export */   css: () => (/* binding */ css),
/* harmony export */   getCompatibleStyle: () => (/* binding */ getCompatibleStyle),
/* harmony export */   supportsAdoptingStyleSheets: () => (/* binding */ supportsAdoptingStyleSheets),
/* harmony export */   unsafeCSS: () => (/* binding */ unsafeCSS)
/* harmony export */ });
/**
 * @license
 * Copyright 2019 Google LLC
 * SPDX-License-Identifier: BSD-3-Clause
 */
const NODE_MODE = false;
const global = NODE_MODE ? globalThis : window;
/**
 * Whether the current browser supports `adoptedStyleSheets`.
 */
const supportsAdoptingStyleSheets = global.ShadowRoot &&
    (global.ShadyCSS === undefined || global.ShadyCSS.nativeShadow) &&
    'adoptedStyleSheets' in Document.prototype &&
    'replace' in CSSStyleSheet.prototype;
const constructionToken = Symbol();
const cssTagCache = new WeakMap();
/**
 * A container for a string of CSS text, that may be used to create a CSSStyleSheet.
 *
 * CSSResult is the return value of `css`-tagged template literals and
 * `unsafeCSS()`. In order to ensure that CSSResults are only created via the
 * `css` tag and `unsafeCSS()`, CSSResult cannot be constructed directly.
 */
class CSSResult {
    constructor(cssText, strings, safeToken) {
        // This property needs to remain unminified.
        this['_$cssResult$'] = true;
        if (safeToken !== constructionToken) {
            throw new Error('CSSResult is not constructable. Use `unsafeCSS` or `css` instead.');
        }
        this.cssText = cssText;
        this._strings = strings;
    }
    // This is a getter so that it's lazy. In practice, this means stylesheets
    // are not created until the first element instance is made.
    get styleSheet() {
        // If `supportsAdoptingStyleSheets` is true then we assume CSSStyleSheet is
        // constructable.
        let styleSheet = this._styleSheet;
        const strings = this._strings;
        if (supportsAdoptingStyleSheets && styleSheet === undefined) {
            const cacheable = strings !== undefined && strings.length === 1;
            if (cacheable) {
                styleSheet = cssTagCache.get(strings);
            }
            if (styleSheet === undefined) {
                (this._styleSheet = styleSheet = new CSSStyleSheet()).replaceSync(this.cssText);
                if (cacheable) {
                    cssTagCache.set(strings, styleSheet);
                }
            }
        }
        return styleSheet;
    }
    toString() {
        return this.cssText;
    }
}
const textFromCSSResult = (value) => {
    // This property needs to remain unminified.
    if (value['_$cssResult$'] === true) {
        return value.cssText;
    }
    else if (typeof value === 'number') {
        return value;
    }
    else {
        throw new Error(`Value passed to 'css' function must be a 'css' function result: ` +
            `${value}. Use 'unsafeCSS' to pass non-literal values, but take care ` +
            `to ensure page security.`);
    }
};
/**
 * Wrap a value for interpolation in a {@linkcode css} tagged template literal.
 *
 * This is unsafe because untrusted CSS text can be used to phone home
 * or exfiltrate data to an attacker controlled site. Take care to only use
 * this with trusted input.
 */
const unsafeCSS = (value) => new CSSResult(typeof value === 'string' ? value : String(value), undefined, constructionToken);
/**
 * A template literal tag which can be used with LitElement's
 * {@linkcode LitElement.styles} property to set element styles.
 *
 * For security reasons, only literal string values and number may be used in
 * embedded expressions. To incorporate non-literal values {@linkcode unsafeCSS}
 * may be used inside an expression.
 */
const css = (strings, ...values) => {
    const cssText = strings.length === 1
        ? strings[0]
        : values.reduce((acc, v, idx) => acc + textFromCSSResult(v) + strings[idx + 1], strings[0]);
    return new CSSResult(cssText, strings, constructionToken);
};
/**
 * Applies the given styles to a `shadowRoot`. When Shadow DOM is
 * available but `adoptedStyleSheets` is not, styles are appended to the
 * `shadowRoot` to [mimic spec behavior](https://wicg.github.io/construct-stylesheets/#using-constructed-stylesheets).
 * Note, when shimming is used, any styles that are subsequently placed into
 * the shadowRoot should be placed *before* any shimmed adopted styles. This
 * will match spec behavior that gives adopted sheets precedence over styles in
 * shadowRoot.
 */
const adoptStyles = (renderRoot, styles) => {
    if (supportsAdoptingStyleSheets) {
        renderRoot.adoptedStyleSheets = styles.map((s) => s instanceof CSSStyleSheet ? s : s.styleSheet);
    }
    else {
        styles.forEach((s) => {
            const style = document.createElement('style');
            // eslint-disable-next-line @typescript-eslint/no-explicit-any
            const nonce = global['litNonce'];
            if (nonce !== undefined) {
                style.setAttribute('nonce', nonce);
            }
            style.textContent = s.cssText;
            renderRoot.appendChild(style);
        });
    }
};
const cssResultFromStyleSheet = (sheet) => {
    let cssText = '';
    for (const rule of sheet.cssRules) {
        cssText += rule.cssText;
    }
    return unsafeCSS(cssText);
};
const getCompatibleStyle = supportsAdoptingStyleSheets ||
    (NODE_MODE && global.CSSStyleSheet === undefined)
    ? (s) => s
    : (s) => s instanceof CSSStyleSheet ? cssResultFromStyleSheet(s) : s;
//# sourceMappingURL=css-tag.js.map

/***/ }),

/***/ "./node_modules/@lit/reactive-element/development/reactive-element.js":
/*!****************************************************************************!*\
  !*** ./node_modules/@lit/reactive-element/development/reactive-element.js ***!
  \****************************************************************************/
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   CSSResult: () => (/* reexport safe */ _css_tag_js__WEBPACK_IMPORTED_MODULE_0__.CSSResult),
/* harmony export */   ReactiveElement: () => (/* binding */ ReactiveElement),
/* harmony export */   adoptStyles: () => (/* reexport safe */ _css_tag_js__WEBPACK_IMPORTED_MODULE_0__.adoptStyles),
/* harmony export */   css: () => (/* reexport safe */ _css_tag_js__WEBPACK_IMPORTED_MODULE_0__.css),
/* harmony export */   defaultConverter: () => (/* binding */ defaultConverter),
/* harmony export */   getCompatibleStyle: () => (/* reexport safe */ _css_tag_js__WEBPACK_IMPORTED_MODULE_0__.getCompatibleStyle),
/* harmony export */   notEqual: () => (/* binding */ notEqual),
/* harmony export */   supportsAdoptingStyleSheets: () => (/* reexport safe */ _css_tag_js__WEBPACK_IMPORTED_MODULE_0__.supportsAdoptingStyleSheets),
/* harmony export */   unsafeCSS: () => (/* reexport safe */ _css_tag_js__WEBPACK_IMPORTED_MODULE_0__.unsafeCSS)
/* harmony export */ });
/* harmony import */ var _css_tag_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./css-tag.js */ "./node_modules/@lit/reactive-element/development/css-tag.js");
/**
 * @license
 * Copyright 2017 Google LLC
 * SPDX-License-Identifier: BSD-3-Clause
 */
var _a, _b, _c, _d;
var _e;
/**
 * Use this module if you want to create your own base class extending
 * {@link ReactiveElement}.
 * @packageDocumentation
 */

// In the Node build, this import will be injected by Rollup:
// import {HTMLElement, customElements} from '@lit-labs/ssr-dom-shim';

const NODE_MODE = false;
const global = NODE_MODE ? globalThis : window;
if (NODE_MODE) {
    (_a = global.customElements) !== null && _a !== void 0 ? _a : (global.customElements = customElements);
}
const DEV_MODE = true;
let requestUpdateThenable;
let issueWarning;
const trustedTypes = global
    .trustedTypes;
// Temporary workaround for https://crbug.com/993268
// Currently, any attribute starting with "on" is considered to be a
// TrustedScript source. Such boolean attributes must be set to the equivalent
// trusted emptyScript value.
const emptyStringForBooleanAttribute = trustedTypes
    ? trustedTypes.emptyScript
    : '';
const polyfillSupport = DEV_MODE
    ? global.reactiveElementPolyfillSupportDevMode
    : global.reactiveElementPolyfillSupport;
if (DEV_MODE) {
    // Ensure warnings are issued only 1x, even if multiple versions of Lit
    // are loaded.
    const issuedWarnings = ((_b = global.litIssuedWarnings) !== null && _b !== void 0 ? _b : (global.litIssuedWarnings = new Set()));
    // Issue a warning, if we haven't already.
    issueWarning = (code, warning) => {
        warning += ` See https://lit.dev/msg/${code} for more information.`;
        if (!issuedWarnings.has(warning)) {
            console.warn(warning);
            issuedWarnings.add(warning);
        }
    };
    issueWarning('dev-mode', `Lit is in dev mode. Not recommended for production!`);
    // Issue polyfill support warning.
    if (((_c = global.ShadyDOM) === null || _c === void 0 ? void 0 : _c.inUse) && polyfillSupport === undefined) {
        issueWarning('polyfill-support-missing', `Shadow DOM is being polyfilled via \`ShadyDOM\` but ` +
            `the \`polyfill-support\` module has not been loaded.`);
    }
    requestUpdateThenable = (name) => ({
        then: (onfulfilled, _onrejected) => {
            issueWarning('request-update-promise', `The \`requestUpdate\` method should no longer return a Promise but ` +
                `does so on \`${name}\`. Use \`updateComplete\` instead.`);
            if (onfulfilled !== undefined) {
                onfulfilled(false);
            }
        },
    });
}
/**
 * Useful for visualizing and logging insights into what the Lit template system is doing.
 *
 * Compiled out of prod mode builds.
 */
const debugLogEvent = DEV_MODE
    ? (event) => {
        const shouldEmit = global
            .emitLitDebugLogEvents;
        if (!shouldEmit) {
            return;
        }
        global.dispatchEvent(new CustomEvent('lit-debug', {
            detail: event,
        }));
    }
    : undefined;
/*
 * When using Closure Compiler, JSCompiler_renameProperty(property, object) is
 * replaced at compile time by the munged name for object[property]. We cannot
 * alias this function, so we have to use a small shim that has the same
 * behavior when not compiling.
 */
/*@__INLINE__*/
const JSCompiler_renameProperty = (prop, _obj) => prop;
const defaultConverter = {
    toAttribute(value, type) {
        switch (type) {
            case Boolean:
                value = value ? emptyStringForBooleanAttribute : null;
                break;
            case Object:
            case Array:
                // if the value is `null` or `undefined` pass this through
                // to allow removing/no change behavior.
                value = value == null ? value : JSON.stringify(value);
                break;
        }
        return value;
    },
    fromAttribute(value, type) {
        let fromValue = value;
        switch (type) {
            case Boolean:
                fromValue = value !== null;
                break;
            case Number:
                fromValue = value === null ? null : Number(value);
                break;
            case Object:
            case Array:
                // Do *not* generate exception when invalid JSON is set as elements
                // don't normally complain on being mis-configured.
                // TODO(sorvell): Do generate exception in *dev mode*.
                try {
                    // Assert to adhere to Bazel's "must type assert JSON parse" rule.
                    fromValue = JSON.parse(value);
                }
                catch (e) {
                    fromValue = null;
                }
                break;
        }
        return fromValue;
    },
};
/**
 * Change function that returns true if `value` is different from `oldValue`.
 * This method is used as the default for a property's `hasChanged` function.
 */
const notEqual = (value, old) => {
    // This ensures (old==NaN, value==NaN) always returns false
    return old !== value && (old === old || value === value);
};
const defaultPropertyDeclaration = {
    attribute: true,
    type: String,
    converter: defaultConverter,
    reflect: false,
    hasChanged: notEqual,
};
/**
 * The Closure JS Compiler doesn't currently have good support for static
 * property semantics where "this" is dynamic (e.g.
 * https://github.com/google/closure-compiler/issues/3177 and others) so we use
 * this hack to bypass any rewriting by the compiler.
 */
const finalized = 'finalized';
/**
 * Base element class which manages element properties and attributes. When
 * properties change, the `update` method is asynchronously called. This method
 * should be supplied by subclassers to render updates as desired.
 * @noInheritDoc
 */
class ReactiveElement
// In the Node build, this `extends` clause will be substituted with
// `(globalThis.HTMLElement ?? HTMLElement)`.
//
// This way, we will first prefer any global `HTMLElement` polyfill that the
// user has assigned, and then fall back to the `HTMLElement` shim which has
// been imported (see note at the top of this file about how this import is
// generated by Rollup). Note that the `HTMLElement` variable has been
// shadowed by this import, so it no longer refers to the global.
 extends HTMLElement {
    constructor() {
        super();
        this.__instanceProperties = new Map();
        /**
         * True if there is a pending update as a result of calling `requestUpdate()`.
         * Should only be read.
         * @category updates
         */
        this.isUpdatePending = false;
        /**
         * Is set to `true` after the first update. The element code cannot assume
         * that `renderRoot` exists before the element `hasUpdated`.
         * @category updates
         */
        this.hasUpdated = false;
        /**
         * Name of currently reflecting property
         */
        this.__reflectingProperty = null;
        this.__initialize();
    }
    /**
     * Adds an initializer function to the class that is called during instance
     * construction.
     *
     * This is useful for code that runs against a `ReactiveElement`
     * subclass, such as a decorator, that needs to do work for each
     * instance, such as setting up a `ReactiveController`.
     *
     * ```ts
     * const myDecorator = (target: typeof ReactiveElement, key: string) => {
     *   target.addInitializer((instance: ReactiveElement) => {
     *     // This is run during construction of the element
     *     new MyController(instance);
     *   });
     * }
     * ```
     *
     * Decorating a field will then cause each instance to run an initializer
     * that adds a controller:
     *
     * ```ts
     * class MyElement extends LitElement {
     *   @myDecorator foo;
     * }
     * ```
     *
     * Initializers are stored per-constructor. Adding an initializer to a
     * subclass does not add it to a superclass. Since initializers are run in
     * constructors, initializers will run in order of the class hierarchy,
     * starting with superclasses and progressing to the instance's class.
     *
     * @nocollapse
     */
    static addInitializer(initializer) {
        var _a;
        this.finalize();
        ((_a = this._initializers) !== null && _a !== void 0 ? _a : (this._initializers = [])).push(initializer);
    }
    /**
     * Returns a list of attributes corresponding to the registered properties.
     * @nocollapse
     * @category attributes
     */
    static get observedAttributes() {
        // note: piggy backing on this to ensure we're finalized.
        this.finalize();
        const attributes = [];
        // Use forEach so this works even if for/of loops are compiled to for loops
        // expecting arrays
        this.elementProperties.forEach((v, p) => {
            const attr = this.__attributeNameForProperty(p, v);
            if (attr !== undefined) {
                this.__attributeToPropertyMap.set(attr, p);
                attributes.push(attr);
            }
        });
        return attributes;
    }
    /**
     * Creates a property accessor on the element prototype if one does not exist
     * and stores a {@linkcode PropertyDeclaration} for the property with the
     * given options. The property setter calls the property's `hasChanged`
     * property option or uses a strict identity check to determine whether or not
     * to request an update.
     *
     * This method may be overridden to customize properties; however,
     * when doing so, it's important to call `super.createProperty` to ensure
     * the property is setup correctly. This method calls
     * `getPropertyDescriptor` internally to get a descriptor to install.
     * To customize what properties do when they are get or set, override
     * `getPropertyDescriptor`. To customize the options for a property,
     * implement `createProperty` like this:
     *
     * ```ts
     * static createProperty(name, options) {
     *   options = Object.assign(options, {myOption: true});
     *   super.createProperty(name, options);
     * }
     * ```
     *
     * @nocollapse
     * @category properties
     */
    static createProperty(name, options = defaultPropertyDeclaration) {
        var _a;
        // if this is a state property, force the attribute to false.
        if (options.state) {
            // Cast as any since this is readonly.
            // eslint-disable-next-line @typescript-eslint/no-explicit-any
            options.attribute = false;
        }
        // Note, since this can be called by the `@property` decorator which
        // is called before `finalize`, we ensure finalization has been kicked off.
        this.finalize();
        this.elementProperties.set(name, options);
        // Do not generate an accessor if the prototype already has one, since
        // it would be lost otherwise and that would never be the user's intention;
        // Instead, we expect users to call `requestUpdate` themselves from
        // user-defined accessors. Note that if the super has an accessor we will
        // still overwrite it
        if (!options.noAccessor && !this.prototype.hasOwnProperty(name)) {
            const key = typeof name === 'symbol' ? Symbol() : `__${name}`;
            const descriptor = this.getPropertyDescriptor(name, key, options);
            if (descriptor !== undefined) {
                Object.defineProperty(this.prototype, name, descriptor);
                if (DEV_MODE) {
                    // If this class doesn't have its own set, create one and initialize
                    // with the values in the set from the nearest ancestor class, if any.
                    if (!this.hasOwnProperty('__reactivePropertyKeys')) {
                        this.__reactivePropertyKeys = new Set((_a = this.__reactivePropertyKeys) !== null && _a !== void 0 ? _a : []);
                    }
                    this.__reactivePropertyKeys.add(name);
                }
            }
        }
    }
    /**
     * Returns a property descriptor to be defined on the given named property.
     * If no descriptor is returned, the property will not become an accessor.
     * For example,
     *
     * ```ts
     * class MyElement extends LitElement {
     *   static getPropertyDescriptor(name, key, options) {
     *     const defaultDescriptor =
     *         super.getPropertyDescriptor(name, key, options);
     *     const setter = defaultDescriptor.set;
     *     return {
     *       get: defaultDescriptor.get,
     *       set(value) {
     *         setter.call(this, value);
     *         // custom action.
     *       },
     *       configurable: true,
     *       enumerable: true
     *     }
     *   }
     * }
     * ```
     *
     * @nocollapse
     * @category properties
     */
    static getPropertyDescriptor(name, key, options) {
        return {
            // eslint-disable-next-line @typescript-eslint/no-explicit-any
            get() {
                return this[key];
            },
            set(value) {
                const oldValue = this[name];
                this[key] = value;
                this.requestUpdate(name, oldValue, options);
            },
            configurable: true,
            enumerable: true,
        };
    }
    /**
     * Returns the property options associated with the given property.
     * These options are defined with a `PropertyDeclaration` via the `properties`
     * object or the `@property` decorator and are registered in
     * `createProperty(...)`.
     *
     * Note, this method should be considered "final" and not overridden. To
     * customize the options for a given property, override
     * {@linkcode createProperty}.
     *
     * @nocollapse
     * @final
     * @category properties
     */
    static getPropertyOptions(name) {
        return this.elementProperties.get(name) || defaultPropertyDeclaration;
    }
    /**
     * Creates property accessors for registered properties, sets up element
     * styling, and ensures any superclasses are also finalized. Returns true if
     * the element was finalized.
     * @nocollapse
     */
    static finalize() {
        if (this.hasOwnProperty(finalized)) {
            return false;
        }
        this[finalized] = true;
        // finalize any superclasses
        const superCtor = Object.getPrototypeOf(this);
        superCtor.finalize();
        // Create own set of initializers for this class if any exist on the
        // superclass and copy them down. Note, for a small perf boost, avoid
        // creating initializers unless needed.
        if (superCtor._initializers !== undefined) {
            this._initializers = [...superCtor._initializers];
        }
        this.elementProperties = new Map(superCtor.elementProperties);
        // initialize Map populated in observedAttributes
        this.__attributeToPropertyMap = new Map();
        // make any properties
        // Note, only process "own" properties since this element will inherit
        // any properties defined on the superClass, and finalization ensures
        // the entire prototype chain is finalized.
        if (this.hasOwnProperty(JSCompiler_renameProperty('properties', this))) {
            const props = this.properties;
            // support symbols in properties (IE11 does not support this)
            const propKeys = [
                ...Object.getOwnPropertyNames(props),
                ...Object.getOwnPropertySymbols(props),
            ];
            // This for/of is ok because propKeys is an array
            for (const p of propKeys) {
                // note, use of `any` is due to TypeScript lack of support for symbol in
                // index types
                // eslint-disable-next-line @typescript-eslint/no-explicit-any
                this.createProperty(p, props[p]);
            }
        }
        this.elementStyles = this.finalizeStyles(this.styles);
        // DEV mode warnings
        if (DEV_MODE) {
            const warnRemovedOrRenamed = (name, renamed = false) => {
                if (this.prototype.hasOwnProperty(name)) {
                    issueWarning(renamed ? 'renamed-api' : 'removed-api', `\`${name}\` is implemented on class ${this.name}. It ` +
                        `has been ${renamed ? 'renamed' : 'removed'} ` +
                        `in this version of LitElement.`);
                }
            };
            warnRemovedOrRenamed('initialize');
            warnRemovedOrRenamed('requestUpdateInternal');
            warnRemovedOrRenamed('_getUpdateComplete', true);
        }
        return true;
    }
    /**
     * Takes the styles the user supplied via the `static styles` property and
     * returns the array of styles to apply to the element.
     * Override this method to integrate into a style management system.
     *
     * Styles are deduplicated preserving the _last_ instance in the list. This
     * is a performance optimization to avoid duplicated styles that can occur
     * especially when composing via subclassing. The last item is kept to try
     * to preserve the cascade order with the assumption that it's most important
     * that last added styles override previous styles.
     *
     * @nocollapse
     * @category styles
     */
    static finalizeStyles(styles) {
        const elementStyles = [];
        if (Array.isArray(styles)) {
            // Dedupe the flattened array in reverse order to preserve the last items.
            // Casting to Array<unknown> works around TS error that
            // appears to come from trying to flatten a type CSSResultArray.
            const set = new Set(styles.flat(Infinity).reverse());
            // Then preserve original order by adding the set items in reverse order.
            for (const s of set) {
                elementStyles.unshift((0,_css_tag_js__WEBPACK_IMPORTED_MODULE_0__.getCompatibleStyle)(s));
            }
        }
        else if (styles !== undefined) {
            elementStyles.push((0,_css_tag_js__WEBPACK_IMPORTED_MODULE_0__.getCompatibleStyle)(styles));
        }
        return elementStyles;
    }
    /**
     * Returns the property name for the given attribute `name`.
     * @nocollapse
     */
    static __attributeNameForProperty(name, options) {
        const attribute = options.attribute;
        return attribute === false
            ? undefined
            : typeof attribute === 'string'
                ? attribute
                : typeof name === 'string'
                    ? name.toLowerCase()
                    : undefined;
    }
    /**
     * Internal only override point for customizing work done when elements
     * are constructed.
     */
    __initialize() {
        var _a;
        this.__updatePromise = new Promise((res) => (this.enableUpdating = res));
        this._$changedProperties = new Map();
        this.__saveInstanceProperties();
        // ensures first update will be caught by an early access of
        // `updateComplete`
        this.requestUpdate();
        (_a = this.constructor._initializers) === null || _a === void 0 ? void 0 : _a.forEach((i) => i(this));
    }
    /**
     * Registers a `ReactiveController` to participate in the element's reactive
     * update cycle. The element automatically calls into any registered
     * controllers during its lifecycle callbacks.
     *
     * If the element is connected when `addController()` is called, the
     * controller's `hostConnected()` callback will be immediately called.
     * @category controllers
     */
    addController(controller) {
        var _a, _b;
        ((_a = this.__controllers) !== null && _a !== void 0 ? _a : (this.__controllers = [])).push(controller);
        // If a controller is added after the element has been connected,
        // call hostConnected. Note, re-using existence of `renderRoot` here
        // (which is set in connectedCallback) to avoid the need to track a
        // first connected state.
        if (this.renderRoot !== undefined && this.isConnected) {
            (_b = controller.hostConnected) === null || _b === void 0 ? void 0 : _b.call(controller);
        }
    }
    /**
     * Removes a `ReactiveController` from the element.
     * @category controllers
     */
    removeController(controller) {
        var _a;
        // Note, if the indexOf is -1, the >>> will flip the sign which makes the
        // splice do nothing.
        (_a = this.__controllers) === null || _a === void 0 ? void 0 : _a.splice(this.__controllers.indexOf(controller) >>> 0, 1);
    }
    /**
     * Fixes any properties set on the instance before upgrade time.
     * Otherwise these would shadow the accessor and break these properties.
     * The properties are stored in a Map which is played back after the
     * constructor runs. Note, on very old versions of Safari (<=9) or Chrome
     * (<=41), properties created for native platform properties like (`id` or
     * `name`) may not have default values set in the element constructor. On
     * these browsers native properties appear on instances and therefore their
     * default value will overwrite any element default (e.g. if the element sets
     * this.id = 'id' in the constructor, the 'id' will become '' since this is
     * the native platform default).
     */
    __saveInstanceProperties() {
        // Use forEach so this works even if for/of loops are compiled to for loops
        // expecting arrays
        this.constructor.elementProperties.forEach((_v, p) => {
            if (this.hasOwnProperty(p)) {
                this.__instanceProperties.set(p, this[p]);
                delete this[p];
            }
        });
    }
    /**
     * Returns the node into which the element should render and by default
     * creates and returns an open shadowRoot. Implement to customize where the
     * element's DOM is rendered. For example, to render into the element's
     * childNodes, return `this`.
     *
     * @return Returns a node into which to render.
     * @category rendering
     */
    createRenderRoot() {
        var _a;
        const renderRoot = (_a = this.shadowRoot) !== null && _a !== void 0 ? _a : this.attachShadow(this.constructor.shadowRootOptions);
        (0,_css_tag_js__WEBPACK_IMPORTED_MODULE_0__.adoptStyles)(renderRoot, this.constructor.elementStyles);
        return renderRoot;
    }
    /**
     * On first connection, creates the element's renderRoot, sets up
     * element styling, and enables updating.
     * @category lifecycle
     */
    connectedCallback() {
        var _a;
        // create renderRoot before first update.
        if (this.renderRoot === undefined) {
            this.renderRoot = this.createRenderRoot();
        }
        this.enableUpdating(true);
        (_a = this.__controllers) === null || _a === void 0 ? void 0 : _a.forEach((c) => { var _a; return (_a = c.hostConnected) === null || _a === void 0 ? void 0 : _a.call(c); });
    }
    /**
     * Note, this method should be considered final and not overridden. It is
     * overridden on the element instance with a function that triggers the first
     * update.
     * @category updates
     */
    enableUpdating(_requestedUpdate) { }
    /**
     * Allows for `super.disconnectedCallback()` in extensions while
     * reserving the possibility of making non-breaking feature additions
     * when disconnecting at some point in the future.
     * @category lifecycle
     */
    disconnectedCallback() {
        var _a;
        (_a = this.__controllers) === null || _a === void 0 ? void 0 : _a.forEach((c) => { var _a; return (_a = c.hostDisconnected) === null || _a === void 0 ? void 0 : _a.call(c); });
    }
    /**
     * Synchronizes property values when attributes change.
     *
     * Specifically, when an attribute is set, the corresponding property is set.
     * You should rarely need to implement this callback. If this method is
     * overridden, `super.attributeChangedCallback(name, _old, value)` must be
     * called.
     *
     * See [using the lifecycle callbacks](https://developer.mozilla.org/en-US/docs/Web/Web_Components/Using_custom_elements#using_the_lifecycle_callbacks)
     * on MDN for more information about the `attributeChangedCallback`.
     * @category attributes
     */
    attributeChangedCallback(name, _old, value) {
        this._$attributeToProperty(name, value);
    }
    __propertyToAttribute(name, value, options = defaultPropertyDeclaration) {
        var _a;
        const attr = this.constructor.__attributeNameForProperty(name, options);
        if (attr !== undefined && options.reflect === true) {
            const converter = ((_a = options.converter) === null || _a === void 0 ? void 0 : _a.toAttribute) !==
                undefined
                ? options.converter
                : defaultConverter;
            const attrValue = converter.toAttribute(value, options.type);
            if (DEV_MODE &&
                this.constructor.enabledWarnings.indexOf('migration') >= 0 &&
                attrValue === undefined) {
                issueWarning('undefined-attribute-value', `The attribute value for the ${name} property is ` +
                    `undefined on element ${this.localName}. The attribute will be ` +
                    `removed, but in the previous version of \`ReactiveElement\`, ` +
                    `the attribute would not have changed.`);
            }
            // Track if the property is being reflected to avoid
            // setting the property again via `attributeChangedCallback`. Note:
            // 1. this takes advantage of the fact that the callback is synchronous.
            // 2. will behave incorrectly if multiple attributes are in the reaction
            // stack at time of calling. However, since we process attributes
            // in `update` this should not be possible (or an extreme corner case
            // that we'd like to discover).
            // mark state reflecting
            this.__reflectingProperty = name;
            if (attrValue == null) {
                this.removeAttribute(attr);
            }
            else {
                this.setAttribute(attr, attrValue);
            }
            // mark state not reflecting
            this.__reflectingProperty = null;
        }
    }
    /** @internal */
    _$attributeToProperty(name, value) {
        var _a;
        const ctor = this.constructor;
        // Note, hint this as an `AttributeMap` so closure clearly understands
        // the type; it has issues with tracking types through statics
        const propName = ctor.__attributeToPropertyMap.get(name);
        // Use tracking info to avoid reflecting a property value to an attribute
        // if it was just set because the attribute changed.
        if (propName !== undefined && this.__reflectingProperty !== propName) {
            const options = ctor.getPropertyOptions(propName);
            const converter = typeof options.converter === 'function'
                ? { fromAttribute: options.converter }
                : ((_a = options.converter) === null || _a === void 0 ? void 0 : _a.fromAttribute) !== undefined
                    ? options.converter
                    : defaultConverter;
            // mark state reflecting
            this.__reflectingProperty = propName;
            this[propName] = converter.fromAttribute(value, options.type
            // eslint-disable-next-line @typescript-eslint/no-explicit-any
            );
            // mark state not reflecting
            this.__reflectingProperty = null;
        }
    }
    /**
     * Requests an update which is processed asynchronously. This should be called
     * when an element should update based on some state not triggered by setting
     * a reactive property. In this case, pass no arguments. It should also be
     * called when manually implementing a property setter. In this case, pass the
     * property `name` and `oldValue` to ensure that any configured property
     * options are honored.
     *
     * @param name name of requesting property
     * @param oldValue old value of requesting property
     * @param options property options to use instead of the previously
     *     configured options
     * @category updates
     */
    requestUpdate(name, oldValue, options) {
        let shouldRequestUpdate = true;
        // If we have a property key, perform property update steps.
        if (name !== undefined) {
            options =
                options ||
                    this.constructor.getPropertyOptions(name);
            const hasChanged = options.hasChanged || notEqual;
            if (hasChanged(this[name], oldValue)) {
                if (!this._$changedProperties.has(name)) {
                    this._$changedProperties.set(name, oldValue);
                }
                // Add to reflecting properties set.
                // Note, it's important that every change has a chance to add the
                // property to `_reflectingProperties`. This ensures setting
                // attribute + property reflects correctly.
                if (options.reflect === true && this.__reflectingProperty !== name) {
                    if (this.__reflectingProperties === undefined) {
                        this.__reflectingProperties = new Map();
                    }
                    this.__reflectingProperties.set(name, options);
                }
            }
            else {
                // Abort the request if the property should not be considered changed.
                shouldRequestUpdate = false;
            }
        }
        if (!this.isUpdatePending && shouldRequestUpdate) {
            this.__updatePromise = this.__enqueueUpdate();
        }
        // Note, since this no longer returns a promise, in dev mode we return a
        // thenable which warns if it's called.
        return DEV_MODE
            ? requestUpdateThenable(this.localName)
            : undefined;
    }
    /**
     * Sets up the element to asynchronously update.
     */
    async __enqueueUpdate() {
        this.isUpdatePending = true;
        try {
            // Ensure any previous update has resolved before updating.
            // This `await` also ensures that property changes are batched.
            await this.__updatePromise;
        }
        catch (e) {
            // Refire any previous errors async so they do not disrupt the update
            // cycle. Errors are refired so developers have a chance to observe
            // them, and this can be done by implementing
            // `window.onunhandledrejection`.
            Promise.reject(e);
        }
        const result = this.scheduleUpdate();
        // If `scheduleUpdate` returns a Promise, we await it. This is done to
        // enable coordinating updates with a scheduler. Note, the result is
        // checked to avoid delaying an additional microtask unless we need to.
        if (result != null) {
            await result;
        }
        return !this.isUpdatePending;
    }
    /**
     * Schedules an element update. You can override this method to change the
     * timing of updates by returning a Promise. The update will await the
     * returned Promise, and you should resolve the Promise to allow the update
     * to proceed. If this method is overridden, `super.scheduleUpdate()`
     * must be called.
     *
     * For instance, to schedule updates to occur just before the next frame:
     *
     * ```ts
     * override protected async scheduleUpdate(): Promise<unknown> {
     *   await new Promise((resolve) => requestAnimationFrame(() => resolve()));
     *   super.scheduleUpdate();
     * }
     * ```
     * @category updates
     */
    scheduleUpdate() {
        return this.performUpdate();
    }
    /**
     * Performs an element update. Note, if an exception is thrown during the
     * update, `firstUpdated` and `updated` will not be called.
     *
     * Call `performUpdate()` to immediately process a pending update. This should
     * generally not be needed, but it can be done in rare cases when you need to
     * update synchronously.
     *
     * Note: To ensure `performUpdate()` synchronously completes a pending update,
     * it should not be overridden. In LitElement 2.x it was suggested to override
     * `performUpdate()` to also customizing update scheduling. Instead, you should now
     * override `scheduleUpdate()`. For backwards compatibility with LitElement 2.x,
     * scheduling updates via `performUpdate()` continues to work, but will make
     * also calling `performUpdate()` to synchronously process updates difficult.
     *
     * @category updates
     */
    performUpdate() {
        var _a, _b;
        // Abort any update if one is not pending when this is called.
        // This can happen if `performUpdate` is called early to "flush"
        // the update.
        if (!this.isUpdatePending) {
            return;
        }
        debugLogEvent === null || debugLogEvent === void 0 ? void 0 : debugLogEvent({ kind: 'update' });
        // create renderRoot before first update.
        if (!this.hasUpdated) {
            // Produce warning if any class properties are shadowed by class fields
            if (DEV_MODE) {
                const shadowedProperties = [];
                (_a = this.constructor.__reactivePropertyKeys) === null || _a === void 0 ? void 0 : _a.forEach((p) => {
                    var _a;
                    if (this.hasOwnProperty(p) && !((_a = this.__instanceProperties) === null || _a === void 0 ? void 0 : _a.has(p))) {
                        shadowedProperties.push(p);
                    }
                });
                if (shadowedProperties.length) {
                    throw new Error(`The following properties on element ${this.localName} will not ` +
                        `trigger updates as expected because they are set using class ` +
                        `fields: ${shadowedProperties.join(', ')}. ` +
                        `Native class fields and some compiled output will overwrite ` +
                        `accessors used for detecting changes. See ` +
                        `https://lit.dev/msg/class-field-shadowing ` +
                        `for more information.`);
                }
            }
        }
        // Mixin instance properties once, if they exist.
        if (this.__instanceProperties) {
            // Use forEach so this works even if for/of loops are compiled to for loops
            // expecting arrays
            // eslint-disable-next-line @typescript-eslint/no-explicit-any
            this.__instanceProperties.forEach((v, p) => (this[p] = v));
            this.__instanceProperties = undefined;
        }
        let shouldUpdate = false;
        const changedProperties = this._$changedProperties;
        try {
            shouldUpdate = this.shouldUpdate(changedProperties);
            if (shouldUpdate) {
                this.willUpdate(changedProperties);
                (_b = this.__controllers) === null || _b === void 0 ? void 0 : _b.forEach((c) => { var _a; return (_a = c.hostUpdate) === null || _a === void 0 ? void 0 : _a.call(c); });
                this.update(changedProperties);
            }
            else {
                this.__markUpdated();
            }
        }
        catch (e) {
            // Prevent `firstUpdated` and `updated` from running when there's an
            // update exception.
            shouldUpdate = false;
            // Ensure element can accept additional updates after an exception.
            this.__markUpdated();
            throw e;
        }
        // The update is no longer considered pending and further updates are now allowed.
        if (shouldUpdate) {
            this._$didUpdate(changedProperties);
        }
    }
    /**
     * Invoked before `update()` to compute values needed during the update.
     *
     * Implement `willUpdate` to compute property values that depend on other
     * properties and are used in the rest of the update process.
     *
     * ```ts
     * willUpdate(changedProperties) {
     *   // only need to check changed properties for an expensive computation.
     *   if (changedProperties.has('firstName') || changedProperties.has('lastName')) {
     *     this.sha = computeSHA(`${this.firstName} ${this.lastName}`);
     *   }
     * }
     *
     * render() {
     *   return html`SHA: ${this.sha}`;
     * }
     * ```
     *
     * @category updates
     */
    willUpdate(_changedProperties) { }
    // Note, this is an override point for polyfill-support.
    // @internal
    _$didUpdate(changedProperties) {
        var _a;
        (_a = this.__controllers) === null || _a === void 0 ? void 0 : _a.forEach((c) => { var _a; return (_a = c.hostUpdated) === null || _a === void 0 ? void 0 : _a.call(c); });
        if (!this.hasUpdated) {
            this.hasUpdated = true;
            this.firstUpdated(changedProperties);
        }
        this.updated(changedProperties);
        if (DEV_MODE &&
            this.isUpdatePending &&
            this.constructor.enabledWarnings.indexOf('change-in-update') >= 0) {
            issueWarning('change-in-update', `Element ${this.localName} scheduled an update ` +
                `(generally because a property was set) ` +
                `after an update completed, causing a new update to be scheduled. ` +
                `This is inefficient and should be avoided unless the next update ` +
                `can only be scheduled as a side effect of the previous update.`);
        }
    }
    __markUpdated() {
        this._$changedProperties = new Map();
        this.isUpdatePending = false;
    }
    /**
     * Returns a Promise that resolves when the element has completed updating.
     * The Promise value is a boolean that is `true` if the element completed the
     * update without triggering another update. The Promise result is `false` if
     * a property was set inside `updated()`. If the Promise is rejected, an
     * exception was thrown during the update.
     *
     * To await additional asynchronous work, override the `getUpdateComplete`
     * method. For example, it is sometimes useful to await a rendered element
     * before fulfilling this Promise. To do this, first await
     * `super.getUpdateComplete()`, then any subsequent state.
     *
     * @return A promise of a boolean that resolves to true if the update completed
     *     without triggering another update.
     * @category updates
     */
    get updateComplete() {
        return this.getUpdateComplete();
    }
    /**
     * Override point for the `updateComplete` promise.
     *
     * It is not safe to override the `updateComplete` getter directly due to a
     * limitation in TypeScript which means it is not possible to call a
     * superclass getter (e.g. `super.updateComplete.then(...)`) when the target
     * language is ES5 (https://github.com/microsoft/TypeScript/issues/338).
     * This method should be overridden instead. For example:
     *
     * ```ts
     * class MyElement extends LitElement {
     *   override async getUpdateComplete() {
     *     const result = await super.getUpdateComplete();
     *     await this._myChild.updateComplete;
     *     return result;
     *   }
     * }
     * ```
     *
     * @return A promise of a boolean that resolves to true if the update completed
     *     without triggering another update.
     * @category updates
     */
    getUpdateComplete() {
        return this.__updatePromise;
    }
    /**
     * Controls whether or not `update()` should be called when the element requests
     * an update. By default, this method always returns `true`, but this can be
     * customized to control when to update.
     *
     * @param _changedProperties Map of changed properties with old values
     * @category updates
     */
    shouldUpdate(_changedProperties) {
        return true;
    }
    /**
     * Updates the element. This method reflects property values to attributes.
     * It can be overridden to render and keep updated element DOM.
     * Setting properties inside this method will *not* trigger
     * another update.
     *
     * @param _changedProperties Map of changed properties with old values
     * @category updates
     */
    update(_changedProperties) {
        if (this.__reflectingProperties !== undefined) {
            // Use forEach so this works even if for/of loops are compiled to for
            // loops expecting arrays
            this.__reflectingProperties.forEach((v, k) => this.__propertyToAttribute(k, this[k], v));
            this.__reflectingProperties = undefined;
        }
        this.__markUpdated();
    }
    /**
     * Invoked whenever the element is updated. Implement to perform
     * post-updating tasks via DOM APIs, for example, focusing an element.
     *
     * Setting properties inside this method will trigger the element to update
     * again after this update cycle completes.
     *
     * @param _changedProperties Map of changed properties with old values
     * @category updates
     */
    updated(_changedProperties) { }
    /**
     * Invoked when the element is first updated. Implement to perform one time
     * work on the element after update.
     *
     * ```ts
     * firstUpdated() {
     *   this.renderRoot.getElementById('my-text-area').focus();
     * }
     * ```
     *
     * Setting properties inside this method will trigger the element to update
     * again after this update cycle completes.
     *
     * @param _changedProperties Map of changed properties with old values
     * @category updates
     */
    firstUpdated(_changedProperties) { }
}
_e = finalized;
/**
 * Marks class as having finished creating properties.
 */
ReactiveElement[_e] = true;
/**
 * Memoized list of all element properties, including any superclass properties.
 * Created lazily on user subclasses when finalizing the class.
 * @nocollapse
 * @category properties
 */
ReactiveElement.elementProperties = new Map();
/**
 * Memoized list of all element styles.
 * Created lazily on user subclasses when finalizing the class.
 * @nocollapse
 * @category styles
 */
ReactiveElement.elementStyles = [];
/**
 * Options used when calling `attachShadow`. Set this property to customize
 * the options for the shadowRoot; for example, to create a closed
 * shadowRoot: `{mode: 'closed'}`.
 *
 * Note, these options are used in `createRenderRoot`. If this method
 * is customized, options should be respected if possible.
 * @nocollapse
 * @category rendering
 */
ReactiveElement.shadowRootOptions = { mode: 'open' };
// Apply polyfills if available
polyfillSupport === null || polyfillSupport === void 0 ? void 0 : polyfillSupport({ ReactiveElement });
// Dev mode warnings...
if (DEV_MODE) {
    // Default warning set.
    ReactiveElement.enabledWarnings = ['change-in-update'];
    const ensureOwnWarnings = function (ctor) {
        if (!ctor.hasOwnProperty(JSCompiler_renameProperty('enabledWarnings', ctor))) {
            ctor.enabledWarnings = ctor.enabledWarnings.slice();
        }
    };
    ReactiveElement.enableWarning = function (warning) {
        ensureOwnWarnings(this);
        if (this.enabledWarnings.indexOf(warning) < 0) {
            this.enabledWarnings.push(warning);
        }
    };
    ReactiveElement.disableWarning = function (warning) {
        ensureOwnWarnings(this);
        const i = this.enabledWarnings.indexOf(warning);
        if (i >= 0) {
            this.enabledWarnings.splice(i, 1);
        }
    };
}
// IMPORTANT: do not change the property name or the assignment expression.
// This line will be used in regexes to search for ReactiveElement usage.
((_d = global.reactiveElementVersions) !== null && _d !== void 0 ? _d : (global.reactiveElementVersions = [])).push('1.6.3');
if (DEV_MODE && global.reactiveElementVersions.length > 1) {
    issueWarning('multiple-versions', `Multiple versions of Lit loaded. Loading multiple versions ` +
        `is not recommended.`);
}
//# sourceMappingURL=reactive-element.js.map

/***/ }),

/***/ "./node_modules/element-internals-polyfill/dist/index.js":
/*!***************************************************************!*\
  !*** ./node_modules/element-internals-polyfill/dist/index.js ***!
  \***************************************************************/
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

"use strict";
__webpack_require__.r(__webpack_exports__);
(function (exports) {
    'use strict';

    const refMap = new WeakMap();
    const validityMap = new WeakMap();
    const hiddenInputMap = new WeakMap();
    const internalsMap = new WeakMap();
    const validationMessageMap = new WeakMap();
    const formsMap = new WeakMap();
    const shadowHostsMap = new WeakMap();
    const formElementsMap = new WeakMap();
    const refValueMap = new WeakMap();
    const upgradeMap = new WeakMap();
    const shadowRootMap = new WeakMap();
    const validationAnchorMap = new WeakMap();
    const documentFragmentMap = new WeakMap();
    const connectedCallbackMap = new WeakMap();
    const validityUpgradeMap = new WeakMap();

    const aom = {
        ariaAtomic: 'aria-atomic',
        ariaAutoComplete: 'aria-autocomplete',
        ariaBusy: 'aria-busy',
        ariaChecked: 'aria-checked',
        ariaColCount: 'aria-colcount',
        ariaColIndex: 'aria-colindex',
        ariaColIndexText: 'aria-colindextext',
        ariaColSpan: 'aria-colspan',
        ariaCurrent: 'aria-current',
        ariaDescription: 'aria-description',
        ariaDisabled: 'aria-disabled',
        ariaExpanded: 'aria-expanded',
        ariaHasPopup: 'aria-haspopup',
        ariaHidden: 'aria-hidden',
        ariaInvalid: 'aria-invalid',
        ariaKeyShortcuts: 'aria-keyshortcuts',
        ariaLabel: 'aria-label',
        ariaLevel: 'aria-level',
        ariaLive: 'aria-live',
        ariaModal: 'aria-modal',
        ariaMultiLine: 'aria-multiline',
        ariaMultiSelectable: 'aria-multiselectable',
        ariaOrientation: 'aria-orientation',
        ariaPlaceholder: 'aria-placeholder',
        ariaPosInSet: 'aria-posinset',
        ariaPressed: 'aria-pressed',
        ariaReadOnly: 'aria-readonly',
        ariaRelevant: 'aria-relevant',
        ariaRequired: 'aria-required',
        ariaRoleDescription: 'aria-roledescription',
        ariaRowCount: 'aria-rowcount',
        ariaRowIndex: 'aria-rowindex',
        ariaRowIndexText: 'aria-rowindextext',
        ariaRowSpan: 'aria-rowspan',
        ariaSelected: 'aria-selected',
        ariaSetSize: 'aria-setsize',
        ariaSort: 'aria-sort',
        ariaValueMax: 'aria-valuemax',
        ariaValueMin: 'aria-valuemin',
        ariaValueNow: 'aria-valuenow',
        ariaValueText: 'aria-valuetext',
        role: 'role'
    };
    const initAom = (ref, internals) => {
        for (let key in aom) {
            internals[key] = null;
            let closureValue = null;
            const attributeName = aom[key];
            Object.defineProperty(internals, key, {
                get() {
                    return closureValue;
                },
                set(value) {
                    closureValue = value;
                    if (ref.isConnected) {
                        ref.setAttribute(attributeName, value);
                    }
                    else {
                        upgradeMap.set(ref, internals);
                    }
                }
            });
        }
    };

    function initNode(node) {
        const internals = internalsMap.get(node);
        const { form } = internals;
        initForm(node, form, internals);
        initLabels(node, internals.labels);
    }
    const walkFieldset = (node, firstRender = false) => {
        const walker = document.createTreeWalker(node, NodeFilter.SHOW_ELEMENT, {
            acceptNode(node) {
                return internalsMap.has(node) ?
                    NodeFilter.FILTER_ACCEPT : NodeFilter.FILTER_SKIP;
            }
        });
        let current = walker.nextNode();
        const isCallNecessary = (!firstRender || node.disabled);
        while (current) {
            if (current.formDisabledCallback && isCallNecessary) {
                setDisabled(current, node.disabled);
            }
            current = walker.nextNode();
        }
    };
    const disabledOrNameObserverConfig = { attributes: true, attributeFilter: ['disabled', 'name'] };
    const disabledOrNameObserver = mutationObserverExists() ? new MutationObserver((mutationsList) => {
        for (const mutation of mutationsList) {
            const target = mutation.target;
            if (mutation.attributeName === 'disabled') {
                if (target.constructor['formAssociated']) {
                    setDisabled(target, target.hasAttribute('disabled'));
                }
                else if (target.localName === 'fieldset') {
                    walkFieldset(target);
                }
            }
            if (mutation.attributeName === 'name') {
                if (target.constructor['formAssociated']) {
                    const internals = internalsMap.get(target);
                    const value = refValueMap.get(target);
                    internals.setFormValue(value);
                }
            }
        }
    }) : {};
    function observerCallback(mutationList) {
        mutationList.forEach(mutationRecord => {
            const { addedNodes, removedNodes } = mutationRecord;
            const added = Array.from(addedNodes);
            const removed = Array.from(removedNodes);
            added.forEach(node => {
                var _a;
                if (internalsMap.has(node) && node.constructor['formAssociated']) {
                    initNode(node);
                }
                if (upgradeMap.has(node)) {
                    const internals = upgradeMap.get(node);
                    const aomKeys = Object.keys(aom);
                    aomKeys
                        .filter(key => internals[key] !== null)
                        .forEach(key => {
                        node.setAttribute(aom[key], internals[key]);
                    });
                    upgradeMap.delete(node);
                }
                if (validityUpgradeMap.has(node)) {
                    const internals = validityUpgradeMap.get(node);
                    node.setAttribute('internals-valid', internals.validity.valid.toString());
                    node.setAttribute('internals-invalid', (!internals.validity.valid).toString());
                    node.setAttribute('aria-invalid', (!internals.validity.valid).toString());
                    validityUpgradeMap.delete(node);
                }
                if (node.localName === 'form') {
                    const formElements = formElementsMap.get(node);
                    const walker = document.createTreeWalker(node, NodeFilter.SHOW_ELEMENT, {
                        acceptNode(node) {
                            return (internalsMap.has(node) && node.constructor['formAssociated'] && !(formElements && formElements.has(node))) ? NodeFilter.FILTER_ACCEPT : NodeFilter.FILTER_SKIP;
                        }
                    });
                    let current = walker.nextNode();
                    while (current) {
                        initNode(current);
                        current = walker.nextNode();
                    }
                }
                if (node.localName === 'fieldset') {
                    (_a = disabledOrNameObserver.observe) === null || _a === void 0 ? void 0 : _a.call(disabledOrNameObserver, node, disabledOrNameObserverConfig);
                    walkFieldset(node, true);
                }
            });
            removed.forEach(node => {
                const internals = internalsMap.get(node);
                if (internals && hiddenInputMap.get(internals)) {
                    removeHiddenInputs(internals);
                }
                if (shadowHostsMap.has(node)) {
                    const observer = shadowHostsMap.get(node);
                    observer.disconnect();
                }
            });
        });
    }
    function fragmentObserverCallback(mutationList) {
        mutationList.forEach(mutation => {
            const { removedNodes } = mutation;
            removedNodes.forEach(node => {
                const observer = documentFragmentMap.get(mutation.target);
                if (internalsMap.has(node)) {
                    upgradeInternals(node);
                }
                observer.disconnect();
            });
        });
    }
    const deferUpgrade = (fragment) => {
        var _a, _b;
        const observer = new MutationObserver(fragmentObserverCallback);
        if (((_a = window === null || window === void 0 ? void 0 : window.ShadyDOM) === null || _a === void 0 ? void 0 : _a.inUse) &&
            fragment.mode &&
            fragment.host) {
            fragment = fragment.host;
        }
        (_b = observer.observe) === null || _b === void 0 ? void 0 : _b.call(observer, fragment, { childList: true });
        documentFragmentMap.set(fragment, observer);
    };
    mutationObserverExists() ? new MutationObserver(observerCallback) : {};
    const observerConfig = {
        childList: true,
        subtree: true
    };

    const setDisabled = (ref, disabled) => {
        ref.toggleAttribute('internals-disabled', disabled);
        if (disabled) {
            ref.setAttribute('aria-disabled', 'true');
        }
        else {
            ref.removeAttribute('aria-disabled');
        }
        if (ref.formDisabledCallback) {
            ref.formDisabledCallback.apply(ref, [disabled]);
        }
    };
    const removeHiddenInputs = (internals) => {
        const hiddenInputs = hiddenInputMap.get(internals);
        hiddenInputs.forEach(hiddenInput => {
            hiddenInput.remove();
        });
        hiddenInputMap.set(internals, []);
    };
    const createHiddenInput = (ref, internals) => {
        const input = document.createElement('input');
        input.type = 'hidden';
        input.name = ref.getAttribute('name');
        ref.after(input);
        hiddenInputMap.get(internals).push(input);
        return input;
    };
    const initRef = (ref, internals) => {
        var _a;
        hiddenInputMap.set(internals, []);
        (_a = disabledOrNameObserver.observe) === null || _a === void 0 ? void 0 : _a.call(disabledOrNameObserver, ref, disabledOrNameObserverConfig);
    };
    const initLabels = (ref, labels) => {
        if (labels.length) {
            Array.from(labels).forEach(label => label.addEventListener('click', ref.click.bind(ref)));
            let firstLabelId = labels[0].id;
            if (!labels[0].id) {
                firstLabelId = `${labels[0].htmlFor}_Label`;
                labels[0].id = firstLabelId;
            }
            ref.setAttribute('aria-labelledby', firstLabelId);
        }
    };
    const setFormValidity = (form) => {
        const nativeControlValidity = Array.from(form.elements)
            .filter((element) => !element.tagName.includes('-') && element.validity)
            .map((element) => element.validity.valid);
        const polyfilledElements = formElementsMap.get(form) || [];
        const polyfilledValidity = Array.from(polyfilledElements)
            .filter(control => control.isConnected)
            .map((control) => internalsMap.get(control).validity.valid);
        const hasInvalid = [...nativeControlValidity, ...polyfilledValidity].includes(false);
        form.toggleAttribute('internals-invalid', hasInvalid);
        form.toggleAttribute('internals-valid', !hasInvalid);
    };
    const formInputCallback = (event) => {
        setFormValidity(findParentForm(event.target));
    };
    const formChangeCallback = (event) => {
        setFormValidity(findParentForm(event.target));
    };
    const wireSubmitLogic = (form) => {
        const submitButtonSelector = ['button[type=submit]', 'input[type=submit]', 'button:not([type])']
            .map(sel => `${sel}:not([disabled])`)
            .map(sel => `${sel}:not([form])${form.id ? `,${sel}[form='${form.id}']` : ''}`)
            .join(',');
        form.addEventListener('click', event => {
            const target = event.target;
            if (target.closest(submitButtonSelector)) {
                const elements = formElementsMap.get(form);
                if (form.noValidate) {
                    return;
                }
                if (elements.size) {
                    const nodes = Array.from(elements);
                    const validityList = nodes
                        .reverse()
                        .map(node => {
                        const internals = internalsMap.get(node);
                        return internals.reportValidity();
                    });
                    if (validityList.includes(false)) {
                        event.preventDefault();
                    }
                }
            }
        });
    };
    const formResetCallback = (event) => {
        const elements = formElementsMap.get(event.target);
        if (elements && elements.size) {
            elements.forEach(element => {
                if (element.constructor.formAssociated && element.formResetCallback) {
                    element.formResetCallback.apply(element);
                }
            });
        }
    };
    const initForm = (ref, form, internals) => {
        if (form) {
            const formElements = formElementsMap.get(form);
            if (formElements) {
                formElements.add(ref);
            }
            else {
                const initSet = new Set();
                initSet.add(ref);
                formElementsMap.set(form, initSet);
                wireSubmitLogic(form);
                form.addEventListener('reset', formResetCallback);
                form.addEventListener('input', formInputCallback);
                form.addEventListener('change', formChangeCallback);
            }
            formsMap.set(form, { ref, internals });
            if (ref.constructor['formAssociated'] && ref.formAssociatedCallback) {
                setTimeout(() => {
                    ref.formAssociatedCallback.apply(ref, [form]);
                }, 0);
            }
            setFormValidity(form);
        }
    };
    const findParentForm = (elem) => {
        let parent = elem.parentNode;
        if (parent && parent.tagName !== 'FORM') {
            parent = findParentForm(parent);
        }
        return parent;
    };
    const throwIfNotFormAssociated = (ref, message, ErrorType = DOMException) => {
        if (!ref.constructor['formAssociated']) {
            throw new ErrorType(message);
        }
    };
    const overrideFormMethod = (form, returnValue, method) => {
        const elements = formElementsMap.get(form);
        if (elements && elements.size) {
            elements.forEach(element => {
                const internals = internalsMap.get(element);
                const valid = internals[method]();
                if (!valid) {
                    returnValue = false;
                }
            });
        }
        return returnValue;
    };
    const upgradeInternals = (ref) => {
        if (ref.constructor['formAssociated']) {
            const internals = internalsMap.get(ref);
            const { labels, form } = internals;
            initLabels(ref, labels);
            initForm(ref, form, internals);
        }
    };
    function mutationObserverExists() {
        return typeof MutationObserver !== 'undefined';
    }

    class ValidityState {
        constructor() {
            this.badInput = false;
            this.customError = false;
            this.patternMismatch = false;
            this.rangeOverflow = false;
            this.rangeUnderflow = false;
            this.stepMismatch = false;
            this.tooLong = false;
            this.tooShort = false;
            this.typeMismatch = false;
            this.valid = true;
            this.valueMissing = false;
            Object.seal(this);
        }
    }
    const setValid = (validityObject) => {
        validityObject.badInput = false;
        validityObject.customError = false;
        validityObject.patternMismatch = false;
        validityObject.rangeOverflow = false;
        validityObject.rangeUnderflow = false;
        validityObject.stepMismatch = false;
        validityObject.tooLong = false;
        validityObject.tooShort = false;
        validityObject.typeMismatch = false;
        validityObject.valid = true;
        validityObject.valueMissing = false;
        return validityObject;
    };
    const reconcileValidity = (validityObject, newState, form) => {
        validityObject.valid = isValid(newState);
        Object.keys(newState).forEach(key => validityObject[key] = newState[key]);
        if (form) {
            setFormValidity(form);
        }
        return validityObject;
    };
    const isValid = (validityState) => {
        let valid = true;
        for (let key in validityState) {
            if (key !== 'valid' && validityState[key] !== false) {
                valid = false;
            }
        }
        return valid;
    };

    const customStateMap = new WeakMap();
    function addState(ref, stateName) {
        ref.toggleAttribute(stateName, true);
        if (ref.part) {
            ref.part.add(stateName);
        }
    }
    class CustomStateSet extends Set {
        static get isPolyfilled() {
            return true;
        }
        constructor(ref) {
            super();
            if (!ref || !ref.tagName || ref.tagName.indexOf('-') === -1) {
                throw new TypeError('Illegal constructor');
            }
            customStateMap.set(this, ref);
        }
        add(state) {
            if (!/^--/.test(state) || typeof state !== 'string') {
                throw new DOMException(`Failed to execute 'add' on 'CustomStateSet': The specified value ${state} must start with '--'.`);
            }
            const result = super.add(state);
            const ref = customStateMap.get(this);
            const stateName = `state${state}`;
            if (ref.isConnected) {
                addState(ref, stateName);
            }
            else {
                setTimeout(() => {
                    addState(ref, stateName);
                });
            }
            return result;
        }
        clear() {
            for (let [entry] of this.entries()) {
                this.delete(entry);
            }
            super.clear();
        }
        delete(state) {
            const result = super.delete(state);
            const ref = customStateMap.get(this);
            if (ref.isConnected) {
                ref.toggleAttribute(`state${state}`, false);
                if (ref.part) {
                    ref.part.remove(`state${state}`);
                }
            }
            else {
                setTimeout(() => {
                    ref.toggleAttribute(`state${state}`, false);
                    if (ref.part) {
                        ref.part.remove(`state${state}`);
                    }
                });
            }
            return result;
        }
    }

    function __classPrivateFieldGet(receiver, state, kind, f) {
        if (kind === "a" && !f) throw new TypeError("Private accessor was defined without a getter");
        if (typeof state === "function" ? receiver !== state || !f : !state.has(receiver)) throw new TypeError("Cannot read private member from an object whose class did not declare it");
        return kind === "m" ? f : kind === "a" ? f.call(receiver) : f ? f.value : state.get(receiver);
    }
    function __classPrivateFieldSet(receiver, state, value, kind, f) {
        if (kind === "m") throw new TypeError("Private method is not writable");
        if (kind === "a" && !f) throw new TypeError("Private accessor was defined without a setter");
        if (typeof state === "function" ? receiver !== state || !f : !state.has(receiver)) throw new TypeError("Cannot write private member to an object whose class did not declare it");
        return (kind === "a" ? f.call(receiver, value) : f ? f.value = value : state.set(receiver, value)), value;
    }

    var _HTMLFormControlsCollection_elements;
    class HTMLFormControlsCollection {
        constructor(elements) {
            _HTMLFormControlsCollection_elements.set(this, void 0);
            __classPrivateFieldSet(this, _HTMLFormControlsCollection_elements, elements, "f");
            for (let i = 0; i < elements.length; i++) {
                let element = elements[i];
                this[i] = element;
                if (element.hasAttribute('name')) {
                    this[element.getAttribute('name')] = element;
                }
            }
            Object.freeze(this);
        }
        get length() {
            return __classPrivateFieldGet(this, _HTMLFormControlsCollection_elements, "f").length;
        }
        [(_HTMLFormControlsCollection_elements = new WeakMap(), Symbol.iterator)]() {
            return __classPrivateFieldGet(this, _HTMLFormControlsCollection_elements, "f")[Symbol.iterator]();
        }
        item(i) {
            return this[i] == null ? null : this[i];
        }
        namedItem(name) {
            return this[name] == null ? null : this[name];
        }
    }

    function patchFormPrototype() {
        const checkValidity = HTMLFormElement.prototype.checkValidity;
        HTMLFormElement.prototype.checkValidity = checkValidityOverride;
        const reportValidity = HTMLFormElement.prototype.reportValidity;
        HTMLFormElement.prototype.reportValidity = reportValidityOverride;
        function checkValidityOverride(...args) {
            let returnValue = checkValidity.apply(this, args);
            return overrideFormMethod(this, returnValue, 'checkValidity');
        }
        function reportValidityOverride(...args) {
            let returnValue = reportValidity.apply(this, args);
            return overrideFormMethod(this, returnValue, 'reportValidity');
        }
        const { get } = Object.getOwnPropertyDescriptor(HTMLFormElement.prototype, 'elements');
        Object.defineProperty(HTMLFormElement.prototype, 'elements', {
            get(...args) {
                const elements = get.call(this, ...args);
                const polyfilledElements = Array.from(formElementsMap.get(this) || []);
                if (polyfilledElements.length === 0) {
                    return elements;
                }
                const orderedElements = Array.from(elements).concat(polyfilledElements).sort((a, b) => {
                    if (a.compareDocumentPosition) {
                        return a.compareDocumentPosition(b) & 2 ? 1 : -1;
                    }
                    return 0;
                });
                return new HTMLFormControlsCollection(orderedElements);
            },
        });
    }

    class ElementInternals {
        static get isPolyfilled() {
            return true;
        }
        constructor(ref) {
            if (!ref || !ref.tagName || ref.tagName.indexOf('-') === -1) {
                throw new TypeError('Illegal constructor');
            }
            const rootNode = ref.getRootNode();
            const validity = new ValidityState();
            this.states = new CustomStateSet(ref);
            refMap.set(this, ref);
            validityMap.set(this, validity);
            internalsMap.set(ref, this);
            initAom(ref, this);
            initRef(ref, this);
            Object.seal(this);
            if (rootNode instanceof DocumentFragment) {
                deferUpgrade(rootNode);
            }
        }
        checkValidity() {
            const ref = refMap.get(this);
            throwIfNotFormAssociated(ref, `Failed to execute 'checkValidity' on 'ElementInternals': The target element is not a form-associated custom element.`);
            if (!this.willValidate) {
                return true;
            }
            const validity = validityMap.get(this);
            if (!validity.valid) {
                const validityEvent = new Event('invalid', {
                    bubbles: false,
                    cancelable: true,
                    composed: false
                });
                ref.dispatchEvent(validityEvent);
            }
            return validity.valid;
        }
        get form() {
            const ref = refMap.get(this);
            throwIfNotFormAssociated(ref, `Failed to read the 'form' property from 'ElementInternals': The target element is not a form-associated custom element.`);
            let form;
            if (ref.constructor['formAssociated'] === true) {
                form = findParentForm(ref);
            }
            return form;
        }
        get labels() {
            const ref = refMap.get(this);
            throwIfNotFormAssociated(ref, `Failed to read the 'labels' property from 'ElementInternals': The target element is not a form-associated custom element.`);
            const id = ref.getAttribute('id');
            const hostRoot = ref.getRootNode();
            if (hostRoot && id) {
                return hostRoot.querySelectorAll(`[for="${id}"]`);
            }
            return [];
        }
        reportValidity() {
            const ref = refMap.get(this);
            throwIfNotFormAssociated(ref, `Failed to execute 'reportValidity' on 'ElementInternals': The target element is not a form-associated custom element.`);
            if (!this.willValidate) {
                return true;
            }
            const valid = this.checkValidity();
            const anchor = validationAnchorMap.get(this);
            if (anchor && !ref.constructor['formAssociated']) {
                throw new DOMException(`Failed to execute 'reportValidity' on 'ElementInternals': The target element is not a form-associated custom element.`);
            }
            if (!valid && anchor) {
                ref.focus();
                anchor.focus();
            }
            return valid;
        }
        setFormValue(value) {
            const ref = refMap.get(this);
            throwIfNotFormAssociated(ref, `Failed to execute 'setFormValue' on 'ElementInternals': The target element is not a form-associated custom element.`);
            removeHiddenInputs(this);
            if (value != null && !(value instanceof FormData)) {
                if (ref.getAttribute('name')) {
                    const hiddenInput = createHiddenInput(ref, this);
                    hiddenInput.value = value;
                }
            }
            else if (value != null && value instanceof FormData) {
                Array.from(value).reverse().forEach(([formDataKey, formDataValue]) => {
                    if (typeof formDataValue === 'string') {
                        const hiddenInput = createHiddenInput(ref, this);
                        hiddenInput.name = formDataKey;
                        hiddenInput.value = formDataValue;
                    }
                });
            }
            refValueMap.set(ref, value);
        }
        setValidity(validityChanges, validationMessage, anchor) {
            const ref = refMap.get(this);
            throwIfNotFormAssociated(ref, `Failed to execute 'setValidity' on 'ElementInternals': The target element is not a form-associated custom element.`);
            if (!validityChanges) {
                throw new TypeError('Failed to execute \'setValidity\' on \'ElementInternals\': 1 argument required, but only 0 present.');
            }
            validationAnchorMap.set(this, anchor);
            const validity = validityMap.get(this);
            const validityChangesObj = {};
            for (const key in validityChanges) {
                validityChangesObj[key] = validityChanges[key];
            }
            if (Object.keys(validityChangesObj).length === 0) {
                setValid(validity);
            }
            const check = Object.assign(Object.assign({}, validity), validityChangesObj);
            delete check.valid;
            const { valid } = reconcileValidity(validity, check, this.form);
            if (!valid && !validationMessage) {
                throw new DOMException(`Failed to execute 'setValidity' on 'ElementInternals': The second argument should not be empty if one or more flags in the first argument are true.`);
            }
            validationMessageMap.set(this, valid ? '' : validationMessage);
            if (ref.isConnected) {
                ref.toggleAttribute('internals-invalid', !valid);
                ref.toggleAttribute('internals-valid', valid);
                ref.setAttribute('aria-invalid', `${!valid}`);
            }
            else {
                validityUpgradeMap.set(ref, this);
            }
        }
        get shadowRoot() {
            const ref = refMap.get(this);
            const shadowRoot = shadowRootMap.get(ref);
            if (shadowRoot) {
                return shadowRoot;
            }
            return null;
        }
        get validationMessage() {
            const ref = refMap.get(this);
            throwIfNotFormAssociated(ref, `Failed to read the 'validationMessage' property from 'ElementInternals': The target element is not a form-associated custom element.`);
            return validationMessageMap.get(this);
        }
        get validity() {
            const ref = refMap.get(this);
            throwIfNotFormAssociated(ref, `Failed to read the 'validity' property from 'ElementInternals': The target element is not a form-associated custom element.`);
            const validity = validityMap.get(this);
            return validity;
        }
        get willValidate() {
            const ref = refMap.get(this);
            throwIfNotFormAssociated(ref, `Failed to read the 'willValidate' property from 'ElementInternals': The target element is not a form-associated custom element.`);
            if ((ref.disabled || ref.hasAttribute('disabled')) ||
                ref.hasAttribute('readonly')) {
                return false;
            }
            return true;
        }
    }
    function isElementInternalsSupported() {
        if (typeof window === 'undefined' || !window.ElementInternals || !HTMLElement.prototype.attachInternals) {
            return false;
        }
        class ElementInternalsFeatureDetection extends HTMLElement {
            constructor() {
                super();
                this.internals = this.attachInternals();
            }
        }
        const randomName = `element-internals-feature-detection-${Math.random().toString(36).replace(/[^a-z]+/g, '')}`;
        customElements.define(randomName, ElementInternalsFeatureDetection);
        const featureDetectionElement = new ElementInternalsFeatureDetection();
        return [
            'shadowRoot',
            'form',
            'willValidate',
            'validity',
            'validationMessage',
            'labels',
            'setFormValue',
            'setValidity',
            'checkValidity',
            'reportValidity'
        ].every(prop => prop in featureDetectionElement.internals);
    }
    let hasElementInternalsPolyfillBeenApplied = false;
    let hasCustomStateSetPolyfillBeenApplied = false;
    function forceCustomStateSetPolyfill(attachInternals) {
        if (hasCustomStateSetPolyfillBeenApplied) {
            return;
        }
        hasCustomStateSetPolyfillBeenApplied = true;
        window.CustomStateSet = CustomStateSet;
        if (attachInternals) {
            HTMLElement.prototype.attachInternals = function (...args) {
                const internals = attachInternals.call(this, args);
                internals.states = new CustomStateSet(this);
                return internals;
            };
        }
    }
    function forceElementInternalsPolyfill(forceCustomStateSet = true) {
        if (hasElementInternalsPolyfillBeenApplied) {
            return;
        }
        hasElementInternalsPolyfillBeenApplied = true;
        if (typeof window !== 'undefined') {
            window.ElementInternals = ElementInternals;
        }
        if (typeof CustomElementRegistry !== 'undefined') {
            const define = CustomElementRegistry.prototype.define;
            CustomElementRegistry.prototype.define = function (name, constructor, options) {
                if (constructor.formAssociated) {
                    const connectedCallback = constructor.prototype.connectedCallback;
                    constructor.prototype.connectedCallback = function () {
                        if (!connectedCallbackMap.has(this)) {
                            connectedCallbackMap.set(this, true);
                            if (this.hasAttribute('disabled')) {
                                setDisabled(this, true);
                            }
                        }
                        if (connectedCallback != null) {
                            connectedCallback.apply(this);
                        }
                        upgradeInternals(this);
                    };
                }
                define.call(this, name, constructor, options);
            };
        }
        if (typeof HTMLElement !== 'undefined') {
            HTMLElement.prototype.attachInternals = function () {
                if (!this.tagName) {
                    return {};
                }
                else if (this.tagName.indexOf('-') === -1) {
                    throw new Error(`Failed to execute 'attachInternals' on 'HTMLElement': Unable to attach ElementInternals to non-custom elements.`);
                }
                if (internalsMap.has(this)) {
                    throw new DOMException(`DOMException: Failed to execute 'attachInternals' on 'HTMLElement': ElementInternals for the specified element was already attached.`);
                }
                return new ElementInternals(this);
            };
        }
        if (typeof Element !== 'undefined') {
            function attachShadowObserver(...args) {
                const shadowRoot = attachShadow.apply(this, args);
                shadowRootMap.set(this, shadowRoot);
                if (mutationObserverExists()) {
                    const observer = new MutationObserver(observerCallback);
                    if (window.ShadyDOM) {
                        observer.observe(this, observerConfig);
                    }
                    else {
                        observer.observe(shadowRoot, observerConfig);
                    }
                    shadowHostsMap.set(this, observer);
                }
                return shadowRoot;
            }
            const attachShadow = Element.prototype.attachShadow;
            Element.prototype.attachShadow = attachShadowObserver;
        }
        if (mutationObserverExists() && typeof document !== 'undefined') {
            const documentObserver = new MutationObserver(observerCallback);
            documentObserver.observe(document.documentElement, observerConfig);
        }
        if (typeof HTMLFormElement !== 'undefined') {
            patchFormPrototype();
        }
        if (forceCustomStateSet ||
            (typeof window !== "undefined" && !window.CustomStateSet)) {
            forceCustomStateSetPolyfill();
        }
    }

    const isCePolyfill = !!customElements.polyfillWrapFlushCallback;
    if (!isCePolyfill) {
        if (!isElementInternalsSupported()) {
            forceElementInternalsPolyfill(false);
        }
        else if (typeof window !== "undefined" && !window.CustomStateSet) {
            forceCustomStateSetPolyfill(HTMLElement.prototype.attachInternals);
        }
    }

    exports.forceCustomStateSetPolyfill = forceCustomStateSetPolyfill;
    exports.forceElementInternalsPolyfill = forceElementInternalsPolyfill;

    Object.defineProperty(exports, '__esModule', { value: true });

    return exports;

})({});


/***/ }),

/***/ "./node_modules/iconify-icon/dist/iconify-icon.mjs":
/*!*********************************************************!*\
  !*** ./node_modules/iconify-icon/dist/iconify-icon.mjs ***!
  \*********************************************************/
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   IconifyIconComponent: () => (/* binding */ IconifyIconComponent),
/* harmony export */   _api: () => (/* binding */ _api),
/* harmony export */   addAPIProvider: () => (/* binding */ addAPIProvider),
/* harmony export */   addCollection: () => (/* binding */ addCollection),
/* harmony export */   addIcon: () => (/* binding */ addIcon),
/* harmony export */   appendCustomStyle: () => (/* binding */ appendCustomStyle),
/* harmony export */   buildIcon: () => (/* binding */ buildIcon),
/* harmony export */   calculateSize: () => (/* binding */ calculateSize),
/* harmony export */   disableCache: () => (/* binding */ disableCache),
/* harmony export */   enableCache: () => (/* binding */ enableCache),
/* harmony export */   getIcon: () => (/* binding */ getIcon),
/* harmony export */   iconExists: () => (/* binding */ iconExists),
/* harmony export */   listIcons: () => (/* binding */ listIcons),
/* harmony export */   loadIcon: () => (/* binding */ loadIcon),
/* harmony export */   loadIcons: () => (/* binding */ loadIcons)
/* harmony export */ });
/**
* (c) Iconify
*
* For the full copyright and license information, please view the license.txt
* files at https://github.com/iconify/iconify
*
* Licensed under MIT.
*
* @license MIT
* @version 1.0.8
*/
const defaultIconDimensions = Object.freeze(
  {
    left: 0,
    top: 0,
    width: 16,
    height: 16
  }
);
const defaultIconTransformations = Object.freeze({
  rotate: 0,
  vFlip: false,
  hFlip: false
});
const defaultIconProps = Object.freeze({
  ...defaultIconDimensions,
  ...defaultIconTransformations
});
const defaultExtendedIconProps = Object.freeze({
  ...defaultIconProps,
  body: "",
  hidden: false
});

const defaultIconSizeCustomisations = Object.freeze({
  width: null,
  height: null
});
const defaultIconCustomisations = Object.freeze({
  // Dimensions
  ...defaultIconSizeCustomisations,
  // Transformations
  ...defaultIconTransformations
});

function rotateFromString(value, defaultValue = 0) {
  const units = value.replace(/^-?[0-9.]*/, "");
  function cleanup(value2) {
    while (value2 < 0) {
      value2 += 4;
    }
    return value2 % 4;
  }
  if (units === "") {
    const num = parseInt(value);
    return isNaN(num) ? 0 : cleanup(num);
  } else if (units !== value) {
    let split = 0;
    switch (units) {
      case "%":
        split = 25;
        break;
      case "deg":
        split = 90;
    }
    if (split) {
      let num = parseFloat(value.slice(0, value.length - units.length));
      if (isNaN(num)) {
        return 0;
      }
      num = num / split;
      return num % 1 === 0 ? cleanup(num) : 0;
    }
  }
  return defaultValue;
}

const separator = /[\s,]+/;
function flipFromString(custom, flip) {
  flip.split(separator).forEach((str) => {
    const value = str.trim();
    switch (value) {
      case "horizontal":
        custom.hFlip = true;
        break;
      case "vertical":
        custom.vFlip = true;
        break;
    }
  });
}

const defaultCustomisations = {
    ...defaultIconCustomisations,
    preserveAspectRatio: '',
};
/**
 * Get customisations
 */
function getCustomisations(node) {
    const customisations = {
        ...defaultCustomisations,
    };
    const attr = (key, def) => node.getAttribute(key) || def;
    // Dimensions
    customisations.width = attr('width', null);
    customisations.height = attr('height', null);
    // Rotation
    customisations.rotate = rotateFromString(attr('rotate', ''));
    // Flip
    flipFromString(customisations, attr('flip', ''));
    // SVG attributes
    customisations.preserveAspectRatio = attr('preserveAspectRatio', attr('preserveaspectratio', ''));
    return customisations;
}
/**
 * Check if customisations have been updated
 */
function haveCustomisationsChanged(value1, value2) {
    for (const key in defaultCustomisations) {
        if (value1[key] !== value2[key]) {
            return true;
        }
    }
    return false;
}

const matchIconName = /^[a-z0-9]+(-[a-z0-9]+)*$/;
const stringToIcon = (value, validate, allowSimpleName, provider = "") => {
  const colonSeparated = value.split(":");
  if (value.slice(0, 1) === "@") {
    if (colonSeparated.length < 2 || colonSeparated.length > 3) {
      return null;
    }
    provider = colonSeparated.shift().slice(1);
  }
  if (colonSeparated.length > 3 || !colonSeparated.length) {
    return null;
  }
  if (colonSeparated.length > 1) {
    const name2 = colonSeparated.pop();
    const prefix = colonSeparated.pop();
    const result = {
      // Allow provider without '@': "provider:prefix:name"
      provider: colonSeparated.length > 0 ? colonSeparated[0] : provider,
      prefix,
      name: name2
    };
    return validate && !validateIconName(result) ? null : result;
  }
  const name = colonSeparated[0];
  const dashSeparated = name.split("-");
  if (dashSeparated.length > 1) {
    const result = {
      provider,
      prefix: dashSeparated.shift(),
      name: dashSeparated.join("-")
    };
    return validate && !validateIconName(result) ? null : result;
  }
  if (allowSimpleName && provider === "") {
    const result = {
      provider,
      prefix: "",
      name
    };
    return validate && !validateIconName(result, allowSimpleName) ? null : result;
  }
  return null;
};
const validateIconName = (icon, allowSimpleName) => {
  if (!icon) {
    return false;
  }
  return !!((icon.provider === "" || icon.provider.match(matchIconName)) && (allowSimpleName && icon.prefix === "" || icon.prefix.match(matchIconName)) && icon.name.match(matchIconName));
};

function mergeIconTransformations(obj1, obj2) {
  const result = {};
  if (!obj1.hFlip !== !obj2.hFlip) {
    result.hFlip = true;
  }
  if (!obj1.vFlip !== !obj2.vFlip) {
    result.vFlip = true;
  }
  const rotate = ((obj1.rotate || 0) + (obj2.rotate || 0)) % 4;
  if (rotate) {
    result.rotate = rotate;
  }
  return result;
}

function mergeIconData(parent, child) {
  const result = mergeIconTransformations(parent, child);
  for (const key in defaultExtendedIconProps) {
    if (key in defaultIconTransformations) {
      if (key in parent && !(key in result)) {
        result[key] = defaultIconTransformations[key];
      }
    } else if (key in child) {
      result[key] = child[key];
    } else if (key in parent) {
      result[key] = parent[key];
    }
  }
  return result;
}

function getIconsTree(data, names) {
  const icons = data.icons;
  const aliases = data.aliases || /* @__PURE__ */ Object.create(null);
  const resolved = /* @__PURE__ */ Object.create(null);
  function resolve(name) {
    if (icons[name]) {
      return resolved[name] = [];
    }
    if (!(name in resolved)) {
      resolved[name] = null;
      const parent = aliases[name] && aliases[name].parent;
      const value = parent && resolve(parent);
      if (value) {
        resolved[name] = [parent].concat(value);
      }
    }
    return resolved[name];
  }
  (names || Object.keys(icons).concat(Object.keys(aliases))).forEach(resolve);
  return resolved;
}

function internalGetIconData(data, name, tree) {
  const icons = data.icons;
  const aliases = data.aliases || /* @__PURE__ */ Object.create(null);
  let currentProps = {};
  function parse(name2) {
    currentProps = mergeIconData(
      icons[name2] || aliases[name2],
      currentProps
    );
  }
  parse(name);
  tree.forEach(parse);
  return mergeIconData(data, currentProps);
}

function parseIconSet(data, callback) {
  const names = [];
  if (typeof data !== "object" || typeof data.icons !== "object") {
    return names;
  }
  if (data.not_found instanceof Array) {
    data.not_found.forEach((name) => {
      callback(name, null);
      names.push(name);
    });
  }
  const tree = getIconsTree(data);
  for (const name in tree) {
    const item = tree[name];
    if (item) {
      callback(name, internalGetIconData(data, name, item));
      names.push(name);
    }
  }
  return names;
}

const optionalPropertyDefaults = {
  provider: "",
  aliases: {},
  not_found: {},
  ...defaultIconDimensions
};
function checkOptionalProps(item, defaults) {
  for (const prop in defaults) {
    if (prop in item && typeof item[prop] !== typeof defaults[prop]) {
      return false;
    }
  }
  return true;
}
function quicklyValidateIconSet(obj) {
  if (typeof obj !== "object" || obj === null) {
    return null;
  }
  const data = obj;
  if (typeof data.prefix !== "string" || !obj.icons || typeof obj.icons !== "object") {
    return null;
  }
  if (!checkOptionalProps(obj, optionalPropertyDefaults)) {
    return null;
  }
  const icons = data.icons;
  for (const name in icons) {
    const icon = icons[name];
    if (!name.match(matchIconName) || typeof icon.body !== "string" || !checkOptionalProps(
      icon,
      defaultExtendedIconProps
    )) {
      return null;
    }
  }
  const aliases = data.aliases || /* @__PURE__ */ Object.create(null);
  for (const name in aliases) {
    const icon = aliases[name];
    const parent = icon.parent;
    if (!name.match(matchIconName) || typeof parent !== "string" || !icons[parent] && !aliases[parent] || !checkOptionalProps(
      icon,
      defaultExtendedIconProps
    )) {
      return null;
    }
  }
  return data;
}

const dataStorage = /* @__PURE__ */ Object.create(null);
function newStorage(provider, prefix) {
  return {
    provider,
    prefix,
    icons: /* @__PURE__ */ Object.create(null),
    missing: /* @__PURE__ */ new Set()
  };
}
function getStorage(provider, prefix) {
  const providerStorage = dataStorage[provider] || (dataStorage[provider] = /* @__PURE__ */ Object.create(null));
  return providerStorage[prefix] || (providerStorage[prefix] = newStorage(provider, prefix));
}
function addIconSet(storage, data) {
  if (!quicklyValidateIconSet(data)) {
    return [];
  }
  return parseIconSet(data, (name, icon) => {
    if (icon) {
      storage.icons[name] = icon;
    } else {
      storage.missing.add(name);
    }
  });
}
function addIconToStorage(storage, name, icon) {
  try {
    if (typeof icon.body === "string") {
      storage.icons[name] = { ...icon };
      return true;
    }
  } catch (err) {
  }
  return false;
}
function listIcons$1(provider, prefix) {
  let allIcons = [];
  const providers = typeof provider === "string" ? [provider] : Object.keys(dataStorage);
  providers.forEach((provider2) => {
    const prefixes = typeof provider2 === "string" && typeof prefix === "string" ? [prefix] : Object.keys(dataStorage[provider2] || {});
    prefixes.forEach((prefix2) => {
      const storage = getStorage(provider2, prefix2);
      allIcons = allIcons.concat(
        Object.keys(storage.icons).map(
          (name) => (provider2 !== "" ? "@" + provider2 + ":" : "") + prefix2 + ":" + name
        )
      );
    });
  });
  return allIcons;
}

let simpleNames = false;
function allowSimpleNames(allow) {
  if (typeof allow === "boolean") {
    simpleNames = allow;
  }
  return simpleNames;
}
function getIconData(name) {
  const icon = typeof name === "string" ? stringToIcon(name, true, simpleNames) : name;
  if (icon) {
    const storage = getStorage(icon.provider, icon.prefix);
    const iconName = icon.name;
    return storage.icons[iconName] || (storage.missing.has(iconName) ? null : void 0);
  }
}
function addIcon$1(name, data) {
  const icon = stringToIcon(name, true, simpleNames);
  if (!icon) {
    return false;
  }
  const storage = getStorage(icon.provider, icon.prefix);
  return addIconToStorage(storage, icon.name, data);
}
function addCollection$1(data, provider) {
  if (typeof data !== "object") {
    return false;
  }
  if (typeof provider !== "string") {
    provider = data.provider || "";
  }
  if (simpleNames && !provider && !data.prefix) {
    let added = false;
    if (quicklyValidateIconSet(data)) {
      data.prefix = "";
      parseIconSet(data, (name, icon) => {
        if (icon && addIcon$1(name, icon)) {
          added = true;
        }
      });
    }
    return added;
  }
  const prefix = data.prefix;
  if (!validateIconName({
    provider,
    prefix,
    name: "a"
  })) {
    return false;
  }
  const storage = getStorage(provider, prefix);
  return !!addIconSet(storage, data);
}
function iconExists$1(name) {
  return !!getIconData(name);
}
function getIcon$1(name) {
  const result = getIconData(name);
  return result ? {
    ...defaultIconProps,
    ...result
  } : null;
}

function sortIcons(icons) {
  const result = {
    loaded: [],
    missing: [],
    pending: []
  };
  const storage = /* @__PURE__ */ Object.create(null);
  icons.sort((a, b) => {
    if (a.provider !== b.provider) {
      return a.provider.localeCompare(b.provider);
    }
    if (a.prefix !== b.prefix) {
      return a.prefix.localeCompare(b.prefix);
    }
    return a.name.localeCompare(b.name);
  });
  let lastIcon = {
    provider: "",
    prefix: "",
    name: ""
  };
  icons.forEach((icon) => {
    if (lastIcon.name === icon.name && lastIcon.prefix === icon.prefix && lastIcon.provider === icon.provider) {
      return;
    }
    lastIcon = icon;
    const provider = icon.provider;
    const prefix = icon.prefix;
    const name = icon.name;
    const providerStorage = storage[provider] || (storage[provider] = /* @__PURE__ */ Object.create(null));
    const localStorage = providerStorage[prefix] || (providerStorage[prefix] = getStorage(provider, prefix));
    let list;
    if (name in localStorage.icons) {
      list = result.loaded;
    } else if (prefix === "" || localStorage.missing.has(name)) {
      list = result.missing;
    } else {
      list = result.pending;
    }
    const item = {
      provider,
      prefix,
      name
    };
    list.push(item);
  });
  return result;
}

function removeCallback(storages, id) {
  storages.forEach((storage) => {
    const items = storage.loaderCallbacks;
    if (items) {
      storage.loaderCallbacks = items.filter((row) => row.id !== id);
    }
  });
}
function updateCallbacks(storage) {
  if (!storage.pendingCallbacksFlag) {
    storage.pendingCallbacksFlag = true;
    setTimeout(() => {
      storage.pendingCallbacksFlag = false;
      const items = storage.loaderCallbacks ? storage.loaderCallbacks.slice(0) : [];
      if (!items.length) {
        return;
      }
      let hasPending = false;
      const provider = storage.provider;
      const prefix = storage.prefix;
      items.forEach((item) => {
        const icons = item.icons;
        const oldLength = icons.pending.length;
        icons.pending = icons.pending.filter((icon) => {
          if (icon.prefix !== prefix) {
            return true;
          }
          const name = icon.name;
          if (storage.icons[name]) {
            icons.loaded.push({
              provider,
              prefix,
              name
            });
          } else if (storage.missing.has(name)) {
            icons.missing.push({
              provider,
              prefix,
              name
            });
          } else {
            hasPending = true;
            return true;
          }
          return false;
        });
        if (icons.pending.length !== oldLength) {
          if (!hasPending) {
            removeCallback([storage], item.id);
          }
          item.callback(
            icons.loaded.slice(0),
            icons.missing.slice(0),
            icons.pending.slice(0),
            item.abort
          );
        }
      });
    });
  }
}
let idCounter = 0;
function storeCallback(callback, icons, pendingSources) {
  const id = idCounter++;
  const abort = removeCallback.bind(null, pendingSources, id);
  if (!icons.pending.length) {
    return abort;
  }
  const item = {
    id,
    icons,
    callback,
    abort
  };
  pendingSources.forEach((storage) => {
    (storage.loaderCallbacks || (storage.loaderCallbacks = [])).push(item);
  });
  return abort;
}

const storage = /* @__PURE__ */ Object.create(null);
function setAPIModule(provider, item) {
  storage[provider] = item;
}
function getAPIModule(provider) {
  return storage[provider] || storage[""];
}

function listToIcons(list, validate = true, simpleNames = false) {
  const result = [];
  list.forEach((item) => {
    const icon = typeof item === "string" ? stringToIcon(item, validate, simpleNames) : item;
    if (icon) {
      result.push(icon);
    }
  });
  return result;
}

// src/config.ts
var defaultConfig = {
  resources: [],
  index: 0,
  timeout: 2e3,
  rotate: 750,
  random: false,
  dataAfterTimeout: false
};

// src/query.ts
function sendQuery(config, payload, query, done) {
  const resourcesCount = config.resources.length;
  const startIndex = config.random ? Math.floor(Math.random() * resourcesCount) : config.index;
  let resources;
  if (config.random) {
    let list = config.resources.slice(0);
    resources = [];
    while (list.length > 1) {
      const nextIndex = Math.floor(Math.random() * list.length);
      resources.push(list[nextIndex]);
      list = list.slice(0, nextIndex).concat(list.slice(nextIndex + 1));
    }
    resources = resources.concat(list);
  } else {
    resources = config.resources.slice(startIndex).concat(config.resources.slice(0, startIndex));
  }
  const startTime = Date.now();
  let status = "pending";
  let queriesSent = 0;
  let lastError;
  let timer = null;
  let queue = [];
  let doneCallbacks = [];
  if (typeof done === "function") {
    doneCallbacks.push(done);
  }
  function resetTimer() {
    if (timer) {
      clearTimeout(timer);
      timer = null;
    }
  }
  function abort() {
    if (status === "pending") {
      status = "aborted";
    }
    resetTimer();
    queue.forEach((item) => {
      if (item.status === "pending") {
        item.status = "aborted";
      }
    });
    queue = [];
  }
  function subscribe(callback, overwrite) {
    if (overwrite) {
      doneCallbacks = [];
    }
    if (typeof callback === "function") {
      doneCallbacks.push(callback);
    }
  }
  function getQueryStatus() {
    return {
      startTime,
      payload,
      status,
      queriesSent,
      queriesPending: queue.length,
      subscribe,
      abort
    };
  }
  function failQuery() {
    status = "failed";
    doneCallbacks.forEach((callback) => {
      callback(void 0, lastError);
    });
  }
  function clearQueue() {
    queue.forEach((item) => {
      if (item.status === "pending") {
        item.status = "aborted";
      }
    });
    queue = [];
  }
  function moduleResponse(item, response, data) {
    const isError = response !== "success";
    queue = queue.filter((queued) => queued !== item);
    switch (status) {
      case "pending":
        break;
      case "failed":
        if (isError || !config.dataAfterTimeout) {
          return;
        }
        break;
      default:
        return;
    }
    if (response === "abort") {
      lastError = data;
      failQuery();
      return;
    }
    if (isError) {
      lastError = data;
      if (!queue.length) {
        if (!resources.length) {
          failQuery();
        } else {
          execNext();
        }
      }
      return;
    }
    resetTimer();
    clearQueue();
    if (!config.random) {
      const index = config.resources.indexOf(item.resource);
      if (index !== -1 && index !== config.index) {
        config.index = index;
      }
    }
    status = "completed";
    doneCallbacks.forEach((callback) => {
      callback(data);
    });
  }
  function execNext() {
    if (status !== "pending") {
      return;
    }
    resetTimer();
    const resource = resources.shift();
    if (resource === void 0) {
      if (queue.length) {
        timer = setTimeout(() => {
          resetTimer();
          if (status === "pending") {
            clearQueue();
            failQuery();
          }
        }, config.timeout);
        return;
      }
      failQuery();
      return;
    }
    const item = {
      status: "pending",
      resource,
      callback: (status2, data) => {
        moduleResponse(item, status2, data);
      }
    };
    queue.push(item);
    queriesSent++;
    timer = setTimeout(execNext, config.rotate);
    query(resource, payload, item.callback);
  }
  setTimeout(execNext);
  return getQueryStatus;
}

// src/index.ts
function initRedundancy(cfg) {
  const config = {
    ...defaultConfig,
    ...cfg
  };
  let queries = [];
  function cleanup() {
    queries = queries.filter((item) => item().status === "pending");
  }
  function query(payload, queryCallback, doneCallback) {
    const query2 = sendQuery(
      config,
      payload,
      queryCallback,
      (data, error) => {
        cleanup();
        if (doneCallback) {
          doneCallback(data, error);
        }
      }
    );
    queries.push(query2);
    return query2;
  }
  function find(callback) {
    return queries.find((value) => {
      return callback(value);
    }) || null;
  }
  const instance = {
    query,
    find,
    setIndex: (index) => {
      config.index = index;
    },
    getIndex: () => config.index,
    cleanup
  };
  return instance;
}

function createAPIConfig(source) {
  let resources;
  if (typeof source.resources === "string") {
    resources = [source.resources];
  } else {
    resources = source.resources;
    if (!(resources instanceof Array) || !resources.length) {
      return null;
    }
  }
  const result = {
    // API hosts
    resources,
    // Root path
    path: source.path || "/",
    // URL length limit
    maxURL: source.maxURL || 500,
    // Timeout before next host is used.
    rotate: source.rotate || 750,
    // Timeout before failing query.
    timeout: source.timeout || 5e3,
    // Randomise default API end point.
    random: source.random === true,
    // Start index
    index: source.index || 0,
    // Receive data after time out (used if time out kicks in first, then API module sends data anyway).
    dataAfterTimeout: source.dataAfterTimeout !== false
  };
  return result;
}
const configStorage = /* @__PURE__ */ Object.create(null);
const fallBackAPISources = [
  "https://api.simplesvg.com",
  "https://api.unisvg.com"
];
const fallBackAPI = [];
while (fallBackAPISources.length > 0) {
  if (fallBackAPISources.length === 1) {
    fallBackAPI.push(fallBackAPISources.shift());
  } else {
    if (Math.random() > 0.5) {
      fallBackAPI.push(fallBackAPISources.shift());
    } else {
      fallBackAPI.push(fallBackAPISources.pop());
    }
  }
}
configStorage[""] = createAPIConfig({
  resources: ["https://api.iconify.design"].concat(fallBackAPI)
});
function addAPIProvider$1(provider, customConfig) {
  const config = createAPIConfig(customConfig);
  if (config === null) {
    return false;
  }
  configStorage[provider] = config;
  return true;
}
function getAPIConfig(provider) {
  return configStorage[provider];
}
function listAPIProviders() {
  return Object.keys(configStorage);
}

function emptyCallback$1() {
}
const redundancyCache = /* @__PURE__ */ Object.create(null);
function getRedundancyCache(provider) {
  if (!redundancyCache[provider]) {
    const config = getAPIConfig(provider);
    if (!config) {
      return;
    }
    const redundancy = initRedundancy(config);
    const cachedReundancy = {
      config,
      redundancy
    };
    redundancyCache[provider] = cachedReundancy;
  }
  return redundancyCache[provider];
}
function sendAPIQuery(target, query, callback) {
  let redundancy;
  let send;
  if (typeof target === "string") {
    const api = getAPIModule(target);
    if (!api) {
      callback(void 0, 424);
      return emptyCallback$1;
    }
    send = api.send;
    const cached = getRedundancyCache(target);
    if (cached) {
      redundancy = cached.redundancy;
    }
  } else {
    const config = createAPIConfig(target);
    if (config) {
      redundancy = initRedundancy(config);
      const moduleKey = target.resources ? target.resources[0] : "";
      const api = getAPIModule(moduleKey);
      if (api) {
        send = api.send;
      }
    }
  }
  if (!redundancy || !send) {
    callback(void 0, 424);
    return emptyCallback$1;
  }
  return redundancy.query(query, send, callback)().abort;
}

const browserCacheVersion = "iconify2";
const browserCachePrefix = "iconify";
const browserCacheCountKey = browserCachePrefix + "-count";
const browserCacheVersionKey = browserCachePrefix + "-version";
const browserStorageHour = 36e5;
const browserStorageCacheExpiration = 168;

function getStoredItem(func, key) {
  try {
    return func.getItem(key);
  } catch (err) {
  }
}
function setStoredItem(func, key, value) {
  try {
    func.setItem(key, value);
    return true;
  } catch (err) {
  }
}
function removeStoredItem(func, key) {
  try {
    func.removeItem(key);
  } catch (err) {
  }
}

function setBrowserStorageItemsCount(storage, value) {
  return setStoredItem(storage, browserCacheCountKey, value.toString());
}
function getBrowserStorageItemsCount(storage) {
  return parseInt(getStoredItem(storage, browserCacheCountKey)) || 0;
}

const browserStorageConfig = {
  local: true,
  session: true
};
const browserStorageEmptyItems = {
  local: /* @__PURE__ */ new Set(),
  session: /* @__PURE__ */ new Set()
};
let browserStorageStatus = false;
function setBrowserStorageStatus(status) {
  browserStorageStatus = status;
}

let _window = typeof window === "undefined" ? {} : window;
function getBrowserStorage(key) {
  const attr = key + "Storage";
  try {
    if (_window && _window[attr] && typeof _window[attr].length === "number") {
      return _window[attr];
    }
  } catch (err) {
  }
  browserStorageConfig[key] = false;
}

function iterateBrowserStorage(key, callback) {
  const func = getBrowserStorage(key);
  if (!func) {
    return;
  }
  const version = getStoredItem(func, browserCacheVersionKey);
  if (version !== browserCacheVersion) {
    if (version) {
      const total2 = getBrowserStorageItemsCount(func);
      for (let i = 0; i < total2; i++) {
        removeStoredItem(func, browserCachePrefix + i.toString());
      }
    }
    setStoredItem(func, browserCacheVersionKey, browserCacheVersion);
    setBrowserStorageItemsCount(func, 0);
    return;
  }
  const minTime = Math.floor(Date.now() / browserStorageHour) - browserStorageCacheExpiration;
  const parseItem = (index) => {
    const name = browserCachePrefix + index.toString();
    const item = getStoredItem(func, name);
    if (typeof item !== "string") {
      return;
    }
    try {
      const data = JSON.parse(item);
      if (typeof data === "object" && typeof data.cached === "number" && data.cached > minTime && typeof data.provider === "string" && typeof data.data === "object" && typeof data.data.prefix === "string" && // Valid item: run callback
      callback(data, index)) {
        return true;
      }
    } catch (err) {
    }
    removeStoredItem(func, name);
  };
  let total = getBrowserStorageItemsCount(func);
  for (let i = total - 1; i >= 0; i--) {
    if (!parseItem(i)) {
      if (i === total - 1) {
        total--;
        setBrowserStorageItemsCount(func, total);
      } else {
        browserStorageEmptyItems[key].add(i);
      }
    }
  }
}

function initBrowserStorage() {
  if (browserStorageStatus) {
    return;
  }
  setBrowserStorageStatus(true);
  for (const key in browserStorageConfig) {
    iterateBrowserStorage(key, (item) => {
      const iconSet = item.data;
      const provider = item.provider;
      const prefix = iconSet.prefix;
      const storage = getStorage(
        provider,
        prefix
      );
      if (!addIconSet(storage, iconSet).length) {
        return false;
      }
      const lastModified = iconSet.lastModified || -1;
      storage.lastModifiedCached = storage.lastModifiedCached ? Math.min(storage.lastModifiedCached, lastModified) : lastModified;
      return true;
    });
  }
}

function updateLastModified(storage, lastModified) {
  const lastValue = storage.lastModifiedCached;
  if (
    // Matches or newer
    lastValue && lastValue >= lastModified
  ) {
    return lastValue === lastModified;
  }
  storage.lastModifiedCached = lastModified;
  if (lastValue) {
    for (const key in browserStorageConfig) {
      iterateBrowserStorage(key, (item) => {
        const iconSet = item.data;
        return item.provider !== storage.provider || iconSet.prefix !== storage.prefix || iconSet.lastModified === lastModified;
      });
    }
  }
  return true;
}
function storeInBrowserStorage(storage, data) {
  if (!browserStorageStatus) {
    initBrowserStorage();
  }
  function store(key) {
    let func;
    if (!browserStorageConfig[key] || !(func = getBrowserStorage(key))) {
      return;
    }
    const set = browserStorageEmptyItems[key];
    let index;
    if (set.size) {
      set.delete(index = Array.from(set).shift());
    } else {
      index = getBrowserStorageItemsCount(func);
      if (!setBrowserStorageItemsCount(func, index + 1)) {
        return;
      }
    }
    const item = {
      cached: Math.floor(Date.now() / browserStorageHour),
      provider: storage.provider,
      data
    };
    return setStoredItem(
      func,
      browserCachePrefix + index.toString(),
      JSON.stringify(item)
    );
  }
  if (data.lastModified && !updateLastModified(storage, data.lastModified)) {
    return;
  }
  if (!Object.keys(data.icons).length) {
    return;
  }
  if (data.not_found) {
    data = Object.assign({}, data);
    delete data.not_found;
  }
  if (!store("local")) {
    store("session");
  }
}

function emptyCallback() {
}
function loadedNewIcons(storage) {
  if (!storage.iconsLoaderFlag) {
    storage.iconsLoaderFlag = true;
    setTimeout(() => {
      storage.iconsLoaderFlag = false;
      updateCallbacks(storage);
    });
  }
}
function loadNewIcons(storage, icons) {
  if (!storage.iconsToLoad) {
    storage.iconsToLoad = icons;
  } else {
    storage.iconsToLoad = storage.iconsToLoad.concat(icons).sort();
  }
  if (!storage.iconsQueueFlag) {
    storage.iconsQueueFlag = true;
    setTimeout(() => {
      storage.iconsQueueFlag = false;
      const { provider, prefix } = storage;
      const icons2 = storage.iconsToLoad;
      delete storage.iconsToLoad;
      let api;
      if (!icons2 || !(api = getAPIModule(provider))) {
        return;
      }
      const params = api.prepare(provider, prefix, icons2);
      params.forEach((item) => {
        sendAPIQuery(provider, item, (data) => {
          if (typeof data !== "object") {
            item.icons.forEach((name) => {
              storage.missing.add(name);
            });
          } else {
            try {
              const parsed = addIconSet(
                storage,
                data
              );
              if (!parsed.length) {
                return;
              }
              const pending = storage.pendingIcons;
              if (pending) {
                parsed.forEach((name) => {
                  pending.delete(name);
                });
              }
              storeInBrowserStorage(storage, data);
            } catch (err) {
              console.error(err);
            }
          }
          loadedNewIcons(storage);
        });
      });
    });
  }
}
const loadIcons$1 = (icons, callback) => {
  const cleanedIcons = listToIcons(icons, true, allowSimpleNames());
  const sortedIcons = sortIcons(cleanedIcons);
  if (!sortedIcons.pending.length) {
    let callCallback = true;
    if (callback) {
      setTimeout(() => {
        if (callCallback) {
          callback(
            sortedIcons.loaded,
            sortedIcons.missing,
            sortedIcons.pending,
            emptyCallback
          );
        }
      });
    }
    return () => {
      callCallback = false;
    };
  }
  const newIcons = /* @__PURE__ */ Object.create(null);
  const sources = [];
  let lastProvider, lastPrefix;
  sortedIcons.pending.forEach((icon) => {
    const { provider, prefix } = icon;
    if (prefix === lastPrefix && provider === lastProvider) {
      return;
    }
    lastProvider = provider;
    lastPrefix = prefix;
    sources.push(getStorage(provider, prefix));
    const providerNewIcons = newIcons[provider] || (newIcons[provider] = /* @__PURE__ */ Object.create(null));
    if (!providerNewIcons[prefix]) {
      providerNewIcons[prefix] = [];
    }
  });
  sortedIcons.pending.forEach((icon) => {
    const { provider, prefix, name } = icon;
    const storage = getStorage(provider, prefix);
    const pendingQueue = storage.pendingIcons || (storage.pendingIcons = /* @__PURE__ */ new Set());
    if (!pendingQueue.has(name)) {
      pendingQueue.add(name);
      newIcons[provider][prefix].push(name);
    }
  });
  sources.forEach((storage) => {
    const { provider, prefix } = storage;
    if (newIcons[provider][prefix].length) {
      loadNewIcons(storage, newIcons[provider][prefix]);
    }
  });
  return callback ? storeCallback(callback, sortedIcons, sources) : emptyCallback;
};
const loadIcon$1 = (icon) => {
  return new Promise((fulfill, reject) => {
    const iconObj = typeof icon === "string" ? stringToIcon(icon, true) : icon;
    if (!iconObj) {
      reject(icon);
      return;
    }
    loadIcons$1([iconObj || icon], (loaded) => {
      if (loaded.length && iconObj) {
        const data = getIconData(iconObj);
        if (data) {
          fulfill({
            ...defaultIconProps,
            ...data
          });
          return;
        }
      }
      reject(icon);
    });
  });
};

/**
 * Test icon string
 */
function testIconObject(value) {
    try {
        const obj = typeof value === 'string' ? JSON.parse(value) : value;
        if (typeof obj.body === 'string') {
            return {
                ...obj,
            };
        }
    }
    catch (err) {
        //
    }
}

/**
 * Parse icon value, load if needed
 */
function parseIconValue(value, onload) {
    // Check if icon name is valid
    const name = typeof value === 'string' ? stringToIcon(value, true, true) : null;
    if (!name) {
        // Test for serialised object
        const data = testIconObject(value);
        return {
            value,
            data,
        };
    }
    // Valid icon name: check if data is available
    const data = getIconData(name);
    // Icon data exists or icon has no prefix. Do not load icon from API if icon has no prefix
    if (data !== void 0 || !name.prefix) {
        return {
            value,
            name,
            data, // could be 'null' -> icon is missing
        };
    }
    // Load icon
    const loading = loadIcons$1([name], () => onload(value, name, getIconData(name)));
    return {
        value,
        name,
        loading,
    };
}

/**
 * Check for inline
 */
function getInline(node) {
    return node.hasAttribute('inline');
}

// Check for Safari
let isBuggedSafari = false;
try {
    isBuggedSafari = navigator.vendor.indexOf('Apple') === 0;
}
catch (err) {
    //
}
/**
 * Get render mode
 */
function getRenderMode(body, mode) {
    switch (mode) {
        // Force mode
        case 'svg':
        case 'bg':
        case 'mask':
            return mode;
    }
    // Check for animation, use 'style' for animated icons, unless browser is Safari
    // (only <a>, which should be ignored or animations start with '<a')
    if (mode !== 'style' &&
        (isBuggedSafari || body.indexOf('<a') === -1)) {
        // Render <svg>
        return 'svg';
    }
    // Use background or mask
    return body.indexOf('currentColor') === -1 ? 'bg' : 'mask';
}

const unitsSplit = /(-?[0-9.]*[0-9]+[0-9.]*)/g;
const unitsTest = /^-?[0-9.]*[0-9]+[0-9.]*$/g;
function calculateSize$1(size, ratio, precision) {
  if (ratio === 1) {
    return size;
  }
  precision = precision || 100;
  if (typeof size === "number") {
    return Math.ceil(size * ratio * precision) / precision;
  }
  if (typeof size !== "string") {
    return size;
  }
  const oldParts = size.split(unitsSplit);
  if (oldParts === null || !oldParts.length) {
    return size;
  }
  const newParts = [];
  let code = oldParts.shift();
  let isNumber = unitsTest.test(code);
  while (true) {
    if (isNumber) {
      const num = parseFloat(code);
      if (isNaN(num)) {
        newParts.push(code);
      } else {
        newParts.push(Math.ceil(num * ratio * precision) / precision);
      }
    } else {
      newParts.push(code);
    }
    code = oldParts.shift();
    if (code === void 0) {
      return newParts.join("");
    }
    isNumber = !isNumber;
  }
}

const isUnsetKeyword = (value) => value === "unset" || value === "undefined" || value === "none";
function iconToSVG(icon, customisations) {
  const fullIcon = {
    ...defaultIconProps,
    ...icon
  };
  const fullCustomisations = {
    ...defaultIconCustomisations,
    ...customisations
  };
  const box = {
    left: fullIcon.left,
    top: fullIcon.top,
    width: fullIcon.width,
    height: fullIcon.height
  };
  let body = fullIcon.body;
  [fullIcon, fullCustomisations].forEach((props) => {
    const transformations = [];
    const hFlip = props.hFlip;
    const vFlip = props.vFlip;
    let rotation = props.rotate;
    if (hFlip) {
      if (vFlip) {
        rotation += 2;
      } else {
        transformations.push(
          "translate(" + (box.width + box.left).toString() + " " + (0 - box.top).toString() + ")"
        );
        transformations.push("scale(-1 1)");
        box.top = box.left = 0;
      }
    } else if (vFlip) {
      transformations.push(
        "translate(" + (0 - box.left).toString() + " " + (box.height + box.top).toString() + ")"
      );
      transformations.push("scale(1 -1)");
      box.top = box.left = 0;
    }
    let tempValue;
    if (rotation < 0) {
      rotation -= Math.floor(rotation / 4) * 4;
    }
    rotation = rotation % 4;
    switch (rotation) {
      case 1:
        tempValue = box.height / 2 + box.top;
        transformations.unshift(
          "rotate(90 " + tempValue.toString() + " " + tempValue.toString() + ")"
        );
        break;
      case 2:
        transformations.unshift(
          "rotate(180 " + (box.width / 2 + box.left).toString() + " " + (box.height / 2 + box.top).toString() + ")"
        );
        break;
      case 3:
        tempValue = box.width / 2 + box.left;
        transformations.unshift(
          "rotate(-90 " + tempValue.toString() + " " + tempValue.toString() + ")"
        );
        break;
    }
    if (rotation % 2 === 1) {
      if (box.left !== box.top) {
        tempValue = box.left;
        box.left = box.top;
        box.top = tempValue;
      }
      if (box.width !== box.height) {
        tempValue = box.width;
        box.width = box.height;
        box.height = tempValue;
      }
    }
    if (transformations.length) {
      body = '<g transform="' + transformations.join(" ") + '">' + body + "</g>";
    }
  });
  const customisationsWidth = fullCustomisations.width;
  const customisationsHeight = fullCustomisations.height;
  const boxWidth = box.width;
  const boxHeight = box.height;
  let width;
  let height;
  if (customisationsWidth === null) {
    height = customisationsHeight === null ? "1em" : customisationsHeight === "auto" ? boxHeight : customisationsHeight;
    width = calculateSize$1(height, boxWidth / boxHeight);
  } else {
    width = customisationsWidth === "auto" ? boxWidth : customisationsWidth;
    height = customisationsHeight === null ? calculateSize$1(width, boxHeight / boxWidth) : customisationsHeight === "auto" ? boxHeight : customisationsHeight;
  }
  const attributes = {};
  const setAttr = (prop, value) => {
    if (!isUnsetKeyword(value)) {
      attributes[prop] = value.toString();
    }
  };
  setAttr("width", width);
  setAttr("height", height);
  attributes.viewBox = box.left.toString() + " " + box.top.toString() + " " + boxWidth.toString() + " " + boxHeight.toString();
  return {
    attributes,
    body
  };
}

const detectFetch = () => {
  let callback;
  try {
    callback = fetch;
    if (typeof callback === "function") {
      return callback;
    }
  } catch (err) {
  }
};
let fetchModule = detectFetch();
function setFetch(fetch2) {
  fetchModule = fetch2;
}
function getFetch() {
  return fetchModule;
}
function calculateMaxLength(provider, prefix) {
  const config = getAPIConfig(provider);
  if (!config) {
    return 0;
  }
  let result;
  if (!config.maxURL) {
    result = 0;
  } else {
    let maxHostLength = 0;
    config.resources.forEach((item) => {
      const host = item;
      maxHostLength = Math.max(maxHostLength, host.length);
    });
    const url = prefix + ".json?icons=";
    result = config.maxURL - maxHostLength - config.path.length - url.length;
  }
  return result;
}
function shouldAbort(status) {
  return status === 404;
}
const prepare = (provider, prefix, icons) => {
  const results = [];
  const maxLength = calculateMaxLength(provider, prefix);
  const type = "icons";
  let item = {
    type,
    provider,
    prefix,
    icons: []
  };
  let length = 0;
  icons.forEach((name, index) => {
    length += name.length + 1;
    if (length >= maxLength && index > 0) {
      results.push(item);
      item = {
        type,
        provider,
        prefix,
        icons: []
      };
      length = name.length;
    }
    item.icons.push(name);
  });
  results.push(item);
  return results;
};
function getPath(provider) {
  if (typeof provider === "string") {
    const config = getAPIConfig(provider);
    if (config) {
      return config.path;
    }
  }
  return "/";
}
const send = (host, params, callback) => {
  if (!fetchModule) {
    callback("abort", 424);
    return;
  }
  let path = getPath(params.provider);
  switch (params.type) {
    case "icons": {
      const prefix = params.prefix;
      const icons = params.icons;
      const iconsList = icons.join(",");
      const urlParams = new URLSearchParams({
        icons: iconsList
      });
      path += prefix + ".json?" + urlParams.toString();
      break;
    }
    case "custom": {
      const uri = params.uri;
      path += uri.slice(0, 1) === "/" ? uri.slice(1) : uri;
      break;
    }
    default:
      callback("abort", 400);
      return;
  }
  let defaultError = 503;
  fetchModule(host + path).then((response) => {
    const status = response.status;
    if (status !== 200) {
      setTimeout(() => {
        callback(shouldAbort(status) ? "abort" : "next", status);
      });
      return;
    }
    defaultError = 501;
    return response.json();
  }).then((data) => {
    if (typeof data !== "object" || data === null) {
      setTimeout(() => {
        if (data === 404) {
          callback("abort", data);
        } else {
          callback("next", defaultError);
        }
      });
      return;
    }
    setTimeout(() => {
      callback("success", data);
    });
  }).catch(() => {
    callback("next", defaultError);
  });
};
const fetchAPIModule = {
  prepare,
  send
};

function toggleBrowserCache(storage, value) {
  switch (storage) {
    case "local":
    case "session":
      browserStorageConfig[storage] = value;
      break;
    case "all":
      for (const key in browserStorageConfig) {
        browserStorageConfig[key] = value;
      }
      break;
  }
}

/**
 * Attribute to add
 */
const nodeAttr = 'data-style';
/**
 * Custom style to add to each node
 */
let customStyle = '';
/**
 * Set custom style to add to all components
 *
 * Affects only components rendered after function call
 */
function appendCustomStyle(style) {
    customStyle = style;
}
/**
 * Add/update style node
 */
function updateStyle(parent, inline) {
    // Get node, create if needed
    let styleNode = Array.from(parent.childNodes).find((node) => node.hasAttribute &&
        node.hasAttribute(nodeAttr));
    if (!styleNode) {
        styleNode = document.createElement('style');
        styleNode.setAttribute(nodeAttr, nodeAttr);
        parent.appendChild(styleNode);
    }
    // Update content
    styleNode.textContent =
        ':host{display:inline-block;vertical-align:' +
            (inline ? '-0.125em' : '0') +
            '}span,svg{display:block}' +
            customStyle;
}

// Core
/**
 * Get functions and initialise stuff
 */
function exportFunctions() {
    /**
     * Initialise stuff
     */
    // Set API module
    setAPIModule('', fetchAPIModule);
    // Allow simple icon names
    allowSimpleNames(true);
    let _window;
    try {
        _window = window;
    }
    catch (err) {
        //
    }
    if (_window) {
        // Set cache and load existing cache
        initBrowserStorage();
        // Load icons from global "IconifyPreload"
        if (_window.IconifyPreload !== void 0) {
            const preload = _window.IconifyPreload;
            const err = 'Invalid IconifyPreload syntax.';
            if (typeof preload === 'object' && preload !== null) {
                (preload instanceof Array ? preload : [preload]).forEach((item) => {
                    try {
                        if (
                        // Check if item is an object and not null/array
                        typeof item !== 'object' ||
                            item === null ||
                            item instanceof Array ||
                            // Check for 'icons' and 'prefix'
                            typeof item.icons !== 'object' ||
                            typeof item.prefix !== 'string' ||
                            // Add icon set
                            !addCollection$1(item)) {
                            console.error(err);
                        }
                    }
                    catch (e) {
                        console.error(err);
                    }
                });
            }
        }
        // Set API from global "IconifyProviders"
        if (_window.IconifyProviders !== void 0) {
            const providers = _window.IconifyProviders;
            if (typeof providers === 'object' && providers !== null) {
                for (const key in providers) {
                    const err = 'IconifyProviders[' + key + '] is invalid.';
                    try {
                        const value = providers[key];
                        if (typeof value !== 'object' ||
                            !value ||
                            value.resources === void 0) {
                            continue;
                        }
                        if (!addAPIProvider$1(key, value)) {
                            console.error(err);
                        }
                    }
                    catch (e) {
                        console.error(err);
                    }
                }
            }
        }
    }
    const _api = {
        getAPIConfig,
        setAPIModule,
        sendAPIQuery,
        setFetch,
        getFetch,
        listAPIProviders,
    };
    return {
        enableCache: (storage) => toggleBrowserCache(storage, true),
        disableCache: (storage) => toggleBrowserCache(storage, false),
        iconExists: iconExists$1,
        getIcon: getIcon$1,
        listIcons: listIcons$1,
        addIcon: addIcon$1,
        addCollection: addCollection$1,
        calculateSize: calculateSize$1,
        buildIcon: iconToSVG,
        loadIcons: loadIcons$1,
        loadIcon: loadIcon$1,
        addAPIProvider: addAPIProvider$1,
        appendCustomStyle,
        _api,
    };
}

function iconToHTML(body, attributes) {
  let renderAttribsHTML = body.indexOf("xlink:") === -1 ? "" : ' xmlns:xlink="http://www.w3.org/1999/xlink"';
  for (const attr in attributes) {
    renderAttribsHTML += " " + attr + '="' + attributes[attr] + '"';
  }
  return '<svg xmlns="http://www.w3.org/2000/svg"' + renderAttribsHTML + ">" + body + "</svg>";
}

function encodeSVGforURL(svg) {
  return svg.replace(/"/g, "'").replace(/%/g, "%25").replace(/#/g, "%23").replace(/</g, "%3C").replace(/>/g, "%3E").replace(/\s+/g, " ");
}
function svgToData(svg) {
  return "data:image/svg+xml," + encodeSVGforURL(svg);
}
function svgToURL(svg) {
  return 'url("' + svgToData(svg) + '")';
}

// List of properties to apply
const monotoneProps = {
    'background-color': 'currentColor',
};
const coloredProps = {
    'background-color': 'transparent',
};
// Dynamically add common props to variables above
const propsToAdd = {
    image: 'var(--svg)',
    repeat: 'no-repeat',
    size: '100% 100%',
};
const propsToAddTo = {
    '-webkit-mask': monotoneProps,
    'mask': monotoneProps,
    'background': coloredProps,
};
for (const prefix in propsToAddTo) {
    const list = propsToAddTo[prefix];
    for (const prop in propsToAdd) {
        list[prefix + '-' + prop] = propsToAdd[prop];
    }
}
/**
 * Fix size: add 'px' to numbers
 */
function fixSize(value) {
    return value ? value + (value.match(/^[-0-9.]+$/) ? 'px' : '') : 'inherit';
}
/**
 * Render node as <span>
 */
function renderSPAN(data, icon, useMask) {
    const node = document.createElement('span');
    // Body
    let body = data.body;
    if (body.indexOf('<a') !== -1) {
        // Animated SVG: add something to fix timing bug
        body += '<!-- ' + Date.now() + ' -->';
    }
    // Generate SVG as URL
    const renderAttribs = data.attributes;
    const html = iconToHTML(body, {
        ...renderAttribs,
        width: icon.width + '',
        height: icon.height + '',
    });
    const url = svgToURL(html);
    // Generate style
    const svgStyle = node.style;
    const styles = {
        '--svg': url,
        'width': fixSize(renderAttribs.width),
        'height': fixSize(renderAttribs.height),
        ...(useMask ? monotoneProps : coloredProps),
    };
    // Apply style
    for (const prop in styles) {
        svgStyle.setProperty(prop, styles[prop]);
    }
    return node;
}

let policy;
function createPolicy() {
  try {
    policy = window.trustedTypes.createPolicy("iconify", {
      // eslint-disable-next-line @typescript-eslint/no-unsafe-return
      createHTML: (s) => s
    });
  } catch (err) {
    policy = null;
  }
}
function cleanUpInnerHTML(html) {
  if (policy === void 0) {
    createPolicy();
  }
  return policy ? policy.createHTML(html) : html;
}

/**
 * Render node as <svg>
 */
function renderSVG(data) {
    const node = document.createElement('span');
    // Add style if needed
    const attr = data.attributes;
    let style = '';
    if (!attr.width) {
        style = 'width: inherit;';
    }
    if (!attr.height) {
        style += 'height: inherit;';
    }
    if (style) {
        attr.style = style;
    }
    // Generate SVG
    const html = iconToHTML(data.body, attr);
    node.innerHTML = cleanUpInnerHTML(html);
    return node.firstChild;
}

/**
 * Render icon
 */
function renderIcon(parent, state) {
    const iconData = state.icon.data;
    const customisations = state.customisations;
    // Render icon
    const renderData = iconToSVG(iconData, customisations);
    if (customisations.preserveAspectRatio) {
        renderData.attributes['preserveAspectRatio'] =
            customisations.preserveAspectRatio;
    }
    const mode = state.renderedMode;
    let node;
    switch (mode) {
        case 'svg':
            node = renderSVG(renderData);
            break;
        default:
            node = renderSPAN(renderData, {
                ...defaultIconProps,
                ...iconData,
            }, mode === 'mask');
    }
    // Set element
    const oldNode = Array.from(parent.childNodes).find((node) => {
        const tag = node.tagName &&
            node.tagName.toUpperCase();
        return tag === 'SPAN' || tag === 'SVG';
    });
    if (oldNode) {
        // Replace old element
        if (node.tagName === 'SPAN' && oldNode.tagName === node.tagName) {
            // Swap style instead of whole node
            oldNode.setAttribute('style', node.getAttribute('style'));
        }
        else {
            parent.replaceChild(node, oldNode);
        }
    }
    else {
        // Add new element
        parent.appendChild(node);
    }
}

/**
 * Set state to PendingState
 */
function setPendingState(icon, inline, lastState) {
    const lastRender = lastState &&
        (lastState.rendered
            ? lastState
            : lastState.lastRender);
    return {
        rendered: false,
        inline,
        icon,
        lastRender,
    };
}

/**
 * Register 'iconify-icon' component, if it does not exist
 */
function defineIconifyIcon(name = 'iconify-icon') {
    // Check for custom elements registry and HTMLElement
    let customElements;
    let ParentClass;
    try {
        customElements = window.customElements;
        ParentClass = window.HTMLElement;
    }
    catch (err) {
        return;
    }
    // Make sure registry and HTMLElement exist
    if (!customElements || !ParentClass) {
        return;
    }
    // Check for duplicate
    const ConflictingClass = customElements.get(name);
    if (ConflictingClass) {
        return ConflictingClass;
    }
    // All attributes
    const attributes = [
        // Icon
        'icon',
        // Mode
        'mode',
        'inline',
        // Customisations
        'width',
        'height',
        'rotate',
        'flip',
    ];
    /**
     * Component class
     */
    const IconifyIcon = class extends ParentClass {
        // Root
        _shadowRoot;
        // State
        _state;
        // Attributes check queued
        _checkQueued = false;
        /**
         * Constructor
         */
        constructor() {
            super();
            // Attach shadow DOM
            const root = (this._shadowRoot = this.attachShadow({
                mode: 'open',
            }));
            // Add style
            const inline = getInline(this);
            updateStyle(root, inline);
            // Create empty state
            this._state = setPendingState({
                value: '',
            }, inline);
            // Queue icon render
            this._queueCheck();
        }
        /**
         * Observed attributes
         */
        static get observedAttributes() {
            return attributes.slice(0);
        }
        /**
         * Observed properties that are different from attributes
         *
         * Experimental! Need to test with various frameworks that support it
         */
        /*
        static get properties() {
            return {
                inline: {
                    type: Boolean,
                    reflect: true,
                },
                // Not listing other attributes because they are strings or combination
                // of string and another type. Cannot have multiple types
            };
        }
        */
        /**
         * Attribute has changed
         */
        attributeChangedCallback(name) {
            if (name === 'inline') {
                // Update immediately: not affected by other attributes
                const newInline = getInline(this);
                const state = this._state;
                if (newInline !== state.inline) {
                    // Update style if inline mode changed
                    state.inline = newInline;
                    updateStyle(this._shadowRoot, newInline);
                }
            }
            else {
                // Queue check for other attributes
                this._queueCheck();
            }
        }
        /**
         * Get/set icon
         */
        get icon() {
            const value = this.getAttribute('icon');
            if (value && value.slice(0, 1) === '{') {
                try {
                    return JSON.parse(value);
                }
                catch (err) {
                    //
                }
            }
            return value;
        }
        set icon(value) {
            if (typeof value === 'object') {
                value = JSON.stringify(value);
            }
            this.setAttribute('icon', value);
        }
        /**
         * Get/set inline
         */
        get inline() {
            return getInline(this);
        }
        set inline(value) {
            if (value) {
                this.setAttribute('inline', 'true');
            }
            else {
                this.removeAttribute('inline');
            }
        }
        /**
         * Restart animation
         */
        restartAnimation() {
            const state = this._state;
            if (state.rendered) {
                const root = this._shadowRoot;
                if (state.renderedMode === 'svg') {
                    // Update root node
                    try {
                        root.lastChild.setCurrentTime(0);
                        return;
                    }
                    catch (err) {
                        // Failed: setCurrentTime() is not supported
                    }
                }
                renderIcon(root, state);
            }
        }
        /**
         * Get status
         */
        get status() {
            const state = this._state;
            return state.rendered
                ? 'rendered'
                : state.icon.data === null
                    ? 'failed'
                    : 'loading';
        }
        /**
         * Queue attributes re-check
         */
        _queueCheck() {
            if (!this._checkQueued) {
                this._checkQueued = true;
                setTimeout(() => {
                    this._check();
                });
            }
        }
        /**
         * Check for changes
         */
        _check() {
            if (!this._checkQueued) {
                return;
            }
            this._checkQueued = false;
            const state = this._state;
            // Get icon
            const newIcon = this.getAttribute('icon');
            if (newIcon !== state.icon.value) {
                this._iconChanged(newIcon);
                return;
            }
            // Ignore other attributes if icon is not rendered
            if (!state.rendered) {
                return;
            }
            // Check for mode and attribute changes
            const mode = this.getAttribute('mode');
            const customisations = getCustomisations(this);
            if (state.attrMode !== mode ||
                haveCustomisationsChanged(state.customisations, customisations)) {
                this._renderIcon(state.icon, customisations, mode);
            }
        }
        /**
         * Icon value has changed
         */
        _iconChanged(newValue) {
            const icon = parseIconValue(newValue, (value, name, data) => {
                // Asynchronous callback: re-check values to make sure stuff wasn't changed
                const state = this._state;
                if (state.rendered || this.getAttribute('icon') !== value) {
                    // Icon data is already available or icon attribute was changed
                    return;
                }
                // Change icon
                const icon = {
                    value,
                    name,
                    data,
                };
                if (icon.data) {
                    // Render icon
                    this._gotIconData(icon);
                }
                else {
                    // Nothing to render: update icon in state
                    state.icon = icon;
                }
            });
            if (icon.data) {
                // Icon is ready to render
                this._gotIconData(icon);
            }
            else {
                // Pending icon
                this._state = setPendingState(icon, this._state.inline, this._state);
            }
        }
        /**
         * Got new icon data, icon is ready to (re)render
         */
        _gotIconData(icon) {
            this._checkQueued = false;
            this._renderIcon(icon, getCustomisations(this), this.getAttribute('mode'));
        }
        /**
         * Re-render based on icon data
         */
        _renderIcon(icon, customisations, attrMode) {
            // Get mode
            const renderedMode = getRenderMode(icon.data.body, attrMode);
            // Inline was not changed
            const inline = this._state.inline;
            // Set state and render
            renderIcon(this._shadowRoot, (this._state = {
                rendered: true,
                icon,
                inline,
                customisations,
                attrMode,
                renderedMode,
            }));
        }
    };
    // Add getters and setters
    attributes.forEach((attr) => {
        if (!(attr in IconifyIcon.prototype)) {
            Object.defineProperty(IconifyIcon.prototype, attr, {
                get: function () {
                    return this.getAttribute(attr);
                },
                set: function (value) {
                    if (value !== null) {
                        this.setAttribute(attr, value);
                    }
                    else {
                        this.removeAttribute(attr);
                    }
                },
            });
        }
    });
    // Add exported functions: both as static and instance methods
    const functions = exportFunctions();
    for (const key in functions) {
        IconifyIcon[key] = IconifyIcon.prototype[key] = functions[key];
    }
    // Define new component
    customElements.define(name, IconifyIcon);
    return IconifyIcon;
}

/**
 * Create exported data: either component instance or functions
 */
const IconifyIconComponent = defineIconifyIcon() || exportFunctions();
/**
 * Export functions
 */
const { enableCache, disableCache, iconExists, getIcon, listIcons, addIcon, addCollection, calculateSize, buildIcon, loadIcons, loadIcon, addAPIProvider, _api, } = IconifyIconComponent;




/***/ }),

/***/ "./node_modules/lit-element/development/lit-element.js":
/*!*************************************************************!*\
  !*** ./node_modules/lit-element/development/lit-element.js ***!
  \*************************************************************/
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   CSSResult: () => (/* reexport safe */ _lit_reactive_element__WEBPACK_IMPORTED_MODULE_0__.CSSResult),
/* harmony export */   LitElement: () => (/* binding */ LitElement),
/* harmony export */   ReactiveElement: () => (/* reexport safe */ _lit_reactive_element__WEBPACK_IMPORTED_MODULE_0__.ReactiveElement),
/* harmony export */   UpdatingElement: () => (/* binding */ UpdatingElement),
/* harmony export */   _$LE: () => (/* binding */ _$LE),
/* harmony export */   _$LH: () => (/* reexport safe */ lit_html__WEBPACK_IMPORTED_MODULE_1__._$LH),
/* harmony export */   adoptStyles: () => (/* reexport safe */ _lit_reactive_element__WEBPACK_IMPORTED_MODULE_0__.adoptStyles),
/* harmony export */   css: () => (/* reexport safe */ _lit_reactive_element__WEBPACK_IMPORTED_MODULE_0__.css),
/* harmony export */   defaultConverter: () => (/* reexport safe */ _lit_reactive_element__WEBPACK_IMPORTED_MODULE_0__.defaultConverter),
/* harmony export */   getCompatibleStyle: () => (/* reexport safe */ _lit_reactive_element__WEBPACK_IMPORTED_MODULE_0__.getCompatibleStyle),
/* harmony export */   html: () => (/* reexport safe */ lit_html__WEBPACK_IMPORTED_MODULE_1__.html),
/* harmony export */   noChange: () => (/* reexport safe */ lit_html__WEBPACK_IMPORTED_MODULE_1__.noChange),
/* harmony export */   notEqual: () => (/* reexport safe */ _lit_reactive_element__WEBPACK_IMPORTED_MODULE_0__.notEqual),
/* harmony export */   nothing: () => (/* reexport safe */ lit_html__WEBPACK_IMPORTED_MODULE_1__.nothing),
/* harmony export */   render: () => (/* reexport safe */ lit_html__WEBPACK_IMPORTED_MODULE_1__.render),
/* harmony export */   supportsAdoptingStyleSheets: () => (/* reexport safe */ _lit_reactive_element__WEBPACK_IMPORTED_MODULE_0__.supportsAdoptingStyleSheets),
/* harmony export */   svg: () => (/* reexport safe */ lit_html__WEBPACK_IMPORTED_MODULE_1__.svg),
/* harmony export */   unsafeCSS: () => (/* reexport safe */ _lit_reactive_element__WEBPACK_IMPORTED_MODULE_0__.unsafeCSS)
/* harmony export */ });
/* harmony import */ var _lit_reactive_element__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! @lit/reactive-element */ "./node_modules/@lit/reactive-element/development/reactive-element.js");
/* harmony import */ var lit_html__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! lit-html */ "./node_modules/lit-html/development/lit-html.js");
/**
 * @license
 * Copyright 2017 Google LLC
 * SPDX-License-Identifier: BSD-3-Clause
 */
var _a, _b, _c;
/**
 * The main LitElement module, which defines the {@linkcode LitElement} base
 * class and related APIs.
 *
 *  LitElement components can define a template and a set of observed
 * properties. Changing an observed property triggers a re-render of the
 * element.
 *
 *  Import {@linkcode LitElement} and {@linkcode html} from this module to
 * create a component:
 *
 *  ```js
 * import {LitElement, html} from 'lit-element';
 *
 * class MyElement extends LitElement {
 *
 *   // Declare observed properties
 *   static get properties() {
 *     return {
 *       adjective: {}
 *     }
 *   }
 *
 *   constructor() {
 *     this.adjective = 'awesome';
 *   }
 *
 *   // Define the element's template
 *   render() {
 *     return html`<p>your ${adjective} template here</p>`;
 *   }
 * }
 *
 * customElements.define('my-element', MyElement);
 * ```
 *
 * `LitElement` extends {@linkcode ReactiveElement} and adds lit-html
 * templating. The `ReactiveElement` class is provided for users that want to
 * build their own custom element base classes that don't use lit-html.
 *
 * @packageDocumentation
 */




// For backwards compatibility export ReactiveElement as UpdatingElement. Note,
// IE transpilation requires exporting like this.
const UpdatingElement = _lit_reactive_element__WEBPACK_IMPORTED_MODULE_0__.ReactiveElement;
const DEV_MODE = true;
let issueWarning;
if (DEV_MODE) {
    // Ensure warnings are issued only 1x, even if multiple versions of Lit
    // are loaded.
    const issuedWarnings = ((_a = globalThis.litIssuedWarnings) !== null && _a !== void 0 ? _a : (globalThis.litIssuedWarnings = new Set()));
    // Issue a warning, if we haven't already.
    issueWarning = (code, warning) => {
        warning += ` See https://lit.dev/msg/${code} for more information.`;
        if (!issuedWarnings.has(warning)) {
            console.warn(warning);
            issuedWarnings.add(warning);
        }
    };
}
/**
 * Base element class that manages element properties and attributes, and
 * renders a lit-html template.
 *
 * To define a component, subclass `LitElement` and implement a
 * `render` method to provide the component's template. Define properties
 * using the {@linkcode LitElement.properties properties} property or the
 * {@linkcode property} decorator.
 */
class LitElement extends _lit_reactive_element__WEBPACK_IMPORTED_MODULE_0__.ReactiveElement {
    constructor() {
        super(...arguments);
        /**
         * @category rendering
         */
        this.renderOptions = { host: this };
        this.__childPart = undefined;
    }
    /**
     * @category rendering
     */
    createRenderRoot() {
        var _a;
        var _b;
        const renderRoot = super.createRenderRoot();
        // When adoptedStyleSheets are shimmed, they are inserted into the
        // shadowRoot by createRenderRoot. Adjust the renderBefore node so that
        // any styles in Lit content render before adoptedStyleSheets. This is
        // important so that adoptedStyleSheets have precedence over styles in
        // the shadowRoot.
        (_a = (_b = this.renderOptions).renderBefore) !== null && _a !== void 0 ? _a : (_b.renderBefore = renderRoot.firstChild);
        return renderRoot;
    }
    /**
     * Updates the element. This method reflects property values to attributes
     * and calls `render` to render DOM via lit-html. Setting properties inside
     * this method will *not* trigger another update.
     * @param changedProperties Map of changed properties with old values
     * @category updates
     */
    update(changedProperties) {
        // Setting properties in `render` should not trigger an update. Since
        // updates are allowed after super.update, it's important to call `render`
        // before that.
        const value = this.render();
        if (!this.hasUpdated) {
            this.renderOptions.isConnected = this.isConnected;
        }
        super.update(changedProperties);
        this.__childPart = (0,lit_html__WEBPACK_IMPORTED_MODULE_1__.render)(value, this.renderRoot, this.renderOptions);
    }
    /**
     * Invoked when the component is added to the document's DOM.
     *
     * In `connectedCallback()` you should setup tasks that should only occur when
     * the element is connected to the document. The most common of these is
     * adding event listeners to nodes external to the element, like a keydown
     * event handler added to the window.
     *
     * ```ts
     * connectedCallback() {
     *   super.connectedCallback();
     *   addEventListener('keydown', this._handleKeydown);
     * }
     * ```
     *
     * Typically, anything done in `connectedCallback()` should be undone when the
     * element is disconnected, in `disconnectedCallback()`.
     *
     * @category lifecycle
     */
    connectedCallback() {
        var _a;
        super.connectedCallback();
        (_a = this.__childPart) === null || _a === void 0 ? void 0 : _a.setConnected(true);
    }
    /**
     * Invoked when the component is removed from the document's DOM.
     *
     * This callback is the main signal to the element that it may no longer be
     * used. `disconnectedCallback()` should ensure that nothing is holding a
     * reference to the element (such as event listeners added to nodes external
     * to the element), so that it is free to be garbage collected.
     *
     * ```ts
     * disconnectedCallback() {
     *   super.disconnectedCallback();
     *   window.removeEventListener('keydown', this._handleKeydown);
     * }
     * ```
     *
     * An element may be re-connected after being disconnected.
     *
     * @category lifecycle
     */
    disconnectedCallback() {
        var _a;
        super.disconnectedCallback();
        (_a = this.__childPart) === null || _a === void 0 ? void 0 : _a.setConnected(false);
    }
    /**
     * Invoked on each update to perform rendering tasks. This method may return
     * any value renderable by lit-html's `ChildPart` - typically a
     * `TemplateResult`. Setting properties inside this method will *not* trigger
     * the element to update.
     * @category rendering
     */
    render() {
        return lit_html__WEBPACK_IMPORTED_MODULE_1__.noChange;
    }
}
/**
 * Ensure this class is marked as `finalized` as an optimization ensuring
 * it will not needlessly try to `finalize`.
 *
 * Note this property name is a string to prevent breaking Closure JS Compiler
 * optimizations. See @lit/reactive-element for more information.
 */
LitElement['finalized'] = true;
// This property needs to remain unminified.
LitElement['_$litElement$'] = true;
// Install hydration if available
(_b = globalThis.litElementHydrateSupport) === null || _b === void 0 ? void 0 : _b.call(globalThis, { LitElement });
// Apply polyfills if available
const polyfillSupport = DEV_MODE
    ? globalThis.litElementPolyfillSupportDevMode
    : globalThis.litElementPolyfillSupport;
polyfillSupport === null || polyfillSupport === void 0 ? void 0 : polyfillSupport({ LitElement });
// DEV mode warnings
if (DEV_MODE) {
    /* eslint-disable @typescript-eslint/no-explicit-any */
    // Note, for compatibility with closure compilation, this access
    // needs to be as a string property index.
    LitElement['finalize'] = function () {
        const finalized = _lit_reactive_element__WEBPACK_IMPORTED_MODULE_0__.ReactiveElement.finalize.call(this);
        if (!finalized) {
            return false;
        }
        const warnRemovedOrRenamed = (obj, name, renamed = false) => {
            if (obj.hasOwnProperty(name)) {
                const ctorName = (typeof obj === 'function' ? obj : obj.constructor)
                    .name;
                issueWarning(renamed ? 'renamed-api' : 'removed-api', `\`${name}\` is implemented on class ${ctorName}. It ` +
                    `has been ${renamed ? 'renamed' : 'removed'} ` +
                    `in this version of LitElement.`);
            }
        };
        warnRemovedOrRenamed(this, 'render');
        warnRemovedOrRenamed(this, 'getStyles', true);
        warnRemovedOrRenamed(this.prototype, 'adoptStyles');
        return true;
    };
    /* eslint-enable @typescript-eslint/no-explicit-any */
}
/**
 * END USERS SHOULD NOT RELY ON THIS OBJECT.
 *
 * Private exports for use by other Lit packages, not intended for use by
 * external users.
 *
 * We currently do not make a mangled rollup build of the lit-ssr code. In order
 * to keep a number of (otherwise private) top-level exports  mangled in the
 * client side code, we export a _$LE object containing those members (or
 * helper methods for accessing private fields of those members), and then
 * re-export them for use in lit-ssr. This keeps lit-ssr agnostic to whether the
 * client-side code is being used in `dev` mode or `prod` mode.
 *
 * This has a unique name, to disambiguate it from private exports in
 * lit-html, since this module re-exports all of lit-html.
 *
 * @private
 */
const _$LE = {
    _$attributeToProperty: (el, name, value) => {
        // eslint-disable-next-line
        el._$attributeToProperty(name, value);
    },
    // eslint-disable-next-line
    _$changedProperties: (el) => el._$changedProperties,
};
// IMPORTANT: do not change the property name or the assignment expression.
// This line will be used in regexes to search for LitElement usage.
((_c = globalThis.litElementVersions) !== null && _c !== void 0 ? _c : (globalThis.litElementVersions = [])).push('3.3.3');
if (DEV_MODE && globalThis.litElementVersions.length > 1) {
    issueWarning('multiple-versions', `Multiple versions of Lit loaded. Loading multiple versions ` +
        `is not recommended.`);
}
//# sourceMappingURL=lit-element.js.map

/***/ }),

/***/ "./node_modules/lit-html/development/directive-helpers.js":
/*!****************************************************************!*\
  !*** ./node_modules/lit-html/development/directive-helpers.js ***!
  \****************************************************************/
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   TemplateResultType: () => (/* binding */ TemplateResultType),
/* harmony export */   clearPart: () => (/* binding */ clearPart),
/* harmony export */   getCommittedValue: () => (/* binding */ getCommittedValue),
/* harmony export */   getDirectiveClass: () => (/* binding */ getDirectiveClass),
/* harmony export */   insertPart: () => (/* binding */ insertPart),
/* harmony export */   isCompiledTemplateResult: () => (/* binding */ isCompiledTemplateResult),
/* harmony export */   isDirectiveResult: () => (/* binding */ isDirectiveResult),
/* harmony export */   isPrimitive: () => (/* binding */ isPrimitive),
/* harmony export */   isSingleExpression: () => (/* binding */ isSingleExpression),
/* harmony export */   isTemplateResult: () => (/* binding */ isTemplateResult),
/* harmony export */   removePart: () => (/* binding */ removePart),
/* harmony export */   setChildPartValue: () => (/* binding */ setChildPartValue),
/* harmony export */   setCommittedValue: () => (/* binding */ setCommittedValue)
/* harmony export */ });
/* harmony import */ var _lit_html_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./lit-html.js */ "./node_modules/lit-html/development/lit-html.js");
/**
 * @license
 * Copyright 2020 Google LLC
 * SPDX-License-Identifier: BSD-3-Clause
 */
var _a, _b;

const { _ChildPart: ChildPart } = _lit_html_js__WEBPACK_IMPORTED_MODULE_0__._$LH;
const ENABLE_SHADYDOM_NOPATCH = true;
const wrap = ENABLE_SHADYDOM_NOPATCH &&
    ((_a = window.ShadyDOM) === null || _a === void 0 ? void 0 : _a.inUse) &&
    ((_b = window.ShadyDOM) === null || _b === void 0 ? void 0 : _b.noPatch) === true
    ? window.ShadyDOM.wrap
    : (node) => node;
/**
 * Tests if a value is a primitive value.
 *
 * See https://tc39.github.io/ecma262/#sec-typeof-operator
 */
const isPrimitive = (value) => value === null || (typeof value != 'object' && typeof value != 'function');
const TemplateResultType = {
    HTML: 1,
    SVG: 2,
};
/**
 * Tests if a value is a TemplateResult or a CompiledTemplateResult.
 */
const isTemplateResult = (value, type) => type === undefined
    ? // This property needs to remain unminified.
        (value === null || value === void 0 ? void 0 : value['_$litType$']) !== undefined
    : (value === null || value === void 0 ? void 0 : value['_$litType$']) === type;
/**
 * Tests if a value is a CompiledTemplateResult.
 */
const isCompiledTemplateResult = (value) => {
    var _a;
    return ((_a = value === null || value === void 0 ? void 0 : value['_$litType$']) === null || _a === void 0 ? void 0 : _a.h) != null;
};
/**
 * Tests if a value is a DirectiveResult.
 */
const isDirectiveResult = (value) => 
// This property needs to remain unminified.
(value === null || value === void 0 ? void 0 : value['_$litDirective$']) !== undefined;
/**
 * Retrieves the Directive class for a DirectiveResult
 */
const getDirectiveClass = (value) => 
// This property needs to remain unminified.
value === null || value === void 0 ? void 0 : value['_$litDirective$'];
/**
 * Tests whether a part has only a single-expression with no strings to
 * interpolate between.
 *
 * Only AttributePart and PropertyPart can have multiple expressions.
 * Multi-expression parts have a `strings` property and single-expression
 * parts do not.
 */
const isSingleExpression = (part) => part.strings === undefined;
const createMarker = () => document.createComment('');
/**
 * Inserts a ChildPart into the given container ChildPart's DOM, either at the
 * end of the container ChildPart, or before the optional `refPart`.
 *
 * This does not add the part to the containerPart's committed value. That must
 * be done by callers.
 *
 * @param containerPart Part within which to add the new ChildPart
 * @param refPart Part before which to add the new ChildPart; when omitted the
 *     part added to the end of the `containerPart`
 * @param part Part to insert, or undefined to create a new part
 */
const insertPart = (containerPart, refPart, part) => {
    var _a;
    const container = wrap(containerPart._$startNode).parentNode;
    const refNode = refPart === undefined ? containerPart._$endNode : refPart._$startNode;
    if (part === undefined) {
        const startNode = wrap(container).insertBefore(createMarker(), refNode);
        const endNode = wrap(container).insertBefore(createMarker(), refNode);
        part = new ChildPart(startNode, endNode, containerPart, containerPart.options);
    }
    else {
        const endNode = wrap(part._$endNode).nextSibling;
        const oldParent = part._$parent;
        const parentChanged = oldParent !== containerPart;
        if (parentChanged) {
            (_a = part._$reparentDisconnectables) === null || _a === void 0 ? void 0 : _a.call(part, containerPart);
            // Note that although `_$reparentDisconnectables` updates the part's
            // `_$parent` reference after unlinking from its current parent, that
            // method only exists if Disconnectables are present, so we need to
            // unconditionally set it here
            part._$parent = containerPart;
            // Since the _$isConnected getter is somewhat costly, only
            // read it once we know the subtree has directives that need
            // to be notified
            let newConnectionState;
            if (part._$notifyConnectionChanged !== undefined &&
                (newConnectionState = containerPart._$isConnected) !==
                    oldParent._$isConnected) {
                part._$notifyConnectionChanged(newConnectionState);
            }
        }
        if (endNode !== refNode || parentChanged) {
            let start = part._$startNode;
            while (start !== endNode) {
                const n = wrap(start).nextSibling;
                wrap(container).insertBefore(start, refNode);
                start = n;
            }
        }
    }
    return part;
};
/**
 * Sets the value of a Part.
 *
 * Note that this should only be used to set/update the value of user-created
 * parts (i.e. those created using `insertPart`); it should not be used
 * by directives to set the value of the directive's container part. Directives
 * should return a value from `update`/`render` to update their part state.
 *
 * For directives that require setting their part value asynchronously, they
 * should extend `AsyncDirective` and call `this.setValue()`.
 *
 * @param part Part to set
 * @param value Value to set
 * @param index For `AttributePart`s, the index to set
 * @param directiveParent Used internally; should not be set by user
 */
const setChildPartValue = (part, value, directiveParent = part) => {
    part._$setValue(value, directiveParent);
    return part;
};
// A sentinel value that can never appear as a part value except when set by
// live(). Used to force a dirty-check to fail and cause a re-render.
const RESET_VALUE = {};
/**
 * Sets the committed value of a ChildPart directly without triggering the
 * commit stage of the part.
 *
 * This is useful in cases where a directive needs to update the part such
 * that the next update detects a value change or not. When value is omitted,
 * the next update will be guaranteed to be detected as a change.
 *
 * @param part
 * @param value
 */
const setCommittedValue = (part, value = RESET_VALUE) => (part._$committedValue = value);
/**
 * Returns the committed value of a ChildPart.
 *
 * The committed value is used for change detection and efficient updates of
 * the part. It can differ from the value set by the template or directive in
 * cases where the template value is transformed before being committed.
 *
 * - `TemplateResult`s are committed as a `TemplateInstance`
 * - Iterables are committed as `Array<ChildPart>`
 * - All other types are committed as the template value or value returned or
 *   set by a directive.
 *
 * @param part
 */
const getCommittedValue = (part) => part._$committedValue;
/**
 * Removes a ChildPart from the DOM, including any of its content.
 *
 * @param part The Part to remove
 */
const removePart = (part) => {
    var _a;
    (_a = part._$notifyConnectionChanged) === null || _a === void 0 ? void 0 : _a.call(part, false, true);
    let start = part._$startNode;
    const end = wrap(part._$endNode).nextSibling;
    while (start !== end) {
        const n = wrap(start).nextSibling;
        wrap(start).remove();
        start = n;
    }
};
const clearPart = (part) => {
    part._$clear();
};
//# sourceMappingURL=directive-helpers.js.map

/***/ }),

/***/ "./node_modules/lit-html/development/directive.js":
/*!********************************************************!*\
  !*** ./node_modules/lit-html/development/directive.js ***!
  \********************************************************/
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   Directive: () => (/* binding */ Directive),
/* harmony export */   PartType: () => (/* binding */ PartType),
/* harmony export */   directive: () => (/* binding */ directive)
/* harmony export */ });
/**
 * @license
 * Copyright 2017 Google LLC
 * SPDX-License-Identifier: BSD-3-Clause
 */
const PartType = {
    ATTRIBUTE: 1,
    CHILD: 2,
    PROPERTY: 3,
    BOOLEAN_ATTRIBUTE: 4,
    EVENT: 5,
    ELEMENT: 6,
};
/**
 * Creates a user-facing directive function from a Directive class. This
 * function has the same parameters as the directive's render() method.
 */
const directive = (c) => (...values) => ({
    // This property needs to remain unminified.
    ['_$litDirective$']: c,
    values,
});
/**
 * Base class for creating custom directives. Users should extend this class,
 * implement `render` and/or `update`, and then pass their subclass to
 * `directive`.
 */
class Directive {
    constructor(_partInfo) { }
    // See comment in Disconnectable interface for why this is a getter
    get _$isConnected() {
        return this._$parent._$isConnected;
    }
    /** @internal */
    _$initialize(part, parent, attributeIndex) {
        this.__part = part;
        this._$parent = parent;
        this.__attributeIndex = attributeIndex;
    }
    /** @internal */
    _$resolve(part, props) {
        return this.update(part, props);
    }
    update(_part, props) {
        return this.render(...props);
    }
}
//# sourceMappingURL=directive.js.map

/***/ }),

/***/ "./node_modules/lit-html/development/directives/class-map.js":
/*!*******************************************************************!*\
  !*** ./node_modules/lit-html/development/directives/class-map.js ***!
  \*******************************************************************/
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   classMap: () => (/* binding */ classMap)
/* harmony export */ });
/* harmony import */ var _lit_html_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ../lit-html.js */ "./node_modules/lit-html/development/lit-html.js");
/* harmony import */ var _directive_js__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ../directive.js */ "./node_modules/lit-html/development/directive.js");
/**
 * @license
 * Copyright 2018 Google LLC
 * SPDX-License-Identifier: BSD-3-Clause
 */


class ClassMapDirective extends _directive_js__WEBPACK_IMPORTED_MODULE_1__.Directive {
    constructor(partInfo) {
        var _a;
        super(partInfo);
        if (partInfo.type !== _directive_js__WEBPACK_IMPORTED_MODULE_1__.PartType.ATTRIBUTE ||
            partInfo.name !== 'class' ||
            ((_a = partInfo.strings) === null || _a === void 0 ? void 0 : _a.length) > 2) {
            throw new Error('`classMap()` can only be used in the `class` attribute ' +
                'and must be the only part in the attribute.');
        }
    }
    render(classInfo) {
        // Add spaces to ensure separation from static classes
        return (' ' +
            Object.keys(classInfo)
                .filter((key) => classInfo[key])
                .join(' ') +
            ' ');
    }
    update(part, [classInfo]) {
        var _a, _b;
        // Remember dynamic classes on the first render
        if (this._previousClasses === undefined) {
            this._previousClasses = new Set();
            if (part.strings !== undefined) {
                this._staticClasses = new Set(part.strings
                    .join(' ')
                    .split(/\s/)
                    .filter((s) => s !== ''));
            }
            for (const name in classInfo) {
                if (classInfo[name] && !((_a = this._staticClasses) === null || _a === void 0 ? void 0 : _a.has(name))) {
                    this._previousClasses.add(name);
                }
            }
            return this.render(classInfo);
        }
        const classList = part.element.classList;
        // Remove old classes that no longer apply
        // We use forEach() instead of for-of so that we don't require down-level
        // iteration.
        this._previousClasses.forEach((name) => {
            if (!(name in classInfo)) {
                classList.remove(name);
                this._previousClasses.delete(name);
            }
        });
        // Add or remove classes based on their classMap value
        for (const name in classInfo) {
            // We explicitly want a loose truthy check of `value` because it seems
            // more convenient that '' and 0 are skipped.
            const value = !!classInfo[name];
            if (value !== this._previousClasses.has(name) &&
                !((_b = this._staticClasses) === null || _b === void 0 ? void 0 : _b.has(name))) {
                if (value) {
                    classList.add(name);
                    this._previousClasses.add(name);
                }
                else {
                    classList.remove(name);
                    this._previousClasses.delete(name);
                }
            }
        }
        return _lit_html_js__WEBPACK_IMPORTED_MODULE_0__.noChange;
    }
}
/**
 * A directive that applies dynamic CSS classes.
 *
 * This must be used in the `class` attribute and must be the only part used in
 * the attribute. It takes each property in the `classInfo` argument and adds
 * the property name to the element's `classList` if the property value is
 * truthy; if the property value is falsey, the property name is removed from
 * the element's `class`.
 *
 * For example `{foo: bar}` applies the class `foo` if the value of `bar` is
 * truthy.
 *
 * @param classInfo
 */
const classMap = (0,_directive_js__WEBPACK_IMPORTED_MODULE_1__.directive)(ClassMapDirective);
//# sourceMappingURL=class-map.js.map

/***/ }),

/***/ "./node_modules/lit-html/development/directives/if-defined.js":
/*!********************************************************************!*\
  !*** ./node_modules/lit-html/development/directives/if-defined.js ***!
  \********************************************************************/
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   ifDefined: () => (/* binding */ ifDefined)
/* harmony export */ });
/* harmony import */ var _lit_html_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ../lit-html.js */ "./node_modules/lit-html/development/lit-html.js");
/**
 * @license
 * Copyright 2018 Google LLC
 * SPDX-License-Identifier: BSD-3-Clause
 */

/**
 * For AttributeParts, sets the attribute if the value is defined and removes
 * the attribute if the value is undefined.
 *
 * For other part types, this directive is a no-op.
 */
const ifDefined = (value) => value !== null && value !== void 0 ? value : _lit_html_js__WEBPACK_IMPORTED_MODULE_0__.nothing;
//# sourceMappingURL=if-defined.js.map

/***/ }),

/***/ "./node_modules/lit-html/development/directives/map.js":
/*!*************************************************************!*\
  !*** ./node_modules/lit-html/development/directives/map.js ***!
  \*************************************************************/
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   map: () => (/* binding */ map)
/* harmony export */ });
/**
 * @license
 * Copyright 2021 Google LLC
 * SPDX-License-Identifier: BSD-3-Clause
 */
/**
 * Returns an iterable containing the result of calling `f(value)` on each
 * value in `items`.
 *
 * @example
 *
 * ```ts
 * render() {
 *   return html`
 *     <ul>
 *       ${map(items, (i) => html`<li>${i}</li>`)}
 *     </ul>
 *   `;
 * }
 * ```
 */
function* map(items, f) {
    if (items !== undefined) {
        let i = 0;
        for (const value of items) {
            yield f(value, i++);
        }
    }
}
//# sourceMappingURL=map.js.map

/***/ }),

/***/ "./node_modules/lit-html/development/directives/repeat.js":
/*!****************************************************************!*\
  !*** ./node_modules/lit-html/development/directives/repeat.js ***!
  \****************************************************************/
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   repeat: () => (/* binding */ repeat)
/* harmony export */ });
/* harmony import */ var _lit_html_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ../lit-html.js */ "./node_modules/lit-html/development/lit-html.js");
/* harmony import */ var _directive_js__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ../directive.js */ "./node_modules/lit-html/development/directive.js");
/* harmony import */ var _directive_helpers_js__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! ../directive-helpers.js */ "./node_modules/lit-html/development/directive-helpers.js");
/**
 * @license
 * Copyright 2017 Google LLC
 * SPDX-License-Identifier: BSD-3-Clause
 */



// Helper for generating a map of array item to its index over a subset
// of an array (used to lazily generate `newKeyToIndexMap` and
// `oldKeyToIndexMap`)
const generateMap = (list, start, end) => {
    const map = new Map();
    for (let i = start; i <= end; i++) {
        map.set(list[i], i);
    }
    return map;
};
class RepeatDirective extends _directive_js__WEBPACK_IMPORTED_MODULE_1__.Directive {
    constructor(partInfo) {
        super(partInfo);
        if (partInfo.type !== _directive_js__WEBPACK_IMPORTED_MODULE_1__.PartType.CHILD) {
            throw new Error('repeat() can only be used in text expressions');
        }
    }
    _getValuesAndKeys(items, keyFnOrTemplate, template) {
        let keyFn;
        if (template === undefined) {
            template = keyFnOrTemplate;
        }
        else if (keyFnOrTemplate !== undefined) {
            keyFn = keyFnOrTemplate;
        }
        const keys = [];
        const values = [];
        let index = 0;
        for (const item of items) {
            keys[index] = keyFn ? keyFn(item, index) : index;
            values[index] = template(item, index);
            index++;
        }
        return {
            values,
            keys,
        };
    }
    render(items, keyFnOrTemplate, template) {
        return this._getValuesAndKeys(items, keyFnOrTemplate, template).values;
    }
    update(containerPart, [items, keyFnOrTemplate, template]) {
        var _a;
        // Old part & key lists are retrieved from the last update (which may
        // be primed by hydration)
        const oldParts = (0,_directive_helpers_js__WEBPACK_IMPORTED_MODULE_2__.getCommittedValue)(containerPart);
        const { values: newValues, keys: newKeys } = this._getValuesAndKeys(items, keyFnOrTemplate, template);
        // We check that oldParts, the committed value, is an Array as an
        // indicator that the previous value came from a repeat() call. If
        // oldParts is not an Array then this is the first render and we return
        // an array for lit-html's array handling to render, and remember the
        // keys.
        if (!Array.isArray(oldParts)) {
            this._itemKeys = newKeys;
            return newValues;
        }
        // In SSR hydration it's possible for oldParts to be an array but for us
        // to not have item keys because the update() hasn't run yet. We set the
        // keys to an empty array. This will cause all oldKey/newKey comparisons
        // to fail and execution to fall to the last nested brach below which
        // reuses the oldPart.
        const oldKeys = ((_a = this._itemKeys) !== null && _a !== void 0 ? _a : (this._itemKeys = []));
        // New part list will be built up as we go (either reused from
        // old parts or created for new keys in this update). This is
        // saved in the above cache at the end of the update.
        const newParts = [];
        // Maps from key to index for current and previous update; these
        // are generated lazily only when needed as a performance
        // optimization, since they are only required for multiple
        // non-contiguous changes in the list, which are less common.
        let newKeyToIndexMap;
        let oldKeyToIndexMap;
        // Head and tail pointers to old parts and new values
        let oldHead = 0;
        let oldTail = oldParts.length - 1;
        let newHead = 0;
        let newTail = newValues.length - 1;
        // Overview of O(n) reconciliation algorithm (general approach
        // based on ideas found in ivi, vue, snabbdom, etc.):
        //
        // * We start with the list of old parts and new values (and
        //   arrays of their respective keys), head/tail pointers into
        //   each, and we build up the new list of parts by updating
        //   (and when needed, moving) old parts or creating new ones.
        //   The initial scenario might look like this (for brevity of
        //   the diagrams, the numbers in the array reflect keys
        //   associated with the old parts or new values, although keys
        //   and parts/values are actually stored in parallel arrays
        //   indexed using the same head/tail pointers):
        //
        //      oldHead v                 v oldTail
        //   oldKeys:  [0, 1, 2, 3, 4, 5, 6]
        //   newParts: [ ,  ,  ,  ,  ,  ,  ]
        //   newKeys:  [0, 2, 1, 4, 3, 7, 6] <- reflects the user's new
        //                                      item order
        //      newHead ^                 ^ newTail
        //
        // * Iterate old & new lists from both sides, updating,
        //   swapping, or removing parts at the head/tail locations
        //   until neither head nor tail can move.
        //
        // * Example below: keys at head pointers match, so update old
        //   part 0 in-place (no need to move it) and record part 0 in
        //   the `newParts` list. The last thing we do is advance the
        //   `oldHead` and `newHead` pointers (will be reflected in the
        //   next diagram).
        //
        //      oldHead v                 v oldTail
        //   oldKeys:  [0, 1, 2, 3, 4, 5, 6]
        //   newParts: [0,  ,  ,  ,  ,  ,  ] <- heads matched: update 0
        //   newKeys:  [0, 2, 1, 4, 3, 7, 6]    and advance both oldHead
        //                                      & newHead
        //      newHead ^                 ^ newTail
        //
        // * Example below: head pointers don't match, but tail
        //   pointers do, so update part 6 in place (no need to move
        //   it), and record part 6 in the `newParts` list. Last,
        //   advance the `oldTail` and `oldHead` pointers.
        //
        //         oldHead v              v oldTail
        //   oldKeys:  [0, 1, 2, 3, 4, 5, 6]
        //   newParts: [0,  ,  ,  ,  ,  , 6] <- tails matched: update 6
        //   newKeys:  [0, 2, 1, 4, 3, 7, 6]    and advance both oldTail
        //                                      & newTail
        //         newHead ^              ^ newTail
        //
        // * If neither head nor tail match; next check if one of the
        //   old head/tail items was removed. We first need to generate
        //   the reverse map of new keys to index (`newKeyToIndexMap`),
        //   which is done once lazily as a performance optimization,
        //   since we only hit this case if multiple non-contiguous
        //   changes were made. Note that for contiguous removal
        //   anywhere in the list, the head and tails would advance
        //   from either end and pass each other before we get to this
        //   case and removals would be handled in the final while loop
        //   without needing to generate the map.
        //
        // * Example below: The key at `oldTail` was removed (no longer
        //   in the `newKeyToIndexMap`), so remove that part from the
        //   DOM and advance just the `oldTail` pointer.
        //
        //         oldHead v           v oldTail
        //   oldKeys:  [0, 1, 2, 3, 4, 5, 6]
        //   newParts: [0,  ,  ,  ,  ,  , 6] <- 5 not in new map: remove
        //   newKeys:  [0, 2, 1, 4, 3, 7, 6]    5 and advance oldTail
        //         newHead ^           ^ newTail
        //
        // * Once head and tail cannot move, any mismatches are due to
        //   either new or moved items; if a new key is in the previous
        //   "old key to old index" map, move the old part to the new
        //   location, otherwise create and insert a new part. Note
        //   that when moving an old part we null its position in the
        //   oldParts array if it lies between the head and tail so we
        //   know to skip it when the pointers get there.
        //
        // * Example below: neither head nor tail match, and neither
        //   were removed; so find the `newHead` key in the
        //   `oldKeyToIndexMap`, and move that old part's DOM into the
        //   next head position (before `oldParts[oldHead]`). Last,
        //   null the part in the `oldPart` array since it was
        //   somewhere in the remaining oldParts still to be scanned
        //   (between the head and tail pointers) so that we know to
        //   skip that old part on future iterations.
        //
        //         oldHead v        v oldTail
        //   oldKeys:  [0, 1, -, 3, 4, 5, 6]
        //   newParts: [0, 2,  ,  ,  ,  , 6] <- stuck: update & move 2
        //   newKeys:  [0, 2, 1, 4, 3, 7, 6]    into place and advance
        //                                      newHead
        //         newHead ^           ^ newTail
        //
        // * Note that for moves/insertions like the one above, a part
        //   inserted at the head pointer is inserted before the
        //   current `oldParts[oldHead]`, and a part inserted at the
        //   tail pointer is inserted before `newParts[newTail+1]`. The
        //   seeming asymmetry lies in the fact that new parts are
        //   moved into place outside in, so to the right of the head
        //   pointer are old parts, and to the right of the tail
        //   pointer are new parts.
        //
        // * We always restart back from the top of the algorithm,
        //   allowing matching and simple updates in place to
        //   continue...
        //
        // * Example below: the head pointers once again match, so
        //   simply update part 1 and record it in the `newParts`
        //   array.  Last, advance both head pointers.
        //
        //         oldHead v        v oldTail
        //   oldKeys:  [0, 1, -, 3, 4, 5, 6]
        //   newParts: [0, 2, 1,  ,  ,  , 6] <- heads matched: update 1
        //   newKeys:  [0, 2, 1, 4, 3, 7, 6]    and advance both oldHead
        //                                      & newHead
        //            newHead ^        ^ newTail
        //
        // * As mentioned above, items that were moved as a result of
        //   being stuck (the final else clause in the code below) are
        //   marked with null, so we always advance old pointers over
        //   these so we're comparing the next actual old value on
        //   either end.
        //
        // * Example below: `oldHead` is null (already placed in
        //   newParts), so advance `oldHead`.
        //
        //            oldHead v     v oldTail
        //   oldKeys:  [0, 1, -, 3, 4, 5, 6] <- old head already used:
        //   newParts: [0, 2, 1,  ,  ,  , 6]    advance oldHead
        //   newKeys:  [0, 2, 1, 4, 3, 7, 6]
        //               newHead ^     ^ newTail
        //
        // * Note it's not critical to mark old parts as null when they
        //   are moved from head to tail or tail to head, since they
        //   will be outside the pointer range and never visited again.
        //
        // * Example below: Here the old tail key matches the new head
        //   key, so the part at the `oldTail` position and move its
        //   DOM to the new head position (before `oldParts[oldHead]`).
        //   Last, advance `oldTail` and `newHead` pointers.
        //
        //               oldHead v  v oldTail
        //   oldKeys:  [0, 1, -, 3, 4, 5, 6]
        //   newParts: [0, 2, 1, 4,  ,  , 6] <- old tail matches new
        //   newKeys:  [0, 2, 1, 4, 3, 7, 6]   head: update & move 4,
        //                                     advance oldTail & newHead
        //               newHead ^     ^ newTail
        //
        // * Example below: Old and new head keys match, so update the
        //   old head part in place, and advance the `oldHead` and
        //   `newHead` pointers.
        //
        //               oldHead v oldTail
        //   oldKeys:  [0, 1, -, 3, 4, 5, 6]
        //   newParts: [0, 2, 1, 4, 3,   ,6] <- heads match: update 3
        //   newKeys:  [0, 2, 1, 4, 3, 7, 6]    and advance oldHead &
        //                                      newHead
        //                  newHead ^  ^ newTail
        //
        // * Once the new or old pointers move past each other then all
        //   we have left is additions (if old list exhausted) or
        //   removals (if new list exhausted). Those are handled in the
        //   final while loops at the end.
        //
        // * Example below: `oldHead` exceeded `oldTail`, so we're done
        //   with the main loop.  Create the remaining part and insert
        //   it at the new head position, and the update is complete.
        //
        //                   (oldHead > oldTail)
        //   oldKeys:  [0, 1, -, 3, 4, 5, 6]
        //   newParts: [0, 2, 1, 4, 3, 7 ,6] <- create and insert 7
        //   newKeys:  [0, 2, 1, 4, 3, 7, 6]
        //                     newHead ^ newTail
        //
        // * Note that the order of the if/else clauses is not
        //   important to the algorithm, as long as the null checks
        //   come first (to ensure we're always working on valid old
        //   parts) and that the final else clause comes last (since
        //   that's where the expensive moves occur). The order of
        //   remaining clauses is is just a simple guess at which cases
        //   will be most common.
        //
        // * Note, we could calculate the longest
        //   increasing subsequence (LIS) of old items in new position,
        //   and only move those not in the LIS set. However that costs
        //   O(nlogn) time and adds a bit more code, and only helps
        //   make rare types of mutations require fewer moves. The
        //   above handles removes, adds, reversal, swaps, and single
        //   moves of contiguous items in linear time, in the minimum
        //   number of moves. As the number of multiple moves where LIS
        //   might help approaches a random shuffle, the LIS
        //   optimization becomes less helpful, so it seems not worth
        //   the code at this point. Could reconsider if a compelling
        //   case arises.
        while (oldHead <= oldTail && newHead <= newTail) {
            if (oldParts[oldHead] === null) {
                // `null` means old part at head has already been used
                // below; skip
                oldHead++;
            }
            else if (oldParts[oldTail] === null) {
                // `null` means old part at tail has already been used
                // below; skip
                oldTail--;
            }
            else if (oldKeys[oldHead] === newKeys[newHead]) {
                // Old head matches new head; update in place
                newParts[newHead] = (0,_directive_helpers_js__WEBPACK_IMPORTED_MODULE_2__.setChildPartValue)(oldParts[oldHead], newValues[newHead]);
                oldHead++;
                newHead++;
            }
            else if (oldKeys[oldTail] === newKeys[newTail]) {
                // Old tail matches new tail; update in place
                newParts[newTail] = (0,_directive_helpers_js__WEBPACK_IMPORTED_MODULE_2__.setChildPartValue)(oldParts[oldTail], newValues[newTail]);
                oldTail--;
                newTail--;
            }
            else if (oldKeys[oldHead] === newKeys[newTail]) {
                // Old head matches new tail; update and move to new tail
                newParts[newTail] = (0,_directive_helpers_js__WEBPACK_IMPORTED_MODULE_2__.setChildPartValue)(oldParts[oldHead], newValues[newTail]);
                (0,_directive_helpers_js__WEBPACK_IMPORTED_MODULE_2__.insertPart)(containerPart, newParts[newTail + 1], oldParts[oldHead]);
                oldHead++;
                newTail--;
            }
            else if (oldKeys[oldTail] === newKeys[newHead]) {
                // Old tail matches new head; update and move to new head
                newParts[newHead] = (0,_directive_helpers_js__WEBPACK_IMPORTED_MODULE_2__.setChildPartValue)(oldParts[oldTail], newValues[newHead]);
                (0,_directive_helpers_js__WEBPACK_IMPORTED_MODULE_2__.insertPart)(containerPart, oldParts[oldHead], oldParts[oldTail]);
                oldTail--;
                newHead++;
            }
            else {
                if (newKeyToIndexMap === undefined) {
                    // Lazily generate key-to-index maps, used for removals &
                    // moves below
                    newKeyToIndexMap = generateMap(newKeys, newHead, newTail);
                    oldKeyToIndexMap = generateMap(oldKeys, oldHead, oldTail);
                }
                if (!newKeyToIndexMap.has(oldKeys[oldHead])) {
                    // Old head is no longer in new list; remove
                    (0,_directive_helpers_js__WEBPACK_IMPORTED_MODULE_2__.removePart)(oldParts[oldHead]);
                    oldHead++;
                }
                else if (!newKeyToIndexMap.has(oldKeys[oldTail])) {
                    // Old tail is no longer in new list; remove
                    (0,_directive_helpers_js__WEBPACK_IMPORTED_MODULE_2__.removePart)(oldParts[oldTail]);
                    oldTail--;
                }
                else {
                    // Any mismatches at this point are due to additions or
                    // moves; see if we have an old part we can reuse and move
                    // into place
                    const oldIndex = oldKeyToIndexMap.get(newKeys[newHead]);
                    const oldPart = oldIndex !== undefined ? oldParts[oldIndex] : null;
                    if (oldPart === null) {
                        // No old part for this value; create a new one and
                        // insert it
                        const newPart = (0,_directive_helpers_js__WEBPACK_IMPORTED_MODULE_2__.insertPart)(containerPart, oldParts[oldHead]);
                        (0,_directive_helpers_js__WEBPACK_IMPORTED_MODULE_2__.setChildPartValue)(newPart, newValues[newHead]);
                        newParts[newHead] = newPart;
                    }
                    else {
                        // Reuse old part
                        newParts[newHead] = (0,_directive_helpers_js__WEBPACK_IMPORTED_MODULE_2__.setChildPartValue)(oldPart, newValues[newHead]);
                        (0,_directive_helpers_js__WEBPACK_IMPORTED_MODULE_2__.insertPart)(containerPart, oldParts[oldHead], oldPart);
                        // This marks the old part as having been used, so that
                        // it will be skipped in the first two checks above
                        oldParts[oldIndex] = null;
                    }
                    newHead++;
                }
            }
        }
        // Add parts for any remaining new values
        while (newHead <= newTail) {
            // For all remaining additions, we insert before last new
            // tail, since old pointers are no longer valid
            const newPart = (0,_directive_helpers_js__WEBPACK_IMPORTED_MODULE_2__.insertPart)(containerPart, newParts[newTail + 1]);
            (0,_directive_helpers_js__WEBPACK_IMPORTED_MODULE_2__.setChildPartValue)(newPart, newValues[newHead]);
            newParts[newHead++] = newPart;
        }
        // Remove any remaining unused old parts
        while (oldHead <= oldTail) {
            const oldPart = oldParts[oldHead++];
            if (oldPart !== null) {
                (0,_directive_helpers_js__WEBPACK_IMPORTED_MODULE_2__.removePart)(oldPart);
            }
        }
        // Save order of new parts for next round
        this._itemKeys = newKeys;
        // Directly set part value, bypassing it's dirty-checking
        (0,_directive_helpers_js__WEBPACK_IMPORTED_MODULE_2__.setCommittedValue)(containerPart, newParts);
        return _lit_html_js__WEBPACK_IMPORTED_MODULE_0__.noChange;
    }
}
/**
 * A directive that repeats a series of values (usually `TemplateResults`)
 * generated from an iterable, and updates those items efficiently when the
 * iterable changes based on user-provided `keys` associated with each item.
 *
 * Note that if a `keyFn` is provided, strict key-to-DOM mapping is maintained,
 * meaning previous DOM for a given key is moved into the new position if
 * needed, and DOM will never be reused with values for different keys (new DOM
 * will always be created for new keys). This is generally the most efficient
 * way to use `repeat` since it performs minimum unnecessary work for insertions
 * and removals.
 *
 * The `keyFn` takes two parameters, the item and its index, and returns a unique key value.
 *
 * ```js
 * html`
 *   <ol>
 *     ${repeat(this.items, (item) => item.id, (item, index) => {
 *       return html`<li>${index}: ${item.name}</li>`;
 *     })}
 *   </ol>
 * `
 * ```
 *
 * **Important**: If providing a `keyFn`, keys *must* be unique for all items in a
 * given call to `repeat`. The behavior when two or more items have the same key
 * is undefined.
 *
 * If no `keyFn` is provided, this directive will perform similar to mapping
 * items to values, and DOM will be reused against potentially different items.
 */
const repeat = (0,_directive_js__WEBPACK_IMPORTED_MODULE_1__.directive)(RepeatDirective);
//# sourceMappingURL=repeat.js.map

/***/ }),

/***/ "./node_modules/lit-html/development/directives/style-map.js":
/*!*******************************************************************!*\
  !*** ./node_modules/lit-html/development/directives/style-map.js ***!
  \*******************************************************************/
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   styleMap: () => (/* binding */ styleMap)
/* harmony export */ });
/* harmony import */ var _lit_html_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ../lit-html.js */ "./node_modules/lit-html/development/lit-html.js");
/* harmony import */ var _directive_js__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ../directive.js */ "./node_modules/lit-html/development/directive.js");
/**
 * @license
 * Copyright 2018 Google LLC
 * SPDX-License-Identifier: BSD-3-Clause
 */


const important = 'important';
// The leading space is important
const importantFlag = ' !' + important;
// How many characters to remove from a value, as a negative number
const flagTrim = 0 - importantFlag.length;
class StyleMapDirective extends _directive_js__WEBPACK_IMPORTED_MODULE_1__.Directive {
    constructor(partInfo) {
        var _a;
        super(partInfo);
        if (partInfo.type !== _directive_js__WEBPACK_IMPORTED_MODULE_1__.PartType.ATTRIBUTE ||
            partInfo.name !== 'style' ||
            ((_a = partInfo.strings) === null || _a === void 0 ? void 0 : _a.length) > 2) {
            throw new Error('The `styleMap` directive must be used in the `style` attribute ' +
                'and must be the only part in the attribute.');
        }
    }
    render(styleInfo) {
        return Object.keys(styleInfo).reduce((style, prop) => {
            const value = styleInfo[prop];
            if (value == null) {
                return style;
            }
            // Convert property names from camel-case to dash-case, i.e.:
            //  `backgroundColor` -> `background-color`
            // Vendor-prefixed names need an extra `-` appended to front:
            //  `webkitAppearance` -> `-webkit-appearance`
            // Exception is any property name containing a dash, including
            // custom properties; we assume these are already dash-cased i.e.:
            //  `--my-button-color` --> `--my-button-color`
            prop = prop.includes('-')
                ? prop
                : prop
                    .replace(/(?:^(webkit|moz|ms|o)|)(?=[A-Z])/g, '-$&')
                    .toLowerCase();
            return style + `${prop}:${value};`;
        }, '');
    }
    update(part, [styleInfo]) {
        const { style } = part.element;
        if (this._previousStyleProperties === undefined) {
            this._previousStyleProperties = new Set();
            for (const name in styleInfo) {
                this._previousStyleProperties.add(name);
            }
            return this.render(styleInfo);
        }
        // Remove old properties that no longer exist in styleInfo
        // We use forEach() instead of for-of so that re don't require down-level
        // iteration.
        this._previousStyleProperties.forEach((name) => {
            // If the name isn't in styleInfo or it's null/undefined
            if (styleInfo[name] == null) {
                this._previousStyleProperties.delete(name);
                if (name.includes('-')) {
                    style.removeProperty(name);
                }
                else {
                    // Note reset using empty string (vs null) as IE11 does not always
                    // reset via null (https://developer.mozilla.org/en-US/docs/Web/API/ElementCSSInlineStyle/style#setting_styles)
                    // eslint-disable-next-line @typescript-eslint/no-explicit-any
                    style[name] = '';
                }
            }
        });
        // Add or update properties
        for (const name in styleInfo) {
            const value = styleInfo[name];
            if (value != null) {
                this._previousStyleProperties.add(name);
                const isImportant = typeof value === 'string' && value.endsWith(importantFlag);
                if (name.includes('-') || isImportant) {
                    style.setProperty(name, isImportant
                        ? value.slice(0, flagTrim)
                        : value, isImportant ? important : '');
                }
                else {
                    // eslint-disable-next-line @typescript-eslint/no-explicit-any
                    style[name] = value;
                }
            }
        }
        return _lit_html_js__WEBPACK_IMPORTED_MODULE_0__.noChange;
    }
}
/**
 * A directive that applies CSS properties to an element.
 *
 * `styleMap` can only be used in the `style` attribute and must be the only
 * expression in the attribute. It takes the property names in the
 * {@link StyleInfo styleInfo} object and adds the properties to the inline
 * style of the element.
 *
 * Property names with dashes (`-`) are assumed to be valid CSS
 * property names and set on the element's style object using `setProperty()`.
 * Names without dashes are assumed to be camelCased JavaScript property names
 * and set on the element's style object using property assignment, allowing the
 * style object to translate JavaScript-style names to CSS property names.
 *
 * For example `styleMap({backgroundColor: 'red', 'border-top': '5px', '--size':
 * '0'})` sets the `background-color`, `border-top` and `--size` properties.
 *
 * @param styleInfo
 * @see {@link https://lit.dev/docs/templates/directives/#stylemap styleMap code samples on Lit.dev}
 */
const styleMap = (0,_directive_js__WEBPACK_IMPORTED_MODULE_1__.directive)(StyleMapDirective);
//# sourceMappingURL=style-map.js.map

/***/ }),

/***/ "./node_modules/lit-html/development/is-server.js":
/*!********************************************************!*\
  !*** ./node_modules/lit-html/development/is-server.js ***!
  \********************************************************/
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   isServer: () => (/* binding */ isServer)
/* harmony export */ });
/**
 * @license
 * Copyright 2022 Google LLC
 * SPDX-License-Identifier: BSD-3-Clause
 */
/**
 * @fileoverview
 *
 * This file exports a boolean const whose value will depend on what environment
 * the module is being imported from.
 */
const NODE_MODE = false;
/**
 * A boolean that will be `true` in server environments like Node, and `false`
 * in browser environments. Note that your server environment or toolchain must
 * support the `"node"` export condition for this to be `true`.
 *
 * This can be used when authoring components to change behavior based on
 * whether or not the component is executing in an SSR context.
 */
const isServer = NODE_MODE;
//# sourceMappingURL=is-server.js.map

/***/ }),

/***/ "./node_modules/lit-html/development/lit-html.js":
/*!*******************************************************!*\
  !*** ./node_modules/lit-html/development/lit-html.js ***!
  \*******************************************************/
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   _$LH: () => (/* binding */ _$LH),
/* harmony export */   html: () => (/* binding */ html),
/* harmony export */   noChange: () => (/* binding */ noChange),
/* harmony export */   nothing: () => (/* binding */ nothing),
/* harmony export */   render: () => (/* binding */ render),
/* harmony export */   svg: () => (/* binding */ svg)
/* harmony export */ });
/**
 * @license
 * Copyright 2017 Google LLC
 * SPDX-License-Identifier: BSD-3-Clause
 */
var _a, _b, _c, _d;
const DEV_MODE = true;
const ENABLE_EXTRA_SECURITY_HOOKS = true;
const ENABLE_SHADYDOM_NOPATCH = true;
const NODE_MODE = false;
// Use window for browser builds because IE11 doesn't have globalThis.
const global = NODE_MODE ? globalThis : window;
/**
 * Useful for visualizing and logging insights into what the Lit template system is doing.
 *
 * Compiled out of prod mode builds.
 */
const debugLogEvent = DEV_MODE
    ? (event) => {
        const shouldEmit = global
            .emitLitDebugLogEvents;
        if (!shouldEmit) {
            return;
        }
        global.dispatchEvent(new CustomEvent('lit-debug', {
            detail: event,
        }));
    }
    : undefined;
// Used for connecting beginRender and endRender events when there are nested
// renders when errors are thrown preventing an endRender event from being
// called.
let debugLogRenderId = 0;
let issueWarning;
if (DEV_MODE) {
    (_a = global.litIssuedWarnings) !== null && _a !== void 0 ? _a : (global.litIssuedWarnings = new Set());
    // Issue a warning, if we haven't already.
    issueWarning = (code, warning) => {
        warning += code
            ? ` See https://lit.dev/msg/${code} for more information.`
            : '';
        if (!global.litIssuedWarnings.has(warning)) {
            console.warn(warning);
            global.litIssuedWarnings.add(warning);
        }
    };
    issueWarning('dev-mode', `Lit is in dev mode. Not recommended for production!`);
}
const wrap = ENABLE_SHADYDOM_NOPATCH &&
    ((_b = global.ShadyDOM) === null || _b === void 0 ? void 0 : _b.inUse) &&
    ((_c = global.ShadyDOM) === null || _c === void 0 ? void 0 : _c.noPatch) === true
    ? global.ShadyDOM.wrap
    : (node) => node;
const trustedTypes = global.trustedTypes;
/**
 * Our TrustedTypePolicy for HTML which is declared using the html template
 * tag function.
 *
 * That HTML is a developer-authored constant, and is parsed with innerHTML
 * before any untrusted expressions have been mixed in. Therefor it is
 * considered safe by construction.
 */
const policy = trustedTypes
    ? trustedTypes.createPolicy('lit-html', {
        createHTML: (s) => s,
    })
    : undefined;
const identityFunction = (value) => value;
const noopSanitizer = (_node, _name, _type) => identityFunction;
/** Sets the global sanitizer factory. */
const setSanitizer = (newSanitizer) => {
    if (!ENABLE_EXTRA_SECURITY_HOOKS) {
        return;
    }
    if (sanitizerFactoryInternal !== noopSanitizer) {
        throw new Error(`Attempted to overwrite existing lit-html security policy.` +
            ` setSanitizeDOMValueFactory should be called at most once.`);
    }
    sanitizerFactoryInternal = newSanitizer;
};
/**
 * Only used in internal tests, not a part of the public API.
 */
const _testOnlyClearSanitizerFactoryDoNotCallOrElse = () => {
    sanitizerFactoryInternal = noopSanitizer;
};
const createSanitizer = (node, name, type) => {
    return sanitizerFactoryInternal(node, name, type);
};
// Added to an attribute name to mark the attribute as bound so we can find
// it easily.
const boundAttributeSuffix = '$lit$';
// This marker is used in many syntactic positions in HTML, so it must be
// a valid element name and attribute name. We don't support dynamic names (yet)
// but this at least ensures that the parse tree is closer to the template
// intention.
const marker = `lit$${String(Math.random()).slice(9)}$`;
// String used to tell if a comment is a marker comment
const markerMatch = '?' + marker;
// Text used to insert a comment marker node. We use processing instruction
// syntax because it's slightly smaller, but parses as a comment node.
const nodeMarker = `<${markerMatch}>`;
const d = NODE_MODE && global.document === undefined
    ? {
        createTreeWalker() {
            return {};
        },
    }
    : document;
// Creates a dynamic marker. We never have to search for these in the DOM.
const createMarker = () => d.createComment('');
const isPrimitive = (value) => value === null || (typeof value != 'object' && typeof value != 'function');
const isArray = Array.isArray;
const isIterable = (value) => isArray(value) ||
    // eslint-disable-next-line @typescript-eslint/no-explicit-any
    typeof (value === null || value === void 0 ? void 0 : value[Symbol.iterator]) === 'function';
const SPACE_CHAR = `[ \t\n\f\r]`;
const ATTR_VALUE_CHAR = `[^ \t\n\f\r"'\`<>=]`;
const NAME_CHAR = `[^\\s"'>=/]`;
// These regexes represent the five parsing states that we care about in the
// Template's HTML scanner. They match the *end* of the state they're named
// after.
// Depending on the match, we transition to a new state. If there's no match,
// we stay in the same state.
// Note that the regexes are stateful. We utilize lastIndex and sync it
// across the multiple regexes used. In addition to the five regexes below
// we also dynamically create a regex to find the matching end tags for raw
// text elements.
/**
 * End of text is: `<` followed by:
 *   (comment start) or (tag) or (dynamic tag binding)
 */
const textEndRegex = /<(?:(!--|\/[^a-zA-Z])|(\/?[a-zA-Z][^>\s]*)|(\/?$))/g;
const COMMENT_START = 1;
const TAG_NAME = 2;
const DYNAMIC_TAG_NAME = 3;
const commentEndRegex = /-->/g;
/**
 * Comments not started with <!--, like </{, can be ended by a single `>`
 */
const comment2EndRegex = />/g;
/**
 * The tagEnd regex matches the end of the "inside an opening" tag syntax
 * position. It either matches a `>`, an attribute-like sequence, or the end
 * of the string after a space (attribute-name position ending).
 *
 * See attributes in the HTML spec:
 * https://www.w3.org/TR/html5/syntax.html#elements-attributes
 *
 * " \t\n\f\r" are HTML space characters:
 * https://infra.spec.whatwg.org/#ascii-whitespace
 *
 * So an attribute is:
 *  * The name: any character except a whitespace character, ("), ('), ">",
 *    "=", or "/". Note: this is different from the HTML spec which also excludes control characters.
 *  * Followed by zero or more space characters
 *  * Followed by "="
 *  * Followed by zero or more space characters
 *  * Followed by:
 *    * Any character except space, ('), ("), "<", ">", "=", (`), or
 *    * (") then any non-("), or
 *    * (') then any non-(')
 */
const tagEndRegex = new RegExp(`>|${SPACE_CHAR}(?:(${NAME_CHAR}+)(${SPACE_CHAR}*=${SPACE_CHAR}*(?:${ATTR_VALUE_CHAR}|("|')|))|$)`, 'g');
const ENTIRE_MATCH = 0;
const ATTRIBUTE_NAME = 1;
const SPACES_AND_EQUALS = 2;
const QUOTE_CHAR = 3;
const singleQuoteAttrEndRegex = /'/g;
const doubleQuoteAttrEndRegex = /"/g;
/**
 * Matches the raw text elements.
 *
 * Comments are not parsed within raw text elements, so we need to search their
 * text content for marker strings.
 */
const rawTextElement = /^(?:script|style|textarea|title)$/i;
/** TemplateResult types */
const HTML_RESULT = 1;
const SVG_RESULT = 2;
// TemplatePart types
// IMPORTANT: these must match the values in PartType
const ATTRIBUTE_PART = 1;
const CHILD_PART = 2;
const PROPERTY_PART = 3;
const BOOLEAN_ATTRIBUTE_PART = 4;
const EVENT_PART = 5;
const ELEMENT_PART = 6;
const COMMENT_PART = 7;
/**
 * Generates a template literal tag function that returns a TemplateResult with
 * the given result type.
 */
const tag = (type) => (strings, ...values) => {
    // Warn against templates octal escape sequences
    // We do this here rather than in render so that the warning is closer to the
    // template definition.
    if (DEV_MODE && strings.some((s) => s === undefined)) {
        console.warn('Some template strings are undefined.\n' +
            'This is probably caused by illegal octal escape sequences.');
    }
    return {
        // This property needs to remain unminified.
        ['_$litType$']: type,
        strings,
        values,
    };
};
/**
 * Interprets a template literal as an HTML template that can efficiently
 * render to and update a container.
 *
 * ```ts
 * const header = (title: string) => html`<h1>${title}</h1>`;
 * ```
 *
 * The `html` tag returns a description of the DOM to render as a value. It is
 * lazy, meaning no work is done until the template is rendered. When rendering,
 * if a template comes from the same expression as a previously rendered result,
 * it's efficiently updated instead of replaced.
 */
const html = tag(HTML_RESULT);
/**
 * Interprets a template literal as an SVG fragment that can efficiently
 * render to and update a container.
 *
 * ```ts
 * const rect = svg`<rect width="10" height="10"></rect>`;
 *
 * const myImage = html`
 *   <svg viewBox="0 0 10 10" xmlns="http://www.w3.org/2000/svg">
 *     ${rect}
 *   </svg>`;
 * ```
 *
 * The `svg` *tag function* should only be used for SVG fragments, or elements
 * that would be contained **inside** an `<svg>` HTML element. A common error is
 * placing an `<svg>` *element* in a template tagged with the `svg` tag
 * function. The `<svg>` element is an HTML element and should be used within a
 * template tagged with the {@linkcode html} tag function.
 *
 * In LitElement usage, it's invalid to return an SVG fragment from the
 * `render()` method, as the SVG fragment will be contained within the element's
 * shadow root and thus cannot be used within an `<svg>` HTML element.
 */
const svg = tag(SVG_RESULT);
/**
 * A sentinel value that signals that a value was handled by a directive and
 * should not be written to the DOM.
 */
const noChange = Symbol.for('lit-noChange');
/**
 * A sentinel value that signals a ChildPart to fully clear its content.
 *
 * ```ts
 * const button = html`${
 *  user.isAdmin
 *    ? html`<button>DELETE</button>`
 *    : nothing
 * }`;
 * ```
 *
 * Prefer using `nothing` over other falsy values as it provides a consistent
 * behavior between various expression binding contexts.
 *
 * In child expressions, `undefined`, `null`, `''`, and `nothing` all behave the
 * same and render no nodes. In attribute expressions, `nothing` _removes_ the
 * attribute, while `undefined` and `null` will render an empty string. In
 * property expressions `nothing` becomes `undefined`.
 */
const nothing = Symbol.for('lit-nothing');
/**
 * The cache of prepared templates, keyed by the tagged TemplateStringsArray
 * and _not_ accounting for the specific template tag used. This means that
 * template tags cannot be dynamic - the must statically be one of html, svg,
 * or attr. This restriction simplifies the cache lookup, which is on the hot
 * path for rendering.
 */
const templateCache = new WeakMap();
const walker = d.createTreeWalker(d, 129 /* NodeFilter.SHOW_{ELEMENT|COMMENT} */, null, false);
let sanitizerFactoryInternal = noopSanitizer;
function trustFromTemplateString(tsa, stringFromTSA) {
    // A security check to prevent spoofing of Lit template results.
    // In the future, we may be able to replace this with Array.isTemplateObject,
    // though we might need to make that check inside of the html and svg
    // functions, because precompiled templates don't come in as
    // TemplateStringArray objects.
    if (!Array.isArray(tsa) || !tsa.hasOwnProperty('raw')) {
        let message = 'invalid template strings array';
        if (DEV_MODE) {
            message = `
          Internal Error: expected template strings to be an array
          with a 'raw' field. Faking a template strings array by
          calling html or svg like an ordinary function is effectively
          the same as calling unsafeHtml and can lead to major security
          issues, e.g. opening your code up to XSS attacks.
          If you're using the html or svg tagged template functions normally
          and still seeing this error, please file a bug at
          https://github.com/lit/lit/issues/new?template=bug_report.md
          and include information about your build tooling, if any.
        `
                .trim()
                .replace(/\n */g, '\n');
        }
        throw new Error(message);
    }
    return policy !== undefined
        ? policy.createHTML(stringFromTSA)
        : stringFromTSA;
}
/**
 * Returns an HTML string for the given TemplateStringsArray and result type
 * (HTML or SVG), along with the case-sensitive bound attribute names in
 * template order. The HTML contains comment markers denoting the `ChildPart`s
 * and suffixes on bound attributes denoting the `AttributeParts`.
 *
 * @param strings template strings array
 * @param type HTML or SVG
 * @return Array containing `[html, attrNames]` (array returned for terseness,
 *     to avoid object fields since this code is shared with non-minified SSR
 *     code)
 */
const getTemplateHtml = (strings, type) => {
    // Insert makers into the template HTML to represent the position of
    // bindings. The following code scans the template strings to determine the
    // syntactic position of the bindings. They can be in text position, where
    // we insert an HTML comment, attribute value position, where we insert a
    // sentinel string and re-write the attribute name, or inside a tag where
    // we insert the sentinel string.
    const l = strings.length - 1;
    // Stores the case-sensitive bound attribute names in the order of their
    // parts. ElementParts are also reflected in this array as undefined
    // rather than a string, to disambiguate from attribute bindings.
    const attrNames = [];
    let html = type === SVG_RESULT ? '<svg>' : '';
    // When we're inside a raw text tag (not it's text content), the regex
    // will still be tagRegex so we can find attributes, but will switch to
    // this regex when the tag ends.
    let rawTextEndRegex;
    // The current parsing state, represented as a reference to one of the
    // regexes
    let regex = textEndRegex;
    for (let i = 0; i < l; i++) {
        const s = strings[i];
        // The index of the end of the last attribute name. When this is
        // positive at end of a string, it means we're in an attribute value
        // position and need to rewrite the attribute name.
        // We also use a special value of -2 to indicate that we encountered
        // the end of a string in attribute name position.
        let attrNameEndIndex = -1;
        let attrName;
        let lastIndex = 0;
        let match;
        // The conditions in this loop handle the current parse state, and the
        // assignments to the `regex` variable are the state transitions.
        while (lastIndex < s.length) {
            // Make sure we start searching from where we previously left off
            regex.lastIndex = lastIndex;
            match = regex.exec(s);
            if (match === null) {
                break;
            }
            lastIndex = regex.lastIndex;
            if (regex === textEndRegex) {
                if (match[COMMENT_START] === '!--') {
                    regex = commentEndRegex;
                }
                else if (match[COMMENT_START] !== undefined) {
                    // We started a weird comment, like </{
                    regex = comment2EndRegex;
                }
                else if (match[TAG_NAME] !== undefined) {
                    if (rawTextElement.test(match[TAG_NAME])) {
                        // Record if we encounter a raw-text element. We'll switch to
                        // this regex at the end of the tag.
                        rawTextEndRegex = new RegExp(`</${match[TAG_NAME]}`, 'g');
                    }
                    regex = tagEndRegex;
                }
                else if (match[DYNAMIC_TAG_NAME] !== undefined) {
                    if (DEV_MODE) {
                        throw new Error('Bindings in tag names are not supported. Please use static templates instead. ' +
                            'See https://lit.dev/docs/templates/expressions/#static-expressions');
                    }
                    regex = tagEndRegex;
                }
            }
            else if (regex === tagEndRegex) {
                if (match[ENTIRE_MATCH] === '>') {
                    // End of a tag. If we had started a raw-text element, use that
                    // regex
                    regex = rawTextEndRegex !== null && rawTextEndRegex !== void 0 ? rawTextEndRegex : textEndRegex;
                    // We may be ending an unquoted attribute value, so make sure we
                    // clear any pending attrNameEndIndex
                    attrNameEndIndex = -1;
                }
                else if (match[ATTRIBUTE_NAME] === undefined) {
                    // Attribute name position
                    attrNameEndIndex = -2;
                }
                else {
                    attrNameEndIndex = regex.lastIndex - match[SPACES_AND_EQUALS].length;
                    attrName = match[ATTRIBUTE_NAME];
                    regex =
                        match[QUOTE_CHAR] === undefined
                            ? tagEndRegex
                            : match[QUOTE_CHAR] === '"'
                                ? doubleQuoteAttrEndRegex
                                : singleQuoteAttrEndRegex;
                }
            }
            else if (regex === doubleQuoteAttrEndRegex ||
                regex === singleQuoteAttrEndRegex) {
                regex = tagEndRegex;
            }
            else if (regex === commentEndRegex || regex === comment2EndRegex) {
                regex = textEndRegex;
            }
            else {
                // Not one of the five state regexes, so it must be the dynamically
                // created raw text regex and we're at the close of that element.
                regex = tagEndRegex;
                rawTextEndRegex = undefined;
            }
        }
        if (DEV_MODE) {
            // If we have a attrNameEndIndex, which indicates that we should
            // rewrite the attribute name, assert that we're in a valid attribute
            // position - either in a tag, or a quoted attribute value.
            console.assert(attrNameEndIndex === -1 ||
                regex === tagEndRegex ||
                regex === singleQuoteAttrEndRegex ||
                regex === doubleQuoteAttrEndRegex, 'unexpected parse state B');
        }
        // We have four cases:
        //  1. We're in text position, and not in a raw text element
        //     (regex === textEndRegex): insert a comment marker.
        //  2. We have a non-negative attrNameEndIndex which means we need to
        //     rewrite the attribute name to add a bound attribute suffix.
        //  3. We're at the non-first binding in a multi-binding attribute, use a
        //     plain marker.
        //  4. We're somewhere else inside the tag. If we're in attribute name
        //     position (attrNameEndIndex === -2), add a sequential suffix to
        //     generate a unique attribute name.
        // Detect a binding next to self-closing tag end and insert a space to
        // separate the marker from the tag end:
        const end = regex === tagEndRegex && strings[i + 1].startsWith('/>') ? ' ' : '';
        html +=
            regex === textEndRegex
                ? s + nodeMarker
                : attrNameEndIndex >= 0
                    ? (attrNames.push(attrName),
                        s.slice(0, attrNameEndIndex) +
                            boundAttributeSuffix +
                            s.slice(attrNameEndIndex)) +
                        marker +
                        end
                    : s +
                        marker +
                        (attrNameEndIndex === -2 ? (attrNames.push(undefined), i) : end);
    }
    const htmlResult = html + (strings[l] || '<?>') + (type === SVG_RESULT ? '</svg>' : '');
    // Returned as an array for terseness
    return [trustFromTemplateString(strings, htmlResult), attrNames];
};
class Template {
    constructor(
    // This property needs to remain unminified.
    { strings, ['_$litType$']: type }, options) {
        this.parts = [];
        let node;
        let nodeIndex = 0;
        let attrNameIndex = 0;
        const partCount = strings.length - 1;
        const parts = this.parts;
        // Create template element
        const [html, attrNames] = getTemplateHtml(strings, type);
        this.el = Template.createElement(html, options);
        walker.currentNode = this.el.content;
        // Reparent SVG nodes into template root
        if (type === SVG_RESULT) {
            const content = this.el.content;
            const svgElement = content.firstChild;
            svgElement.remove();
            content.append(...svgElement.childNodes);
        }
        // Walk the template to find binding markers and create TemplateParts
        while ((node = walker.nextNode()) !== null && parts.length < partCount) {
            if (node.nodeType === 1) {
                if (DEV_MODE) {
                    const tag = node.localName;
                    // Warn if `textarea` includes an expression and throw if `template`
                    // does since these are not supported. We do this by checking
                    // innerHTML for anything that looks like a marker. This catches
                    // cases like bindings in textarea there markers turn into text nodes.
                    if (/^(?:textarea|template)$/i.test(tag) &&
                        node.innerHTML.includes(marker)) {
                        const m = `Expressions are not supported inside \`${tag}\` ` +
                            `elements. See https://lit.dev/msg/expression-in-${tag} for more ` +
                            `information.`;
                        if (tag === 'template') {
                            throw new Error(m);
                        }
                        else
                            issueWarning('', m);
                    }
                }
                // TODO (justinfagnani): for attempted dynamic tag names, we don't
                // increment the bindingIndex, and it'll be off by 1 in the element
                // and off by two after it.
                if (node.hasAttributes()) {
                    // We defer removing bound attributes because on IE we might not be
                    // iterating attributes in their template order, and would sometimes
                    // remove an attribute that we still need to create a part for.
                    const attrsToRemove = [];
                    for (const name of node.getAttributeNames()) {
                        // `name` is the name of the attribute we're iterating over, but not
                        // _necessarily_ the name of the attribute we will create a part
                        // for. They can be different in browsers that don't iterate on
                        // attributes in source order. In that case the attrNames array
                        // contains the attribute name we'll process next. We only need the
                        // attribute name here to know if we should process a bound attribute
                        // on this element.
                        if (name.endsWith(boundAttributeSuffix) ||
                            name.startsWith(marker)) {
                            const realName = attrNames[attrNameIndex++];
                            attrsToRemove.push(name);
                            if (realName !== undefined) {
                                // Lowercase for case-sensitive SVG attributes like viewBox
                                const value = node.getAttribute(realName.toLowerCase() + boundAttributeSuffix);
                                const statics = value.split(marker);
                                const m = /([.?@])?(.*)/.exec(realName);
                                parts.push({
                                    type: ATTRIBUTE_PART,
                                    index: nodeIndex,
                                    name: m[2],
                                    strings: statics,
                                    ctor: m[1] === '.'
                                        ? PropertyPart
                                        : m[1] === '?'
                                            ? BooleanAttributePart
                                            : m[1] === '@'
                                                ? EventPart
                                                : AttributePart,
                                });
                            }
                            else {
                                parts.push({
                                    type: ELEMENT_PART,
                                    index: nodeIndex,
                                });
                            }
                        }
                    }
                    for (const name of attrsToRemove) {
                        node.removeAttribute(name);
                    }
                }
                // TODO (justinfagnani): benchmark the regex against testing for each
                // of the 3 raw text element names.
                if (rawTextElement.test(node.tagName)) {
                    // For raw text elements we need to split the text content on
                    // markers, create a Text node for each segment, and create
                    // a TemplatePart for each marker.
                    const strings = node.textContent.split(marker);
                    const lastIndex = strings.length - 1;
                    if (lastIndex > 0) {
                        node.textContent = trustedTypes
                            ? trustedTypes.emptyScript
                            : '';
                        // Generate a new text node for each literal section
                        // These nodes are also used as the markers for node parts
                        // We can't use empty text nodes as markers because they're
                        // normalized when cloning in IE (could simplify when
                        // IE is no longer supported)
                        for (let i = 0; i < lastIndex; i++) {
                            node.append(strings[i], createMarker());
                            // Walk past the marker node we just added
                            walker.nextNode();
                            parts.push({ type: CHILD_PART, index: ++nodeIndex });
                        }
                        // Note because this marker is added after the walker's current
                        // node, it will be walked to in the outer loop (and ignored), so
                        // we don't need to adjust nodeIndex here
                        node.append(strings[lastIndex], createMarker());
                    }
                }
            }
            else if (node.nodeType === 8) {
                const data = node.data;
                if (data === markerMatch) {
                    parts.push({ type: CHILD_PART, index: nodeIndex });
                }
                else {
                    let i = -1;
                    while ((i = node.data.indexOf(marker, i + 1)) !== -1) {
                        // Comment node has a binding marker inside, make an inactive part
                        // The binding won't work, but subsequent bindings will
                        parts.push({ type: COMMENT_PART, index: nodeIndex });
                        // Move to the end of the match
                        i += marker.length - 1;
                    }
                }
            }
            nodeIndex++;
        }
        // We could set walker.currentNode to another node here to prevent a memory
        // leak, but every time we prepare a template, we immediately render it
        // and re-use the walker in new TemplateInstance._clone().
        debugLogEvent === null || debugLogEvent === void 0 ? void 0 : debugLogEvent({
            kind: 'template prep',
            template: this,
            clonableTemplate: this.el,
            parts: this.parts,
            strings,
        });
    }
    // Overridden via `litHtmlPolyfillSupport` to provide platform support.
    /** @nocollapse */
    static createElement(html, _options) {
        const el = d.createElement('template');
        el.innerHTML = html;
        return el;
    }
}
function resolveDirective(part, value, parent = part, attributeIndex) {
    var _a, _b, _c;
    var _d;
    // Bail early if the value is explicitly noChange. Note, this means any
    // nested directive is still attached and is not run.
    if (value === noChange) {
        return value;
    }
    let currentDirective = attributeIndex !== undefined
        ? (_a = parent.__directives) === null || _a === void 0 ? void 0 : _a[attributeIndex]
        : parent.__directive;
    const nextDirectiveConstructor = isPrimitive(value)
        ? undefined
        : // This property needs to remain unminified.
            value['_$litDirective$'];
    if ((currentDirective === null || currentDirective === void 0 ? void 0 : currentDirective.constructor) !== nextDirectiveConstructor) {
        // This property needs to remain unminified.
        (_b = currentDirective === null || currentDirective === void 0 ? void 0 : currentDirective['_$notifyDirectiveConnectionChanged']) === null || _b === void 0 ? void 0 : _b.call(currentDirective, false);
        if (nextDirectiveConstructor === undefined) {
            currentDirective = undefined;
        }
        else {
            currentDirective = new nextDirectiveConstructor(part);
            currentDirective._$initialize(part, parent, attributeIndex);
        }
        if (attributeIndex !== undefined) {
            ((_c = (_d = parent).__directives) !== null && _c !== void 0 ? _c : (_d.__directives = []))[attributeIndex] =
                currentDirective;
        }
        else {
            parent.__directive = currentDirective;
        }
    }
    if (currentDirective !== undefined) {
        value = resolveDirective(part, currentDirective._$resolve(part, value.values), currentDirective, attributeIndex);
    }
    return value;
}
/**
 * An updateable instance of a Template. Holds references to the Parts used to
 * update the template instance.
 */
class TemplateInstance {
    constructor(template, parent) {
        this._$parts = [];
        /** @internal */
        this._$disconnectableChildren = undefined;
        this._$template = template;
        this._$parent = parent;
    }
    // Called by ChildPart parentNode getter
    get parentNode() {
        return this._$parent.parentNode;
    }
    // See comment in Disconnectable interface for why this is a getter
    get _$isConnected() {
        return this._$parent._$isConnected;
    }
    // This method is separate from the constructor because we need to return a
    // DocumentFragment and we don't want to hold onto it with an instance field.
    _clone(options) {
        var _a;
        const { el: { content }, parts: parts, } = this._$template;
        const fragment = ((_a = options === null || options === void 0 ? void 0 : options.creationScope) !== null && _a !== void 0 ? _a : d).importNode(content, true);
        walker.currentNode = fragment;
        let node = walker.nextNode();
        let nodeIndex = 0;
        let partIndex = 0;
        let templatePart = parts[0];
        while (templatePart !== undefined) {
            if (nodeIndex === templatePart.index) {
                let part;
                if (templatePart.type === CHILD_PART) {
                    part = new ChildPart(node, node.nextSibling, this, options);
                }
                else if (templatePart.type === ATTRIBUTE_PART) {
                    part = new templatePart.ctor(node, templatePart.name, templatePart.strings, this, options);
                }
                else if (templatePart.type === ELEMENT_PART) {
                    part = new ElementPart(node, this, options);
                }
                this._$parts.push(part);
                templatePart = parts[++partIndex];
            }
            if (nodeIndex !== (templatePart === null || templatePart === void 0 ? void 0 : templatePart.index)) {
                node = walker.nextNode();
                nodeIndex++;
            }
        }
        // We need to set the currentNode away from the cloned tree so that we
        // don't hold onto the tree even if the tree is detached and should be
        // freed.
        walker.currentNode = d;
        return fragment;
    }
    _update(values) {
        let i = 0;
        for (const part of this._$parts) {
            if (part !== undefined) {
                debugLogEvent === null || debugLogEvent === void 0 ? void 0 : debugLogEvent({
                    kind: 'set part',
                    part,
                    value: values[i],
                    valueIndex: i,
                    values,
                    templateInstance: this,
                });
                if (part.strings !== undefined) {
                    part._$setValue(values, part, i);
                    // The number of values the part consumes is part.strings.length - 1
                    // since values are in between template spans. We increment i by 1
                    // later in the loop, so increment it by part.strings.length - 2 here
                    i += part.strings.length - 2;
                }
                else {
                    part._$setValue(values[i]);
                }
            }
            i++;
        }
    }
}
class ChildPart {
    constructor(startNode, endNode, parent, options) {
        var _a;
        this.type = CHILD_PART;
        this._$committedValue = nothing;
        // The following fields will be patched onto ChildParts when required by
        // AsyncDirective
        /** @internal */
        this._$disconnectableChildren = undefined;
        this._$startNode = startNode;
        this._$endNode = endNode;
        this._$parent = parent;
        this.options = options;
        // Note __isConnected is only ever accessed on RootParts (i.e. when there is
        // no _$parent); the value on a non-root-part is "don't care", but checking
        // for parent would be more code
        this.__isConnected = (_a = options === null || options === void 0 ? void 0 : options.isConnected) !== null && _a !== void 0 ? _a : true;
        if (ENABLE_EXTRA_SECURITY_HOOKS) {
            // Explicitly initialize for consistent class shape.
            this._textSanitizer = undefined;
        }
    }
    // See comment in Disconnectable interface for why this is a getter
    get _$isConnected() {
        var _a, _b;
        // ChildParts that are not at the root should always be created with a
        // parent; only RootChildNode's won't, so they return the local isConnected
        // state
        return (_b = (_a = this._$parent) === null || _a === void 0 ? void 0 : _a._$isConnected) !== null && _b !== void 0 ? _b : this.__isConnected;
    }
    /**
     * The parent node into which the part renders its content.
     *
     * A ChildPart's content consists of a range of adjacent child nodes of
     * `.parentNode`, possibly bordered by 'marker nodes' (`.startNode` and
     * `.endNode`).
     *
     * - If both `.startNode` and `.endNode` are non-null, then the part's content
     * consists of all siblings between `.startNode` and `.endNode`, exclusively.
     *
     * - If `.startNode` is non-null but `.endNode` is null, then the part's
     * content consists of all siblings following `.startNode`, up to and
     * including the last child of `.parentNode`. If `.endNode` is non-null, then
     * `.startNode` will always be non-null.
     *
     * - If both `.endNode` and `.startNode` are null, then the part's content
     * consists of all child nodes of `.parentNode`.
     */
    get parentNode() {
        let parentNode = wrap(this._$startNode).parentNode;
        const parent = this._$parent;
        if (parent !== undefined &&
            (parentNode === null || parentNode === void 0 ? void 0 : parentNode.nodeType) === 11 /* Node.DOCUMENT_FRAGMENT */) {
            // If the parentNode is a DocumentFragment, it may be because the DOM is
            // still in the cloned fragment during initial render; if so, get the real
            // parentNode the part will be committed into by asking the parent.
            parentNode = parent.parentNode;
        }
        return parentNode;
    }
    /**
     * The part's leading marker node, if any. See `.parentNode` for more
     * information.
     */
    get startNode() {
        return this._$startNode;
    }
    /**
     * The part's trailing marker node, if any. See `.parentNode` for more
     * information.
     */
    get endNode() {
        return this._$endNode;
    }
    _$setValue(value, directiveParent = this) {
        var _a;
        if (DEV_MODE && this.parentNode === null) {
            throw new Error(`This \`ChildPart\` has no \`parentNode\` and therefore cannot accept a value. This likely means the element containing the part was manipulated in an unsupported way outside of Lit's control such that the part's marker nodes were ejected from DOM. For example, setting the element's \`innerHTML\` or \`textContent\` can do this.`);
        }
        value = resolveDirective(this, value, directiveParent);
        if (isPrimitive(value)) {
            // Non-rendering child values. It's important that these do not render
            // empty text nodes to avoid issues with preventing default <slot>
            // fallback content.
            if (value === nothing || value == null || value === '') {
                if (this._$committedValue !== nothing) {
                    debugLogEvent === null || debugLogEvent === void 0 ? void 0 : debugLogEvent({
                        kind: 'commit nothing to child',
                        start: this._$startNode,
                        end: this._$endNode,
                        parent: this._$parent,
                        options: this.options,
                    });
                    this._$clear();
                }
                this._$committedValue = nothing;
            }
            else if (value !== this._$committedValue && value !== noChange) {
                this._commitText(value);
            }
            // This property needs to remain unminified.
        }
        else if (value['_$litType$'] !== undefined) {
            this._commitTemplateResult(value);
        }
        else if (value.nodeType !== undefined) {
            if (DEV_MODE && ((_a = this.options) === null || _a === void 0 ? void 0 : _a.host) === value) {
                this._commitText(`[probable mistake: rendered a template's host in itself ` +
                    `(commonly caused by writing \${this} in a template]`);
                console.warn(`Attempted to render the template host`, value, `inside itself. This is almost always a mistake, and in dev mode `, `we render some warning text. In production however, we'll `, `render it, which will usually result in an error, and sometimes `, `in the element disappearing from the DOM.`);
                return;
            }
            this._commitNode(value);
        }
        else if (isIterable(value)) {
            this._commitIterable(value);
        }
        else {
            // Fallback, will render the string representation
            this._commitText(value);
        }
    }
    _insert(node) {
        return wrap(wrap(this._$startNode).parentNode).insertBefore(node, this._$endNode);
    }
    _commitNode(value) {
        var _a;
        if (this._$committedValue !== value) {
            this._$clear();
            if (ENABLE_EXTRA_SECURITY_HOOKS &&
                sanitizerFactoryInternal !== noopSanitizer) {
                const parentNodeName = (_a = this._$startNode.parentNode) === null || _a === void 0 ? void 0 : _a.nodeName;
                if (parentNodeName === 'STYLE' || parentNodeName === 'SCRIPT') {
                    let message = 'Forbidden';
                    if (DEV_MODE) {
                        if (parentNodeName === 'STYLE') {
                            message =
                                `Lit does not support binding inside style nodes. ` +
                                    `This is a security risk, as style injection attacks can ` +
                                    `exfiltrate data and spoof UIs. ` +
                                    `Consider instead using css\`...\` literals ` +
                                    `to compose styles, and make do dynamic styling with ` +
                                    `css custom properties, ::parts, <slot>s, ` +
                                    `and by mutating the DOM rather than stylesheets.`;
                        }
                        else {
                            message =
                                `Lit does not support binding inside script nodes. ` +
                                    `This is a security risk, as it could allow arbitrary ` +
                                    `code execution.`;
                        }
                    }
                    throw new Error(message);
                }
            }
            debugLogEvent === null || debugLogEvent === void 0 ? void 0 : debugLogEvent({
                kind: 'commit node',
                start: this._$startNode,
                parent: this._$parent,
                value: value,
                options: this.options,
            });
            this._$committedValue = this._insert(value);
        }
    }
    _commitText(value) {
        // If the committed value is a primitive it means we called _commitText on
        // the previous render, and we know that this._$startNode.nextSibling is a
        // Text node. We can now just replace the text content (.data) of the node.
        if (this._$committedValue !== nothing &&
            isPrimitive(this._$committedValue)) {
            const node = wrap(this._$startNode).nextSibling;
            if (ENABLE_EXTRA_SECURITY_HOOKS) {
                if (this._textSanitizer === undefined) {
                    this._textSanitizer = createSanitizer(node, 'data', 'property');
                }
                value = this._textSanitizer(value);
            }
            debugLogEvent === null || debugLogEvent === void 0 ? void 0 : debugLogEvent({
                kind: 'commit text',
                node,
                value,
                options: this.options,
            });
            node.data = value;
        }
        else {
            if (ENABLE_EXTRA_SECURITY_HOOKS) {
                const textNode = d.createTextNode('');
                this._commitNode(textNode);
                // When setting text content, for security purposes it matters a lot
                // what the parent is. For example, <style> and <script> need to be
                // handled with care, while <span> does not. So first we need to put a
                // text node into the document, then we can sanitize its content.
                if (this._textSanitizer === undefined) {
                    this._textSanitizer = createSanitizer(textNode, 'data', 'property');
                }
                value = this._textSanitizer(value);
                debugLogEvent === null || debugLogEvent === void 0 ? void 0 : debugLogEvent({
                    kind: 'commit text',
                    node: textNode,
                    value,
                    options: this.options,
                });
                textNode.data = value;
            }
            else {
                this._commitNode(d.createTextNode(value));
                debugLogEvent === null || debugLogEvent === void 0 ? void 0 : debugLogEvent({
                    kind: 'commit text',
                    node: wrap(this._$startNode).nextSibling,
                    value,
                    options: this.options,
                });
            }
        }
        this._$committedValue = value;
    }
    _commitTemplateResult(result) {
        var _a;
        // This property needs to remain unminified.
        const { values, ['_$litType$']: type } = result;
        // If $litType$ is a number, result is a plain TemplateResult and we get
        // the template from the template cache. If not, result is a
        // CompiledTemplateResult and _$litType$ is a CompiledTemplate and we need
        // to create the <template> element the first time we see it.
        const template = typeof type === 'number'
            ? this._$getTemplate(result)
            : (type.el === undefined &&
                (type.el = Template.createElement(trustFromTemplateString(type.h, type.h[0]), this.options)),
                type);
        if (((_a = this._$committedValue) === null || _a === void 0 ? void 0 : _a._$template) === template) {
            debugLogEvent === null || debugLogEvent === void 0 ? void 0 : debugLogEvent({
                kind: 'template updating',
                template,
                instance: this._$committedValue,
                parts: this._$committedValue._$parts,
                options: this.options,
                values,
            });
            this._$committedValue._update(values);
        }
        else {
            const instance = new TemplateInstance(template, this);
            const fragment = instance._clone(this.options);
            debugLogEvent === null || debugLogEvent === void 0 ? void 0 : debugLogEvent({
                kind: 'template instantiated',
                template,
                instance,
                parts: instance._$parts,
                options: this.options,
                fragment,
                values,
            });
            instance._update(values);
            debugLogEvent === null || debugLogEvent === void 0 ? void 0 : debugLogEvent({
                kind: 'template instantiated and updated',
                template,
                instance,
                parts: instance._$parts,
                options: this.options,
                fragment,
                values,
            });
            this._commitNode(fragment);
            this._$committedValue = instance;
        }
    }
    // Overridden via `litHtmlPolyfillSupport` to provide platform support.
    /** @internal */
    _$getTemplate(result) {
        let template = templateCache.get(result.strings);
        if (template === undefined) {
            templateCache.set(result.strings, (template = new Template(result)));
        }
        return template;
    }
    _commitIterable(value) {
        // For an Iterable, we create a new InstancePart per item, then set its
        // value to the item. This is a little bit of overhead for every item in
        // an Iterable, but it lets us recurse easily and efficiently update Arrays
        // of TemplateResults that will be commonly returned from expressions like:
        // array.map((i) => html`${i}`), by reusing existing TemplateInstances.
        // If value is an array, then the previous render was of an
        // iterable and value will contain the ChildParts from the previous
        // render. If value is not an array, clear this part and make a new
        // array for ChildParts.
        if (!isArray(this._$committedValue)) {
            this._$committedValue = [];
            this._$clear();
        }
        // Lets us keep track of how many items we stamped so we can clear leftover
        // items from a previous render
        const itemParts = this._$committedValue;
        let partIndex = 0;
        let itemPart;
        for (const item of value) {
            if (partIndex === itemParts.length) {
                // If no existing part, create a new one
                // TODO (justinfagnani): test perf impact of always creating two parts
                // instead of sharing parts between nodes
                // https://github.com/lit/lit/issues/1266
                itemParts.push((itemPart = new ChildPart(this._insert(createMarker()), this._insert(createMarker()), this, this.options)));
            }
            else {
                // Reuse an existing part
                itemPart = itemParts[partIndex];
            }
            itemPart._$setValue(item);
            partIndex++;
        }
        if (partIndex < itemParts.length) {
            // itemParts always have end nodes
            this._$clear(itemPart && wrap(itemPart._$endNode).nextSibling, partIndex);
            // Truncate the parts array so _value reflects the current state
            itemParts.length = partIndex;
        }
    }
    /**
     * Removes the nodes contained within this Part from the DOM.
     *
     * @param start Start node to clear from, for clearing a subset of the part's
     *     DOM (used when truncating iterables)
     * @param from  When `start` is specified, the index within the iterable from
     *     which ChildParts are being removed, used for disconnecting directives in
     *     those Parts.
     *
     * @internal
     */
    _$clear(start = wrap(this._$startNode).nextSibling, from) {
        var _a;
        (_a = this._$notifyConnectionChanged) === null || _a === void 0 ? void 0 : _a.call(this, false, true, from);
        while (start && start !== this._$endNode) {
            const n = wrap(start).nextSibling;
            wrap(start).remove();
            start = n;
        }
    }
    /**
     * Implementation of RootPart's `isConnected`. Note that this metod
     * should only be called on `RootPart`s (the `ChildPart` returned from a
     * top-level `render()` call). It has no effect on non-root ChildParts.
     * @param isConnected Whether to set
     * @internal
     */
    setConnected(isConnected) {
        var _a;
        if (this._$parent === undefined) {
            this.__isConnected = isConnected;
            (_a = this._$notifyConnectionChanged) === null || _a === void 0 ? void 0 : _a.call(this, isConnected);
        }
        else if (DEV_MODE) {
            throw new Error('part.setConnected() may only be called on a ' +
                'RootPart returned from render().');
        }
    }
}
class AttributePart {
    constructor(element, name, strings, parent, options) {
        this.type = ATTRIBUTE_PART;
        /** @internal */
        this._$committedValue = nothing;
        /** @internal */
        this._$disconnectableChildren = undefined;
        this.element = element;
        this.name = name;
        this._$parent = parent;
        this.options = options;
        if (strings.length > 2 || strings[0] !== '' || strings[1] !== '') {
            this._$committedValue = new Array(strings.length - 1).fill(new String());
            this.strings = strings;
        }
        else {
            this._$committedValue = nothing;
        }
        if (ENABLE_EXTRA_SECURITY_HOOKS) {
            this._sanitizer = undefined;
        }
    }
    get tagName() {
        return this.element.tagName;
    }
    // See comment in Disconnectable interface for why this is a getter
    get _$isConnected() {
        return this._$parent._$isConnected;
    }
    /**
     * Sets the value of this part by resolving the value from possibly multiple
     * values and static strings and committing it to the DOM.
     * If this part is single-valued, `this._strings` will be undefined, and the
     * method will be called with a single value argument. If this part is
     * multi-value, `this._strings` will be defined, and the method is called
     * with the value array of the part's owning TemplateInstance, and an offset
     * into the value array from which the values should be read.
     * This method is overloaded this way to eliminate short-lived array slices
     * of the template instance values, and allow a fast-path for single-valued
     * parts.
     *
     * @param value The part value, or an array of values for multi-valued parts
     * @param valueIndex the index to start reading values from. `undefined` for
     *   single-valued parts
     * @param noCommit causes the part to not commit its value to the DOM. Used
     *   in hydration to prime attribute parts with their first-rendered value,
     *   but not set the attribute, and in SSR to no-op the DOM operation and
     *   capture the value for serialization.
     *
     * @internal
     */
    _$setValue(value, directiveParent = this, valueIndex, noCommit) {
        const strings = this.strings;
        // Whether any of the values has changed, for dirty-checking
        let change = false;
        if (strings === undefined) {
            // Single-value binding case
            value = resolveDirective(this, value, directiveParent, 0);
            change =
                !isPrimitive(value) ||
                    (value !== this._$committedValue && value !== noChange);
            if (change) {
                this._$committedValue = value;
            }
        }
        else {
            // Interpolation case
            const values = value;
            value = strings[0];
            let i, v;
            for (i = 0; i < strings.length - 1; i++) {
                v = resolveDirective(this, values[valueIndex + i], directiveParent, i);
                if (v === noChange) {
                    // If the user-provided value is `noChange`, use the previous value
                    v = this._$committedValue[i];
                }
                change || (change = !isPrimitive(v) || v !== this._$committedValue[i]);
                if (v === nothing) {
                    value = nothing;
                }
                else if (value !== nothing) {
                    value += (v !== null && v !== void 0 ? v : '') + strings[i + 1];
                }
                // We always record each value, even if one is `nothing`, for future
                // change detection.
                this._$committedValue[i] = v;
            }
        }
        if (change && !noCommit) {
            this._commitValue(value);
        }
    }
    /** @internal */
    _commitValue(value) {
        if (value === nothing) {
            wrap(this.element).removeAttribute(this.name);
        }
        else {
            if (ENABLE_EXTRA_SECURITY_HOOKS) {
                if (this._sanitizer === undefined) {
                    this._sanitizer = sanitizerFactoryInternal(this.element, this.name, 'attribute');
                }
                value = this._sanitizer(value !== null && value !== void 0 ? value : '');
            }
            debugLogEvent === null || debugLogEvent === void 0 ? void 0 : debugLogEvent({
                kind: 'commit attribute',
                element: this.element,
                name: this.name,
                value,
                options: this.options,
            });
            wrap(this.element).setAttribute(this.name, (value !== null && value !== void 0 ? value : ''));
        }
    }
}
class PropertyPart extends AttributePart {
    constructor() {
        super(...arguments);
        this.type = PROPERTY_PART;
    }
    /** @internal */
    _commitValue(value) {
        if (ENABLE_EXTRA_SECURITY_HOOKS) {
            if (this._sanitizer === undefined) {
                this._sanitizer = sanitizerFactoryInternal(this.element, this.name, 'property');
            }
            value = this._sanitizer(value);
        }
        debugLogEvent === null || debugLogEvent === void 0 ? void 0 : debugLogEvent({
            kind: 'commit property',
            element: this.element,
            name: this.name,
            value,
            options: this.options,
        });
        // eslint-disable-next-line @typescript-eslint/no-explicit-any
        this.element[this.name] = value === nothing ? undefined : value;
    }
}
// Temporary workaround for https://crbug.com/993268
// Currently, any attribute starting with "on" is considered to be a
// TrustedScript source. Such boolean attributes must be set to the equivalent
// trusted emptyScript value.
const emptyStringForBooleanAttribute = trustedTypes
    ? trustedTypes.emptyScript
    : '';
class BooleanAttributePart extends AttributePart {
    constructor() {
        super(...arguments);
        this.type = BOOLEAN_ATTRIBUTE_PART;
    }
    /** @internal */
    _commitValue(value) {
        debugLogEvent === null || debugLogEvent === void 0 ? void 0 : debugLogEvent({
            kind: 'commit boolean attribute',
            element: this.element,
            name: this.name,
            value: !!(value && value !== nothing),
            options: this.options,
        });
        if (value && value !== nothing) {
            wrap(this.element).setAttribute(this.name, emptyStringForBooleanAttribute);
        }
        else {
            wrap(this.element).removeAttribute(this.name);
        }
    }
}
class EventPart extends AttributePart {
    constructor(element, name, strings, parent, options) {
        super(element, name, strings, parent, options);
        this.type = EVENT_PART;
        if (DEV_MODE && this.strings !== undefined) {
            throw new Error(`A \`<${element.localName}>\` has a \`@${name}=...\` listener with ` +
                'invalid content. Event listeners in templates must have exactly ' +
                'one expression and no surrounding text.');
        }
    }
    // EventPart does not use the base _$setValue/_resolveValue implementation
    // since the dirty checking is more complex
    /** @internal */
    _$setValue(newListener, directiveParent = this) {
        var _a;
        newListener =
            (_a = resolveDirective(this, newListener, directiveParent, 0)) !== null && _a !== void 0 ? _a : nothing;
        if (newListener === noChange) {
            return;
        }
        const oldListener = this._$committedValue;
        // If the new value is nothing or any options change we have to remove the
        // part as a listener.
        const shouldRemoveListener = (newListener === nothing && oldListener !== nothing) ||
            newListener.capture !==
                oldListener.capture ||
            newListener.once !==
                oldListener.once ||
            newListener.passive !==
                oldListener.passive;
        // If the new value is not nothing and we removed the listener, we have
        // to add the part as a listener.
        const shouldAddListener = newListener !== nothing &&
            (oldListener === nothing || shouldRemoveListener);
        debugLogEvent === null || debugLogEvent === void 0 ? void 0 : debugLogEvent({
            kind: 'commit event listener',
            element: this.element,
            name: this.name,
            value: newListener,
            options: this.options,
            removeListener: shouldRemoveListener,
            addListener: shouldAddListener,
            oldListener,
        });
        if (shouldRemoveListener) {
            this.element.removeEventListener(this.name, this, oldListener);
        }
        if (shouldAddListener) {
            // Beware: IE11 and Chrome 41 don't like using the listener as the
            // options object. Figure out how to deal w/ this in IE11 - maybe
            // patch addEventListener?
            this.element.addEventListener(this.name, this, newListener);
        }
        this._$committedValue = newListener;
    }
    handleEvent(event) {
        var _a, _b;
        if (typeof this._$committedValue === 'function') {
            this._$committedValue.call((_b = (_a = this.options) === null || _a === void 0 ? void 0 : _a.host) !== null && _b !== void 0 ? _b : this.element, event);
        }
        else {
            this._$committedValue.handleEvent(event);
        }
    }
}
class ElementPart {
    constructor(element, parent, options) {
        this.element = element;
        this.type = ELEMENT_PART;
        /** @internal */
        this._$disconnectableChildren = undefined;
        this._$parent = parent;
        this.options = options;
    }
    // See comment in Disconnectable interface for why this is a getter
    get _$isConnected() {
        return this._$parent._$isConnected;
    }
    _$setValue(value) {
        debugLogEvent === null || debugLogEvent === void 0 ? void 0 : debugLogEvent({
            kind: 'commit to element binding',
            element: this.element,
            value,
            options: this.options,
        });
        resolveDirective(this, value);
    }
}
/**
 * END USERS SHOULD NOT RELY ON THIS OBJECT.
 *
 * Private exports for use by other Lit packages, not intended for use by
 * external users.
 *
 * We currently do not make a mangled rollup build of the lit-ssr code. In order
 * to keep a number of (otherwise private) top-level exports  mangled in the
 * client side code, we export a _$LH object containing those members (or
 * helper methods for accessing private fields of those members), and then
 * re-export them for use in lit-ssr. This keeps lit-ssr agnostic to whether the
 * client-side code is being used in `dev` mode or `prod` mode.
 *
 * This has a unique name, to disambiguate it from private exports in
 * lit-element, which re-exports all of lit-html.
 *
 * @private
 */
const _$LH = {
    // Used in lit-ssr
    _boundAttributeSuffix: boundAttributeSuffix,
    _marker: marker,
    _markerMatch: markerMatch,
    _HTML_RESULT: HTML_RESULT,
    _getTemplateHtml: getTemplateHtml,
    // Used in tests and private-ssr-support
    _TemplateInstance: TemplateInstance,
    _isIterable: isIterable,
    _resolveDirective: resolveDirective,
    _ChildPart: ChildPart,
    _AttributePart: AttributePart,
    _BooleanAttributePart: BooleanAttributePart,
    _EventPart: EventPart,
    _PropertyPart: PropertyPart,
    _ElementPart: ElementPart,
};
// Apply polyfills if available
const polyfillSupport = DEV_MODE
    ? global.litHtmlPolyfillSupportDevMode
    : global.litHtmlPolyfillSupport;
polyfillSupport === null || polyfillSupport === void 0 ? void 0 : polyfillSupport(Template, ChildPart);
// IMPORTANT: do not change the property name or the assignment expression.
// This line will be used in regexes to search for lit-html usage.
((_d = global.litHtmlVersions) !== null && _d !== void 0 ? _d : (global.litHtmlVersions = [])).push('2.8.0');
if (DEV_MODE && global.litHtmlVersions.length > 1) {
    issueWarning('multiple-versions', `Multiple versions of Lit loaded. ` +
        `Loading multiple versions is not recommended.`);
}
/**
 * Renders a value, usually a lit-html TemplateResult, to the container.
 *
 * This example renders the text "Hello, Zoe!" inside a paragraph tag, appending
 * it to the container `document.body`.
 *
 * ```js
 * import {html, render} from 'lit';
 *
 * const name = "Zoe";
 * render(html`<p>Hello, ${name}!</p>`, document.body);
 * ```
 *
 * @param value Any [renderable
 *   value](https://lit.dev/docs/templates/expressions/#child-expressions),
 *   typically a {@linkcode TemplateResult} created by evaluating a template tag
 *   like {@linkcode html} or {@linkcode svg}.
 * @param container A DOM container to render to. The first render will append
 *   the rendered value to the container, and subsequent renders will
 *   efficiently update the rendered value if the same result type was
 *   previously rendered there.
 * @param options See {@linkcode RenderOptions} for options documentation.
 * @see
 * {@link https://lit.dev/docs/libraries/standalone-templates/#rendering-lit-html-templates| Rendering Lit HTML Templates}
 */
const render = (value, container, options) => {
    var _a, _b;
    if (DEV_MODE && container == null) {
        // Give a clearer error message than
        //     Uncaught TypeError: Cannot read properties of null (reading
        //     '_$litPart$')
        // which reads like an internal Lit error.
        throw new TypeError(`The container to render into may not be ${container}`);
    }
    const renderId = DEV_MODE ? debugLogRenderId++ : 0;
    const partOwnerNode = (_a = options === null || options === void 0 ? void 0 : options.renderBefore) !== null && _a !== void 0 ? _a : container;
    // This property needs to remain unminified.
    // eslint-disable-next-line @typescript-eslint/no-explicit-any
    let part = partOwnerNode['_$litPart$'];
    debugLogEvent === null || debugLogEvent === void 0 ? void 0 : debugLogEvent({
        kind: 'begin render',
        id: renderId,
        value,
        container,
        options,
        part,
    });
    if (part === undefined) {
        const endNode = (_b = options === null || options === void 0 ? void 0 : options.renderBefore) !== null && _b !== void 0 ? _b : null;
        // This property needs to remain unminified.
        // eslint-disable-next-line @typescript-eslint/no-explicit-any
        partOwnerNode['_$litPart$'] = part = new ChildPart(container.insertBefore(createMarker(), endNode), endNode, undefined, options !== null && options !== void 0 ? options : {});
    }
    part._$setValue(value);
    debugLogEvent === null || debugLogEvent === void 0 ? void 0 : debugLogEvent({
        kind: 'end render',
        id: renderId,
        value,
        container,
        options,
        part,
    });
    return part;
};
if (ENABLE_EXTRA_SECURITY_HOOKS) {
    render.setSanitizer = setSanitizer;
    render.createSanitizer = createSanitizer;
    if (DEV_MODE) {
        render._testOnlyClearSanitizerFactoryDoNotCallOrElse =
            _testOnlyClearSanitizerFactoryDoNotCallOrElse;
    }
}
//# sourceMappingURL=lit-html.js.map

/***/ }),

/***/ "./node_modules/lit/directives/class-map.js":
/*!**************************************************!*\
  !*** ./node_modules/lit/directives/class-map.js ***!
  \**************************************************/
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   classMap: () => (/* reexport safe */ lit_html_directives_class_map_js__WEBPACK_IMPORTED_MODULE_0__.classMap)
/* harmony export */ });
/* harmony import */ var lit_html_directives_class_map_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! lit-html/directives/class-map.js */ "./node_modules/lit-html/development/directives/class-map.js");

//# sourceMappingURL=class-map.js.map


/***/ }),

/***/ "./node_modules/lit/directives/if-defined.js":
/*!***************************************************!*\
  !*** ./node_modules/lit/directives/if-defined.js ***!
  \***************************************************/
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   ifDefined: () => (/* reexport safe */ lit_html_directives_if_defined_js__WEBPACK_IMPORTED_MODULE_0__.ifDefined)
/* harmony export */ });
/* harmony import */ var lit_html_directives_if_defined_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! lit-html/directives/if-defined.js */ "./node_modules/lit-html/development/directives/if-defined.js");

//# sourceMappingURL=if-defined.js.map


/***/ }),

/***/ "./node_modules/lit/directives/map.js":
/*!********************************************!*\
  !*** ./node_modules/lit/directives/map.js ***!
  \********************************************/
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   map: () => (/* reexport safe */ lit_html_directives_map_js__WEBPACK_IMPORTED_MODULE_0__.map)
/* harmony export */ });
/* harmony import */ var lit_html_directives_map_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! lit-html/directives/map.js */ "./node_modules/lit-html/development/directives/map.js");

//# sourceMappingURL=map.js.map


/***/ }),

/***/ "./node_modules/lit/directives/repeat.js":
/*!***********************************************!*\
  !*** ./node_modules/lit/directives/repeat.js ***!
  \***********************************************/
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   repeat: () => (/* reexport safe */ lit_html_directives_repeat_js__WEBPACK_IMPORTED_MODULE_0__.repeat)
/* harmony export */ });
/* harmony import */ var lit_html_directives_repeat_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! lit-html/directives/repeat.js */ "./node_modules/lit-html/development/directives/repeat.js");

//# sourceMappingURL=repeat.js.map


/***/ }),

/***/ "./node_modules/lit/directives/style-map.js":
/*!**************************************************!*\
  !*** ./node_modules/lit/directives/style-map.js ***!
  \**************************************************/
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   styleMap: () => (/* reexport safe */ lit_html_directives_style_map_js__WEBPACK_IMPORTED_MODULE_0__.styleMap)
/* harmony export */ });
/* harmony import */ var lit_html_directives_style_map_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! lit-html/directives/style-map.js */ "./node_modules/lit-html/development/directives/style-map.js");

//# sourceMappingURL=style-map.js.map


/***/ }),

/***/ "./node_modules/lit/index.js":
/*!***********************************!*\
  !*** ./node_modules/lit/index.js ***!
  \***********************************/
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   CSSResult: () => (/* reexport safe */ lit_element_lit_element_js__WEBPACK_IMPORTED_MODULE_2__.CSSResult),
/* harmony export */   LitElement: () => (/* reexport safe */ lit_element_lit_element_js__WEBPACK_IMPORTED_MODULE_2__.LitElement),
/* harmony export */   ReactiveElement: () => (/* reexport safe */ lit_element_lit_element_js__WEBPACK_IMPORTED_MODULE_2__.ReactiveElement),
/* harmony export */   UpdatingElement: () => (/* reexport safe */ lit_element_lit_element_js__WEBPACK_IMPORTED_MODULE_2__.UpdatingElement),
/* harmony export */   _$LE: () => (/* reexport safe */ lit_element_lit_element_js__WEBPACK_IMPORTED_MODULE_2__._$LE),
/* harmony export */   _$LH: () => (/* reexport safe */ lit_element_lit_element_js__WEBPACK_IMPORTED_MODULE_2__._$LH),
/* harmony export */   adoptStyles: () => (/* reexport safe */ lit_element_lit_element_js__WEBPACK_IMPORTED_MODULE_2__.adoptStyles),
/* harmony export */   css: () => (/* reexport safe */ lit_element_lit_element_js__WEBPACK_IMPORTED_MODULE_2__.css),
/* harmony export */   defaultConverter: () => (/* reexport safe */ lit_element_lit_element_js__WEBPACK_IMPORTED_MODULE_2__.defaultConverter),
/* harmony export */   getCompatibleStyle: () => (/* reexport safe */ lit_element_lit_element_js__WEBPACK_IMPORTED_MODULE_2__.getCompatibleStyle),
/* harmony export */   html: () => (/* reexport safe */ lit_element_lit_element_js__WEBPACK_IMPORTED_MODULE_2__.html),
/* harmony export */   isServer: () => (/* reexport safe */ lit_html_is_server_js__WEBPACK_IMPORTED_MODULE_3__.isServer),
/* harmony export */   noChange: () => (/* reexport safe */ lit_element_lit_element_js__WEBPACK_IMPORTED_MODULE_2__.noChange),
/* harmony export */   notEqual: () => (/* reexport safe */ lit_element_lit_element_js__WEBPACK_IMPORTED_MODULE_2__.notEqual),
/* harmony export */   nothing: () => (/* reexport safe */ lit_element_lit_element_js__WEBPACK_IMPORTED_MODULE_2__.nothing),
/* harmony export */   render: () => (/* reexport safe */ lit_element_lit_element_js__WEBPACK_IMPORTED_MODULE_2__.render),
/* harmony export */   supportsAdoptingStyleSheets: () => (/* reexport safe */ lit_element_lit_element_js__WEBPACK_IMPORTED_MODULE_2__.supportsAdoptingStyleSheets),
/* harmony export */   svg: () => (/* reexport safe */ lit_element_lit_element_js__WEBPACK_IMPORTED_MODULE_2__.svg),
/* harmony export */   unsafeCSS: () => (/* reexport safe */ lit_element_lit_element_js__WEBPACK_IMPORTED_MODULE_2__.unsafeCSS)
/* harmony export */ });
/* harmony import */ var _lit_reactive_element__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! @lit/reactive-element */ "./node_modules/@lit/reactive-element/development/reactive-element.js");
/* harmony import */ var lit_html__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! lit-html */ "./node_modules/lit-html/development/lit-html.js");
/* harmony import */ var lit_element_lit_element_js__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! lit-element/lit-element.js */ "./node_modules/lit-element/development/lit-element.js");
/* harmony import */ var lit_html_is_server_js__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(/*! lit-html/is-server.js */ "./node_modules/lit-html/development/is-server.js");

//# sourceMappingURL=index.js.map


/***/ })

/******/ 	});
/************************************************************************/
/******/ 	// The module cache
/******/ 	var __webpack_module_cache__ = {};
/******/ 	
/******/ 	// The require function
/******/ 	function __webpack_require__(moduleId) {
/******/ 		// Check if module is in cache
/******/ 		var cachedModule = __webpack_module_cache__[moduleId];
/******/ 		if (cachedModule !== undefined) {
/******/ 			return cachedModule.exports;
/******/ 		}
/******/ 		// Create a new module (and put it into the cache)
/******/ 		var module = __webpack_module_cache__[moduleId] = {
/******/ 			// no module.id needed
/******/ 			// no module.loaded needed
/******/ 			exports: {}
/******/ 		};
/******/ 	
/******/ 		// Execute the module function
/******/ 		__webpack_modules__[moduleId](module, module.exports, __webpack_require__);
/******/ 	
/******/ 		// Return the exports of the module
/******/ 		return module.exports;
/******/ 	}
/******/ 	
/******/ 	// expose the modules object (__webpack_modules__)
/******/ 	__webpack_require__.m = __webpack_modules__;
/******/ 	
/************************************************************************/
/******/ 	/* webpack/runtime/chunk loaded */
/******/ 	(() => {
/******/ 		var deferred = [];
/******/ 		__webpack_require__.O = (result, chunkIds, fn, priority) => {
/******/ 			if(chunkIds) {
/******/ 				priority = priority || 0;
/******/ 				for(var i = deferred.length; i > 0 && deferred[i - 1][2] > priority; i--) deferred[i] = deferred[i - 1];
/******/ 				deferred[i] = [chunkIds, fn, priority];
/******/ 				return;
/******/ 			}
/******/ 			var notFulfilled = Infinity;
/******/ 			for (var i = 0; i < deferred.length; i++) {
/******/ 				var [chunkIds, fn, priority] = deferred[i];
/******/ 				var fulfilled = true;
/******/ 				for (var j = 0; j < chunkIds.length; j++) {
/******/ 					if ((priority & 1 === 0 || notFulfilled >= priority) && Object.keys(__webpack_require__.O).every((key) => (__webpack_require__.O[key](chunkIds[j])))) {
/******/ 						chunkIds.splice(j--, 1);
/******/ 					} else {
/******/ 						fulfilled = false;
/******/ 						if(priority < notFulfilled) notFulfilled = priority;
/******/ 					}
/******/ 				}
/******/ 				if(fulfilled) {
/******/ 					deferred.splice(i--, 1)
/******/ 					var r = fn();
/******/ 					if (r !== undefined) result = r;
/******/ 				}
/******/ 			}
/******/ 			return result;
/******/ 		};
/******/ 	})();
/******/ 	
/******/ 	/* webpack/runtime/define property getters */
/******/ 	(() => {
/******/ 		// define getter functions for harmony exports
/******/ 		__webpack_require__.d = (exports, definition) => {
/******/ 			for(var key in definition) {
/******/ 				if(__webpack_require__.o(definition, key) && !__webpack_require__.o(exports, key)) {
/******/ 					Object.defineProperty(exports, key, { enumerable: true, get: definition[key] });
/******/ 				}
/******/ 			}
/******/ 		};
/******/ 	})();
/******/ 	
/******/ 	/* webpack/runtime/ensure chunk */
/******/ 	(() => {
/******/ 		__webpack_require__.f = {};
/******/ 		// This file contains only the entry chunk.
/******/ 		// The chunk loading function for additional chunks
/******/ 		__webpack_require__.e = (chunkId) => {
/******/ 			return Promise.all(Object.keys(__webpack_require__.f).reduce((promises, key) => {
/******/ 				__webpack_require__.f[key](chunkId, promises);
/******/ 				return promises;
/******/ 			}, []));
/******/ 		};
/******/ 	})();
/******/ 	
/******/ 	/* webpack/runtime/get javascript chunk filename */
/******/ 	(() => {
/******/ 		// This function allow to reference async chunks
/******/ 		__webpack_require__.u = (chunkId) => {
/******/ 			// return url for filenames not based on template
/******/ 			if ({"node_modules_disciple_tools_web-components_src_i18n_generated_am_ET_js":1,"node_modules_disciple_tools_web-components_src_i18n_generated_ar_js":1,"node_modules_disciple_tools_web-components_src_i18n_generated_ar_MA_js":1,"node_modules_disciple_tools_web-components_src_i18n_generated_bg_BG_js":1,"node_modules_disciple_tools_web-components_src_i18n_generated_bn_BD_js":1,"node_modules_disciple_tools_web-components_src_i18n_generated_bs_BA_js":1,"node_modules_disciple_tools_web-components_src_i18n_generated_cs_js":1,"node_modules_disciple_tools_web-components_src_i18n_generated_de_DE_js":1,"node_modules_disciple_tools_web-components_src_i18n_generated_el_js":1,"node_modules_disciple_tools_web-components_src_i18n_generated_en_US_js":1,"node_modules_disciple_tools_web-components_src_i18n_generated_es-419_js":1,"node_modules_disciple_tools_web-components_src_i18n_generated_es_419_js":1,"node_modules_disciple_tools_web-components_src_i18n_generated_es_ES_js":1,"node_modules_disciple_tools_web-components_src_i18n_generated_fa_IR_js":1,"node_modules_disciple_tools_web-components_src_i18n_generated_fr_FR_js":1,"node_modules_disciple_tools_web-components_src_i18n_generated_hi_IN_js":1,"node_modules_disciple_tools_web-components_src_i18n_generated_hr_js":1,"node_modules_disciple_tools_web-components_src_i18n_generated_hu_HU_js":1,"node_modules_disciple_tools_web-components_src_i18n_generated_id_ID_js":1,"node_modules_disciple_tools_web-components_src_i18n_generated_it_IT_js":1,"node_modules_disciple_tools_web-components_src_i18n_generated_ja_js":1,"node_modules_disciple_tools_web-components_src_i18n_generated_ko_KR_js":1,"node_modules_disciple_tools_web-components_src_i18n_generated_mk_MK_js":1,"node_modules_disciple_tools_web-components_src_i18n_generated_mr_js":1,"node_modules_disciple_tools_web-components_src_i18n_generated_my_MM_js":1,"node_modules_disciple_tools_web-components_src_i18n_generated_ne_NP_js":1,"node_modules_disciple_tools_web-components_src_i18n_generated_nl_NL_js":1,"node_modules_disciple_tools_web-components_src_i18n_generated_pa_IN_js":1,"node_modules_disciple_tools_web-components_src_i18n_generated_pl_js":1,"node_modules_disciple_tools_web-components_src_i18n_generated_pt_BR_js":1,"node_modules_disciple_tools_web-components_src_i18n_generated_ro_RO_js":1,"node_modules_disciple_tools_web-components_src_i18n_generated_ru_RU_js":1,"node_modules_disciple_tools_web-components_src_i18n_generated_sl_SI_js":1,"node_modules_disciple_tools_web-components_src_i18n_generated_sr_BA_js":1,"node_modules_disciple_tools_web-components_src_i18n_generated_sw_js":1,"node_modules_disciple_tools_web-components_src_i18n_generated_th_js":1,"node_modules_disciple_tools_web-components_src_i18n_generated_tl_js":1,"node_modules_disciple_tools_web-components_src_i18n_generated_tr_TR_js":1,"node_modules_disciple_tools_web-components_src_i18n_generated_uk_js":1,"node_modules_disciple_tools_web-components_src_i18n_generated_vi_js":1,"node_modules_disciple_tools_web-components_src_i18n_generated_zh_CN_js":1,"node_modules_disciple_tools_web-components_src_i18n_generated_zh_TW_js":1}[chunkId]) return "conversation_scripts/" + chunkId + ".js";
/******/ 			// return url for filenames based on template
/******/ 			return undefined;
/******/ 		};
/******/ 	})();
/******/ 	
/******/ 	/* webpack/runtime/get mini-css chunk filename */
/******/ 	(() => {
/******/ 		// This function allow to reference all chunks
/******/ 		__webpack_require__.miniCssF = (chunkId) => {
/******/ 			// return url for filenames based on template
/******/ 			return "" + chunkId + ".css";
/******/ 		};
/******/ 	})();
/******/ 	
/******/ 	/* webpack/runtime/hasOwnProperty shorthand */
/******/ 	(() => {
/******/ 		__webpack_require__.o = (obj, prop) => (Object.prototype.hasOwnProperty.call(obj, prop))
/******/ 	})();
/******/ 	
/******/ 	/* webpack/runtime/load script */
/******/ 	(() => {
/******/ 		var inProgress = {};
/******/ 		var dataWebpackPrefix = "disciple-tools-conversations:";
/******/ 		// loadScript function to load a script via script tag
/******/ 		__webpack_require__.l = (url, done, key, chunkId) => {
/******/ 			if(inProgress[url]) { inProgress[url].push(done); return; }
/******/ 			var script, needAttach;
/******/ 			if(key !== undefined) {
/******/ 				var scripts = document.getElementsByTagName("script");
/******/ 				for(var i = 0; i < scripts.length; i++) {
/******/ 					var s = scripts[i];
/******/ 					if(s.getAttribute("src") == url || s.getAttribute("data-webpack") == dataWebpackPrefix + key) { script = s; break; }
/******/ 				}
/******/ 			}
/******/ 			if(!script) {
/******/ 				needAttach = true;
/******/ 				script = document.createElement('script');
/******/ 		
/******/ 				script.charset = 'utf-8';
/******/ 				script.timeout = 120;
/******/ 				if (__webpack_require__.nc) {
/******/ 					script.setAttribute("nonce", __webpack_require__.nc);
/******/ 				}
/******/ 				script.setAttribute("data-webpack", dataWebpackPrefix + key);
/******/ 		
/******/ 				script.src = url;
/******/ 			}
/******/ 			inProgress[url] = [done];
/******/ 			var onScriptComplete = (prev, event) => {
/******/ 				// avoid mem leaks in IE.
/******/ 				script.onerror = script.onload = null;
/******/ 				clearTimeout(timeout);
/******/ 				var doneFns = inProgress[url];
/******/ 				delete inProgress[url];
/******/ 				script.parentNode && script.parentNode.removeChild(script);
/******/ 				doneFns && doneFns.forEach((fn) => (fn(event)));
/******/ 				if(prev) return prev(event);
/******/ 			}
/******/ 			var timeout = setTimeout(onScriptComplete.bind(null, undefined, { type: 'timeout', target: script }), 120000);
/******/ 			script.onerror = onScriptComplete.bind(null, script.onerror);
/******/ 			script.onload = onScriptComplete.bind(null, script.onload);
/******/ 			needAttach && document.head.appendChild(script);
/******/ 		};
/******/ 	})();
/******/ 	
/******/ 	/* webpack/runtime/make namespace object */
/******/ 	(() => {
/******/ 		// define __esModule on exports
/******/ 		__webpack_require__.r = (exports) => {
/******/ 			if(typeof Symbol !== 'undefined' && Symbol.toStringTag) {
/******/ 				Object.defineProperty(exports, Symbol.toStringTag, { value: 'Module' });
/******/ 			}
/******/ 			Object.defineProperty(exports, '__esModule', { value: true });
/******/ 		};
/******/ 	})();
/******/ 	
/******/ 	/* webpack/runtime/publicPath */
/******/ 	(() => {
/******/ 		__webpack_require__.p = "/wp-content/plugins/disciple-tools-conversations/dist/";
/******/ 	})();
/******/ 	
/******/ 	/* webpack/runtime/jsonp chunk loading */
/******/ 	(() => {
/******/ 		// no baseURI
/******/ 		
/******/ 		// object to store loaded and loading chunks
/******/ 		// undefined = chunk not loaded, null = chunk preloaded/prefetched
/******/ 		// [resolve, reject, Promise] = chunk loading, 0 = chunk loaded
/******/ 		var installedChunks = {
/******/ 			"/conversation_scripts": 0,
/******/ 			"styles": 0
/******/ 		};
/******/ 		
/******/ 		__webpack_require__.f.j = (chunkId, promises) => {
/******/ 				// JSONP chunk loading for javascript
/******/ 				var installedChunkData = __webpack_require__.o(installedChunks, chunkId) ? installedChunks[chunkId] : undefined;
/******/ 				if(installedChunkData !== 0) { // 0 means "already installed".
/******/ 		
/******/ 					// a Promise means "currently loading".
/******/ 					if(installedChunkData) {
/******/ 						promises.push(installedChunkData[2]);
/******/ 					} else {
/******/ 						if("styles" != chunkId) {
/******/ 							// setup Promise in chunk cache
/******/ 							var promise = new Promise((resolve, reject) => (installedChunkData = installedChunks[chunkId] = [resolve, reject]));
/******/ 							promises.push(installedChunkData[2] = promise);
/******/ 		
/******/ 							// start chunk loading
/******/ 							var url = __webpack_require__.p + __webpack_require__.u(chunkId);
/******/ 							// create error before stack unwound to get useful stacktrace later
/******/ 							var error = new Error();
/******/ 							var loadingEnded = (event) => {
/******/ 								if(__webpack_require__.o(installedChunks, chunkId)) {
/******/ 									installedChunkData = installedChunks[chunkId];
/******/ 									if(installedChunkData !== 0) installedChunks[chunkId] = undefined;
/******/ 									if(installedChunkData) {
/******/ 										var errorType = event && (event.type === 'load' ? 'missing' : event.type);
/******/ 										var realSrc = event && event.target && event.target.src;
/******/ 										error.message = 'Loading chunk ' + chunkId + ' failed.\n(' + errorType + ': ' + realSrc + ')';
/******/ 										error.name = 'ChunkLoadError';
/******/ 										error.type = errorType;
/******/ 										error.request = realSrc;
/******/ 										installedChunkData[1](error);
/******/ 									}
/******/ 								}
/******/ 							};
/******/ 							__webpack_require__.l(url, loadingEnded, "chunk-" + chunkId, chunkId);
/******/ 						} else installedChunks[chunkId] = 0;
/******/ 					}
/******/ 				}
/******/ 		};
/******/ 		
/******/ 		// no prefetching
/******/ 		
/******/ 		// no preloaded
/******/ 		
/******/ 		// no HMR
/******/ 		
/******/ 		// no HMR manifest
/******/ 		
/******/ 		__webpack_require__.O.j = (chunkId) => (installedChunks[chunkId] === 0);
/******/ 		
/******/ 		// install a JSONP callback for chunk loading
/******/ 		var webpackJsonpCallback = (parentChunkLoadingFunction, data) => {
/******/ 			var [chunkIds, moreModules, runtime] = data;
/******/ 			// add "moreModules" to the modules object,
/******/ 			// then flag all "chunkIds" as loaded and fire callback
/******/ 			var moduleId, chunkId, i = 0;
/******/ 			if(chunkIds.some((id) => (installedChunks[id] !== 0))) {
/******/ 				for(moduleId in moreModules) {
/******/ 					if(__webpack_require__.o(moreModules, moduleId)) {
/******/ 						__webpack_require__.m[moduleId] = moreModules[moduleId];
/******/ 					}
/******/ 				}
/******/ 				if(runtime) var result = runtime(__webpack_require__);
/******/ 			}
/******/ 			if(parentChunkLoadingFunction) parentChunkLoadingFunction(data);
/******/ 			for(;i < chunkIds.length; i++) {
/******/ 				chunkId = chunkIds[i];
/******/ 				if(__webpack_require__.o(installedChunks, chunkId) && installedChunks[chunkId]) {
/******/ 					installedChunks[chunkId][0]();
/******/ 				}
/******/ 				installedChunks[chunkId] = 0;
/******/ 			}
/******/ 			return __webpack_require__.O(result);
/******/ 		}
/******/ 		
/******/ 		var chunkLoadingGlobal = self["webpackChunkdisciple_tools_conversations"] = self["webpackChunkdisciple_tools_conversations"] || [];
/******/ 		chunkLoadingGlobal.forEach(webpackJsonpCallback.bind(null, 0));
/******/ 		chunkLoadingGlobal.push = webpackJsonpCallback.bind(null, chunkLoadingGlobal.push.bind(chunkLoadingGlobal));
/******/ 	})();
/******/ 	
/************************************************************************/
/******/ 	
/******/ 	// startup
/******/ 	// Load entry module and return exports
/******/ 	// This entry module depends on other loaded chunks and execution need to be delayed
/******/ 	__webpack_require__.O(undefined, ["styles"], () => (__webpack_require__("./assets/js/conversation_scripts.js")))
/******/ 	var __webpack_exports__ = __webpack_require__.O(undefined, ["styles"], () => (__webpack_require__("./assets/css/styles.css")))
/******/ 	__webpack_exports__ = __webpack_require__.O(__webpack_exports__);
/******/ 	
/******/ })()
;