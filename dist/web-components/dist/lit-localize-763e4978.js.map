{"version":3,"file":"lit-localize-763e4978.js","sources":["../node_modules/@lit/localize/internal/str-tag.js","../node_modules/@lit/localize/internal/default-msg.js","../node_modules/@lit/localize/internal/locale-status-event.js","../node_modules/@lit/localize/internal/deferred.js","../node_modules/@lit/localize/internal/fnv1a64.js","../node_modules/@lit/localize/internal/id-generation.js","../node_modules/@lit/localize/internal/runtime-msg.js","../node_modules/@lit/localize/init/runtime.js","../node_modules/@lit/localize/lit-localize.js"],"sourcesContent":["/**\n * @license\n * Copyright 2021 Google LLC\n * SPDX-License-Identifier: BSD-3-Clause\n */\n/**\n * Tag that allows expressions to be used in localized non-HTML template\n * strings.\n *\n * Example: msg(str`Hello ${this.user}!`);\n *\n * The Lit html tag can also be used for this purpose, but HTML will need to be\n * escaped, and there is a small overhead for HTML parsing.\n *\n * Untagged template strings with expressions aren't supported by lit-localize\n * because they don't allow for values to be captured at runtime.\n */\nconst _str = (strings, ...values) => ({\n    strTag: true,\n    strings,\n    values,\n});\nexport const str = _str;\nexport const isStrTagged = (val) => typeof val !== 'string' && 'strTag' in val;\n/**\n * Render the result of a `str` tagged template to a string. Note we don't need\n * to do this for Lit templates, since Lit itself handles rendering.\n */\nexport const joinStringsAndValues = (strings, values, valueOrder) => {\n    let concat = strings[0];\n    for (let i = 1; i < strings.length; i++) {\n        concat += values[valueOrder ? valueOrder[i - 1] : i - 1];\n        concat += strings[i];\n    }\n    return concat;\n};\n//# sourceMappingURL=str-tag.js.map","/**\n * @license\n * Copyright 2021 Google LLC\n * SPDX-License-Identifier: BSD-3-Clause\n */\nimport { isStrTagged, joinStringsAndValues } from './str-tag.js';\n/**\n * Default identity msg implementation. Simply returns the input template with\n * no awareness of translations. If the template is str-tagged, returns it in\n * string form.\n */\nexport const defaultMsg = ((template) => isStrTagged(template)\n    ? joinStringsAndValues(template.strings, template.values)\n    : template);\n//# sourceMappingURL=default-msg.js.map","/**\n * @license\n * Copyright 2021 Google LLC\n * SPDX-License-Identifier: BSD-3-Clause\n */\n/**\n * Name of the event dispatched to `window` whenever a locale change starts,\n * finishes successfully, or fails. Only relevant to runtime mode.\n *\n * The `detail` of this event is an object with a `status` string that can be:\n * \"loading\", \"ready\", or \"error\", along with the relevant locale code, and\n * error message if applicable.\n *\n * You can listen for this event to know when your application should be\n * re-rendered following a locale change. See also the Localized mixin, which\n * automatically re-renders LitElement classes using this event.\n */\nexport const LOCALE_STATUS_EVENT = 'lit-localize-status';\n//# sourceMappingURL=locale-status-event.js.map","/**\n * @license\n * Copyright 2020 Google LLC\n * SPDX-License-Identifier: BSD-3-Clause\n */\nexport class Deferred {\n    constructor() {\n        this.settled = false;\n        this.promise = new Promise((resolve, reject) => {\n            this._resolve = resolve;\n            this._reject = reject;\n        });\n    }\n    resolve(value) {\n        this.settled = true;\n        this._resolve(value);\n    }\n    reject(error) {\n        this.settled = true;\n        this._reject(error);\n    }\n}\n//# sourceMappingURL=deferred.js.map","/**\n * @license\n * Copyright 2014 Travis Webb\n * SPDX-License-Identifier: MIT\n */\n// This module is derived from the file:\n// https://github.com/tjwebb/fnv-plus/blob/1e2ce68a07cb7dd4c3c85364f3d8d96c95919474/index.js#L309\n//\n// Changes:\n// - Only the _hash64_1a_fast function is included.\n// - Removed loop unrolling.\n// - Converted to TypeScript ES module.\n// - var -> let/const\n//\n// TODO(aomarks) Upstream improvements to https://github.com/tjwebb/fnv-plus/.\nconst hl = [];\nfor (let i = 0; i < 256; i++) {\n    hl[i] = ((i >> 4) & 15).toString(16) + (i & 15).toString(16);\n}\n/**\n * Perform a FNV-1A 64-bit hash of the given string (as UTF-16 code units), and\n * return a hexadecimal digest (left zero padded to 16 characters).\n *\n * @see {@link http://tools.ietf.org/html/draft-eastlake-fnv-06}\n */\nexport function fnv1a64(str) {\n    let t0 = 0, v0 = 0x2325, t1 = 0, v1 = 0x8422, t2 = 0, v2 = 0x9ce4, t3 = 0, v3 = 0xcbf2;\n    for (let i = 0; i < str.length; i++) {\n        v0 ^= str.charCodeAt(i);\n        t0 = v0 * 435;\n        t1 = v1 * 435;\n        t2 = v2 * 435;\n        t3 = v3 * 435;\n        t2 += v0 << 8;\n        t3 += v1 << 8;\n        t1 += t0 >>> 16;\n        v0 = t0 & 65535;\n        t2 += t1 >>> 16;\n        v1 = t1 & 65535;\n        v3 = (t3 + (t2 >>> 16)) & 65535;\n        v2 = t2 & 65535;\n    }\n    return (hl[v3 >> 8] +\n        hl[v3 & 255] +\n        hl[v2 >> 8] +\n        hl[v2 & 255] +\n        hl[v1 >> 8] +\n        hl[v1 & 255] +\n        hl[v0 >> 8] +\n        hl[v0 & 255]);\n}\n//# sourceMappingURL=fnv1a64.js.map","/**\n * @license\n * Copyright 2020 Google LLC\n * SPDX-License-Identifier: BSD-3-Clause\n */\nimport { fnv1a64 } from './fnv1a64.js';\n/**\n * Delimiter used between each template string component before hashing. Used to\n * prevent e.g. \"foobar\" and \"foo${baz}bar\" from sharing a hash.\n *\n * This is the \"record separator\" ASCII character.\n */\nexport const HASH_DELIMITER = '\\x1e';\n/**\n * Id prefix on html-tagged templates to distinguish e.g. `<b>x</b>` from\n * html`<b>x</b>`.\n */\nconst HTML_PREFIX = 'h';\n/**\n * Id prefix on plain string templates to distinguish e.g. `<b>x</b>` from\n * html`<b>x</b>`.\n */\nconst STRING_PREFIX = 's';\n/**\n * Generate a unique ID for a lit-localize message.\n *\n * Example:\n *   Template: html`Hello <b>${who}</b>!`\n *     Params: [\"Hello <b>\", \"</b>!\"], true\n *     Output: h82ccc38d4d46eaa9\n *\n * The ID is constructed as:\n *\n *   [0]    Kind of template: [h]tml or [s]tring.\n *   [1,16] 64-bit FNV-1a hash hex digest of the template strings, as UTF-16\n *          code points, delineated by an ASCII \"record separator\" character.\n *\n * We choose FNV-1a because:\n *\n *   1. It's pretty fast (e.g. much faster than SHA-1).\n *   2. It's pretty small (0.25 KiB minified + brotli).\n *   3. We don't require cryptographic security, and 64 bits should give\n *      sufficient collision resistance for any one application. Worst\n *      case, we will always detect collisions during analysis.\n *   4. We can't use Web Crypto API (e.g. SHA-1), because it's asynchronous.\n *   5. It's a well known non-cryptographic hash with implementations in many\n *      languages.\n *   6. There was an existing JavaScript implementation that doesn't require\n *      BigInt, for IE11 compatibility.\n */\nexport function generateMsgId(strings, isHtmlTagged) {\n    return ((isHtmlTagged ? HTML_PREFIX : STRING_PREFIX) +\n        fnv1a64(typeof strings === 'string' ? strings : strings.join(HASH_DELIMITER)));\n}\n//# sourceMappingURL=id-generation.js.map","/**\n * @license\n * Copyright 2021 Google LLC\n * SPDX-License-Identifier: BSD-3-Clause\n */\nimport { defaultMsg } from './default-msg.js';\nimport { joinStringsAndValues } from './str-tag.js';\nimport { generateMsgId } from './id-generation.js';\nconst expressionOrders = new WeakMap();\nconst hashCache = new Map();\nexport function runtimeMsg(templates, template, options) {\n    var _a;\n    if (templates) {\n        const id = (_a = options === null || options === void 0 ? void 0 : options.id) !== null && _a !== void 0 ? _a : generateId(template);\n        const localized = templates[id];\n        if (localized) {\n            if (typeof localized === 'string') {\n                // E.g. \"Hello World!\"\n                return localized;\n            }\n            else if ('strTag' in localized) {\n                // E.g. str`Hello ${name}!`\n                //\n                // Localized templates have ${number} in place of real template\n                // expressions. They can't have real template values, because the\n                // variable scope would be wrong. The number tells us the index of the\n                // source value to substitute in its place, because expressions can be\n                // moved to a different position during translation.\n                return joinStringsAndValues(localized.strings, \n                // Cast `template` because its type wasn't automatically narrowed (but\n                // we know it must be the same type as `localized`).\n                template.values, localized.values);\n            }\n            else {\n                // E.g. html`Hello <b>${name}</b>!`\n                //\n                // We have to keep our own mapping of expression ordering because we do\n                // an in-place update of `values`, and otherwise we'd lose ordering for\n                // subsequent renders.\n                let order = expressionOrders.get(localized);\n                if (order === undefined) {\n                    order = localized.values;\n                    expressionOrders.set(localized, order);\n                }\n                return {\n                    ...localized,\n                    values: order.map((i) => template.values[i]),\n                };\n            }\n        }\n    }\n    return defaultMsg(template);\n}\nfunction generateId(template) {\n    const strings = typeof template === 'string' ? template : template.strings;\n    let id = hashCache.get(strings);\n    if (id === undefined) {\n        id = generateMsgId(strings, typeof template !== 'string' && !('strTag' in template));\n        hashCache.set(strings, id);\n    }\n    return id;\n}\n//# sourceMappingURL=runtime-msg.js.map","/**\n * @license\n * Copyright 2021 Google LLC\n * SPDX-License-Identifier: BSD-3-Clause\n */\nimport { _installMsgImplementation } from '../lit-localize.js';\nimport { Deferred } from '../internal/deferred.js';\nimport { LOCALE_STATUS_EVENT } from '../internal/locale-status-event.js';\nimport { runtimeMsg } from '../internal/runtime-msg.js';\n/**\n * Dispatch a \"lit-localize-status\" event to `window` with the given detail.\n */\nfunction dispatchStatusEvent(detail) {\n    window.dispatchEvent(new CustomEvent(LOCALE_STATUS_EVENT, { detail }));\n}\nlet activeLocale = '';\nlet loadingLocale;\nlet sourceLocale;\nlet validLocales;\nlet loadLocale;\nlet templates;\nlet loading = new Deferred();\n// The loading promise must be initially resolved, because that's what we should\n// return if the user immediately calls setLocale(sourceLocale).\nloading.resolve();\nlet requestId = 0;\n/**\n * Set configuration parameters for lit-localize when in runtime mode. Returns\n * an object with functions:\n *\n * - `getLocale`: Return the active locale code.\n * - `setLocale`: Set the active locale code.\n *\n * Throws if called more than once.\n */\nexport const configureLocalization = (config) => {\n    _installMsgImplementation(((template, options) => runtimeMsg(templates, template, options)));\n    activeLocale = sourceLocale = config.sourceLocale;\n    validLocales = new Set(config.targetLocales);\n    validLocales.add(config.sourceLocale);\n    loadLocale = config.loadLocale;\n    return { getLocale, setLocale };\n};\n/**\n * Return the active locale code.\n */\nconst getLocale = () => {\n    return activeLocale;\n};\n/**\n * Set the active locale code, and begin loading templates for that locale using\n * the `loadLocale` function that was passed to `configureLocalization`. Returns\n * a promise that resolves when the next locale is ready to be rendered.\n *\n * Note that if a second call to `setLocale` is made while the first requested\n * locale is still loading, then the second call takes precedence, and the\n * promise returned from the first call will resolve when second locale is\n * ready. If you need to know whether a particular locale was loaded, check\n * `getLocale` after the promise resolves.\n *\n * Throws if the given locale is not contained by the configured `sourceLocale`\n * or `targetLocales`.\n */\nconst setLocale = (newLocale) => {\n    if (newLocale === (loadingLocale !== null && loadingLocale !== void 0 ? loadingLocale : activeLocale)) {\n        return loading.promise;\n    }\n    if (!validLocales || !loadLocale) {\n        throw new Error('Internal error');\n    }\n    if (!validLocales.has(newLocale)) {\n        throw new Error('Invalid locale code');\n    }\n    requestId++;\n    const thisRequestId = requestId;\n    loadingLocale = newLocale;\n    if (loading.settled) {\n        loading = new Deferred();\n    }\n    dispatchStatusEvent({ status: 'loading', loadingLocale: newLocale });\n    const localePromise = newLocale === sourceLocale\n        ? // We could switch to the source locale synchronously, but we prefer to\n            // queue it on a microtask so that switching locales is consistently\n            // asynchronous.\n            Promise.resolve({ templates: undefined })\n        : loadLocale(newLocale);\n    localePromise.then((mod) => {\n        if (requestId === thisRequestId) {\n            activeLocale = newLocale;\n            loadingLocale = undefined;\n            templates = mod.templates;\n            dispatchStatusEvent({ status: 'ready', readyLocale: newLocale });\n            loading.resolve();\n        }\n        // Else another locale was requested in the meantime. Don't resolve or\n        // reject, because the newer load call is going to use the same promise.\n        // Note the user can call getLocale() after the promise resolves if they\n        // need to check if the locale is still the one they expected to load.\n    }, (err) => {\n        if (requestId === thisRequestId) {\n            dispatchStatusEvent({\n                status: 'error',\n                errorLocale: newLocale,\n                errorMessage: err.toString(),\n            });\n            loading.reject(err);\n        }\n    });\n    return loading.promise;\n};\n//# sourceMappingURL=runtime.js.map","/**\n * @license\n * Copyright 2020 Google LLC\n * SPDX-License-Identifier: BSD-3-Clause\n */\nimport { defaultMsg } from './internal/default-msg.js';\nexport * from './internal/locale-status-event.js';\nexport * from './internal/str-tag.js';\nexport * from './internal/types.js';\n// TODO(aomarks) In a future breaking version, remove these imports so that the\n// bulk of the code isn't included in bundles by default. In particular imagine\n// the component library use-case where msg() calls are made, but there is no\n// need to actually initialize any of the localization runtime.\nexport * from './internal/localized-controller.js';\nexport * from './internal/localized-decorator.js';\nexport * from './init/runtime.js';\nexport * from './init/transform.js';\n/**\n * Make a string or lit-html template localizable.\n *\n * @param template A string, a lit-html template, or a function that returns\n * either a string or lit-html template.\n * @param options Optional configuration object with the following properties:\n *   - id: Optional project-wide unique identifier for this template. If\n *     omitted, an id will be automatically generated from the template strings.\n *   - desc: Optional description\n */\nexport let msg = defaultMsg;\nlet installed = false;\n/**\n * Internal only. Do not use this function.\n *\n * Installs an implementation of the msg function to replace the default\n * identity function. Throws if called more than once.\n *\n * @internal\n */\nexport function _installMsgImplementation(impl) {\n    if (installed) {\n        throw new Error('lit-localize can only be configured once');\n    }\n    msg = impl;\n    installed = true;\n}\n//# sourceMappingURL=lit-localize.js.map"],"names":["str","strings","values","strTag","joinStringsAndValues","valueOrder","concat","i","length","defaultMsg","template","isStrTagged","val","LOCALE_STATUS_EVENT","Deferred","constructor","this","settled","promise","Promise","resolve","reject","_resolve","_reject","value","error","hl","toString","generateMsgId","isHtmlTagged","t0","v0","t1","v1","t2","v2","t3","v3","charCodeAt","fnv1a64","join","expressionOrders","WeakMap","hashCache","Map","runtimeMsg","templates","options","_a","id","get","undefined","set","generateId","localized","order","map","dispatchStatusEvent","detail","window","dispatchEvent","CustomEvent","loadingLocale","sourceLocale","validLocales","loadLocale","activeLocale","loading","requestId","configureLocalization","config","impl","installed","Error","msg","_installMsgImplementation","Set","targetLocales","add","getLocale","setLocale","newLocale","has","thisRequestId","status","then","mod","readyLocale","err","errorLocale","errorMessage"],"mappings":";;;;;AAiBA,MAKaA,EALA,CAACC,KAAYC,KAAY,CAClCC,QAAQ,EACRF,UACAC,WAQSE,EAAuB,CAACH,EAASC,EAAQG,KAClD,IAAIC,EAASL,EAAQ,GACrB,IAAK,IAAIM,EAAI,EAAGA,EAAIN,EAAQO,OAAQD,IAChCD,GAAUJ,EAAOG,EAAaA,EAAWE,EAAI,GAAKA,EAAI,GACtDD,GAAUL,EAAQM,GAEtB,OAAOD,CAAM,ECvBJG,EAAeC,IAAaC,MDYU,iBAAvBC,ECZyBF,IDYU,WAAYE,ECXrER,EAAqBM,EAAST,QAASS,EAASR,QAChDQ,EDUqB,IAACE,CCVd,ECIDC,EAAsB;;;;;;ACZ5B,MAAMC,EACTC,cACIC,KAAKC,SAAU,EACfD,KAAKE,QAAU,IAAIC,SAAQ,CAACC,EAASC,KACjCL,KAAKM,SAAWF,EAChBJ,KAAKO,QAAUF,CAAM,GAE5B,CACDD,QAAQI,GACJR,KAAKC,SAAU,EACfD,KAAKM,SAASE,EACjB,CACDH,OAAOI,GACHT,KAAKC,SAAU,EACfD,KAAKO,QAAQE,EAChB;;;;;GCLL,MAAMC,EAAK,GACX,IAAK,IAAInB,EAAI,EAAGA,EAAI,IAAKA,IACrBmB,EAAGnB,IAAOA,GAAK,EAAK,IAAIoB,SAAS,KAAW,GAAJpB,GAAQoB,SAAS,ICiCtD,SAASC,EAAc3B,EAAS4B,GACnC,OAASA,EAlCO,IAKE,KDGf,SAAiB7B,GACpB,IAAI8B,EAAK,EAAGC,EAAK,KAAQC,EAAK,EAAGC,EAAK,MAAQC,EAAK,EAAGC,EAAK,MAAQC,EAAK,EAAGC,EAAK,MAChF,IAAK,IAAI9B,EAAI,EAAGA,EAAIP,EAAIQ,OAAQD,IAC5BwB,GAAM/B,EAAIsC,WAAW/B,GACrBuB,EAAU,IAALC,EACLC,EAAU,IAALC,EACLC,EAAU,IAALC,EACLC,EAAU,IAALC,EACLH,GAAMH,GAAM,EACZK,GAAMH,GAAM,EACZD,GAAMF,IAAO,GACbC,EAAU,MAALD,EACLI,GAAMF,IAAO,GACbC,EAAU,MAALD,EACLK,EAAMD,GAAMF,IAAO,IAAO,MAC1BC,EAAU,MAALD,EAET,OAAQR,EAAGW,GAAM,GACbX,EAAQ,IAALW,GACHX,EAAGS,GAAM,GACTT,EAAQ,IAALS,GACHT,EAAGO,GAAM,GACTP,EAAQ,IAALO,GACHP,EAAGK,GAAM,GACTL,EAAQ,IAALK,EACX;;;;;GCEQQ,CAA2B,iBAAZtC,EAAuBA,EAAUA,EAAQuC,KAxClC,KAyC9B;;;;;GC7CA,MAAMC,EAAmB,IAAIC,QACvBC,EAAY,IAAIC,IACf,SAASC,EAAWC,EAAWpC,EAAUqC,GAC5C,IAAIC,EACJ,GAAIF,EAAW,CACX,MAAMG,EAA6E,QAAvED,EAAKD,aAAyC,EAASA,EAAQE,UAAuB,IAAPD,EAAgBA,EAwCnH,SAAoBtC,GAChB,MAAMT,EAA8B,iBAAbS,EAAwBA,EAAWA,EAAST,QACnE,IAAIgD,EAAKN,EAAUO,IAAIjD,QACZkD,IAAPF,IACAA,EAAKrB,EAAc3B,EAA6B,iBAAbS,KAA2B,WAAYA,IAC1EiC,EAAUS,IAAInD,EAASgD,IAE3B,OAAOA,CACX;;;;;GAhDwHI,CAAW3C,GACrH4C,EAAYR,EAAUG,GAC5B,GAAIK,EAAW,CACX,GAAyB,iBAAdA,EAEP,OAAOA,EAEN,GAAI,WAAYA,EAQjB,OAAOlD,EAAqBkD,EAAUrD,QAGtCS,EAASR,OAAQoD,EAAUpD,QAE1B,CAMD,IAAIqD,EAAQd,EAAiBS,IAAII,GAKjC,YAJcH,IAAVI,IACAA,EAAQD,EAAUpD,OAClBuC,EAAiBW,IAAIE,EAAWC,IAE7B,IACAD,EACHpD,OAAQqD,EAAMC,KAAKjD,GAAMG,EAASR,OAAOK,KAEhD,CACJ,CACJ,CACD,OAAOE,EAAWC,EACtB,CCxCA,SAAS+C,EAAoBC,GACzBC,OAAOC,cAAc,IAAIC,YLIM,sBKJ2B,CAAEH,WAChE,CACA,IACII,EACAC,EACAC,EACAC,EACAnB,EALAoB,EAAe,GAMfC,EAAU,IAAIrD,EAGlBqD,EAAQ/C,UACR,IAAIgD,EAAY,EAUJ,MAACC,EAAyBC,ICE/B,SAAmCC,GACtC,GAAIC,EACA,MAAM,IAAIC,MAAM,4CAEpBC,EAAMH,EACNC,GAAY,CAChB,CDPIG,EAA2B,CAACjE,EAAUqC,IAAYF,EAAWC,EAAWpC,EAAUqC,KAClFmB,EAAeH,EAAeO,EAAOP,aACrCC,EAAe,IAAIY,IAAIN,EAAOO,eAC9Bb,EAAac,IAAIR,EAAOP,cACxBE,EAAaK,EAAOL,WACb,CAAEc,YAAWC,cAKlBD,EAAY,IACPb,EAgBLc,EAAaC,IACf,GAAIA,KAAenB,QAAqDA,EAAgBI,GACpF,OAAOC,EAAQjD,QAEnB,IAAK8C,IAAiBC,EAClB,MAAM,IAAIQ,MAAM,kBAEpB,IAAKT,EAAakB,IAAID,GAClB,MAAM,IAAIR,MAAM,uBAEpBL,IACA,MAAMe,EAAgBf,EACtBN,EAAgBmB,EACZd,EAAQlD,UACRkD,EAAU,IAAIrD,GAElB2C,EAAoB,CAAE2B,OAAQ,UAAWtB,cAAemB,IA6BxD,OA5BsBA,IAAclB,EAI5B5C,QAAQC,QAAQ,CAAE0B,eAAWK,IAC/Bc,EAAWgB,IACHI,MAAMC,IACZlB,IAAce,IACdjB,EAAee,EACfnB,OAAgBX,EAChBL,EAAYwC,EAAIxC,UAChBW,EAAoB,CAAE2B,OAAQ,QAASG,YAAaN,IACpDd,EAAQ/C,UACX,IAKDoE,IACIpB,IAAce,IACd1B,EAAoB,CAChB2B,OAAQ,QACRK,YAAaR,EACbS,aAAcF,EAAI7D,aAEtBwC,EAAQ9C,OAAOmE,GAClB,IAEErB,EAAQjD,OAAO;;;;;;ACjFhB,IAACwD,EAAMjE,EACb+D,GAAY"}